## API Report File for "@fp-tx/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
function absurd<A>(_: never): A;

// @public (undocumented)
interface Alt<F> extends Functor<F> {
    // (undocumented)
    readonly alt: <A>(fa: HKT<F, A>, that: LazyArg<HKT<F, A>>) => HKT<F, A>;
}

declare namespace alt {
    export {
        altAll,
        Alt,
        Alt1,
        Alt2,
        Alt2C,
        Alt3,
        Alt3C,
        Alt4
    }
}
export { alt }

// @public (undocumented)
interface Alt1<F extends URIS> extends Functor1<F> {
    // (undocumented)
    readonly alt: <A>(fa: Kind<F, A>, that: LazyArg<Kind<F, A>>) => Kind<F, A>;
}

// @public (undocumented)
interface Alt2<F extends URIS2> extends Functor2<F> {
    // (undocumented)
    readonly alt: <E, A>(fa: Kind2<F, E, A>, that: LazyArg<Kind2<F, E, A>>) => Kind2<F, E, A>;
}

// @public (undocumented)
interface Alt2C<F extends URIS2, E> extends Functor2C<F, E> {
    // (undocumented)
    readonly alt: <A>(fa: Kind2<F, E, A>, that: LazyArg<Kind2<F, E, A>>) => Kind2<F, E, A>;
}

// @public (undocumented)
interface Alt3<F extends URIS3> extends Functor3<F> {
    // (undocumented)
    readonly alt: <R, E, A>(fa: Kind3<F, R, E, A>, that: LazyArg<Kind3<F, R, E, A>>) => Kind3<F, R, E, A>;
}

// @public (undocumented)
interface Alt3C<F extends URIS3, E> extends Functor3C<F, E> {
    // (undocumented)
    readonly alt: <R, A>(fa: Kind3<F, R, E, A>, that: LazyArg<Kind3<F, R, E, A>>) => Kind3<F, R, E, A>;
}

// @public (undocumented)
interface Alt4<F extends URIS4> extends Functor4<F> {
    // (undocumented)
    readonly alt: <S, R, E, A>(fa: Kind4<F, S, R, E, A>, that: LazyArg<Kind4<F, S, R, E, A>>) => Kind4<F, S, R, E, A>;
}

// @public (undocumented)
const Alt_10: Alt3<URI_18>;

// @public (undocumented)
const alt_10: <A>(second: LazyArg<IOOption<A>>) => (first: IOOption<A>) => IOOption<A>;

// @public (undocumented)
const Alt_11: Alt2<URI_23>;

// @public (undocumented)
function alt_11<M extends URIS4>(M: Monad4<M>): <S, R, E, A>(second: LazyArg<Kind4<M, S, R, E, Option_2<A>>>) => (first: Kind4<M, S, R, E, Option_2<A>>) => Kind4<M, S, R, E, Option_2<A>>;

// @public (undocumented)
function alt_11<M extends URIS3>(M: Monad3<M>): <R, E, A>(second: LazyArg<Kind3<M, R, E, Option_2<A>>>) => (first: Kind3<M, R, E, Option_2<A>>) => Kind3<M, R, E, Option_2<A>>;

// @public (undocumented)
function alt_11<M extends URIS3, E>(M: Monad3C<M, E>): <R, A>(second: LazyArg<Kind3<M, R, E, Option_2<A>>>) => (first: Kind3<M, R, E, Option_2<A>>) => Kind3<M, R, E, Option_2<A>>;

// @public (undocumented)
function alt_11<M extends URIS2>(M: Monad2<M>): <E, A>(second: LazyArg<Kind2<M, E, Option_2<A>>>) => (first: Kind2<M, E, Option_2<A>>) => Kind2<M, E, Option_2<A>>;

// @public (undocumented)
function alt_11<M extends URIS2, E>(M: Monad2C<M, E>): <A>(second: LazyArg<Kind2<M, E, Option_2<A>>>) => (first: Kind2<M, E, Option_2<A>>) => Kind2<M, E, Option_2<A>>;

// @public (undocumented)
function alt_11<M extends URIS>(M: Monad1<M>): <A>(second: LazyArg<Kind<M, Option_2<A>>>) => (first: Kind<M, Option_2<A>>) => Kind<M, Option_2<A>>;

// @public (undocumented)
function alt_11<M>(M: Monad_6<M>): <A>(second: LazyArg<HKT<M, Option_2<A>>>) => (first: HKT<M, Option_2<A>>) => HKT<M, Option_2<A>>;

// @public (undocumented)
const Alt_12: Alt3<URI_22>;

// @public
function alt_12<F extends URIS4>(F: Alt4<F>): <S, R, E, A>(that: LazyArg<Kind4<F, S, R, E, A>>) => (fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>;

// @public (undocumented)
function alt_12<F extends URIS3>(F: Alt3<F>): <R, E, A>(that: LazyArg<Kind3<F, R, E, A>>) => (fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;

// @public (undocumented)
function alt_12<F extends URIS3, E>(F: Alt3C<F, E>): <R, A>(that: LazyArg<Kind3<F, R, E, A>>) => (fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;

// @public (undocumented)
function alt_12<F extends URIS2>(F: Alt2<F>): <E, A>(that: LazyArg<Kind2<F, E, A>>) => (fa: Kind2<F, E, A>) => Kind2<F, E, A>;

// @public (undocumented)
function alt_12<F extends URIS2, E>(F: Alt2C<F, E>): <A>(that: LazyArg<Kind2<F, E, A>>) => (fa: Kind2<F, E, A>) => Kind2<F, E, A>;

// @public (undocumented)
function alt_12<F extends URIS>(F: Alt1<F>): <A>(that: LazyArg<Kind<F, A>>) => (fa: Kind<F, A>) => Kind<F, A>;

// @public (undocumented)
function alt_12<F>(F: Alt<F>): <A>(that: LazyArg<HKT<F, A>>) => (fa: HKT<F, A>) => HKT<F, A>;

// @public (undocumented)
const Alt_13: Alt1<URI_24>;

// @public
const alt_13: <R, E, A>(that: () => ReaderEither<R, E, A>) => (fa: ReaderEither<R, E, A>) => ReaderEither<R, E, A>;

// @public (undocumented)
const Alt_14: Alt4<URI_31>;

// @public
const alt_14: <E, A>(that: LazyArg<TaskEither<E, A>>) => (fa: TaskEither<E, A>) => TaskEither<E, A>;

// @public (undocumented)
const Alt_15: Alt1<URI_33>;

// @public
const alt_15: <R, E, A>(that: () => ReaderTaskEither<R, E, A>) => (fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;

// @public
const alt_16: <A>(that: LazyArg<ReadonlyArray<A>>) => (fa: ReadonlyArray<A>) => ReadonlyArray<A>;

// @public
const alt_17: <S, R, E, A>(that: LazyArg<StateReaderTaskEither<S, R, E, A>>) => (fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const alt_18: <A>(second: LazyArg<TaskOption<A>>) => (first: TaskOption<A>) => TaskOption<A>;

// @public (undocumented)
const Alt_2: Alt1<URI_2>;

// @public
const alt_2: <A>(that: LazyArg<ReadonlyNonEmptyArray<A>>) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public (undocumented)
const Alt_3: Alt1<URI_3>;

// @public
const alt_3: <A>(that: LazyArg<NonEmptyArray<A>>) => (fa: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public (undocumented)
const Alt_4: Alt1<URI_4>;

// @public
const alt_4: <A>(that: LazyArg<Array<A>>) => (fa: Array<A>) => Array<A>;

// @public (undocumented)
const Alt_5: Alt1<URI_7>;

// @public
const alt_5: <A>(that: LazyArg<Option_2<A>>) => (fa: Option_2<A>) => Option_2<A>;

// @public (undocumented)
const Alt_6: Alt2<URI_6>;

// @public
const alt_6: <E, A>(that: LazyArg<Either<E, A>>) => (fa: Either<E, A>) => Either<E, A>;

// @public (undocumented)
const Alt_7: Alt1<URI_11>;

// @public (undocumented)
function alt_7<M extends URIS3>(M: Monad3<M>): <R, ME, E, A>(second: LazyArg<Kind3<M, R, ME, Either<E, A>>>) => (first: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, A>>;

// @public (undocumented)
function alt_7<M extends URIS3, ME>(M: Monad3C<M, ME>): <R, E, A>(second: LazyArg<Kind3<M, R, ME, Either<E, A>>>) => (first: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, A>>;

// @public (undocumented)
function alt_7<M extends URIS2>(M: Monad2<M>): <ME, E, A>(second: LazyArg<Kind2<M, ME, Either<E, A>>>) => (first: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, A>>;

// @public (undocumented)
function alt_7<M extends URIS2, ME>(M: Monad2C<M, ME>): <E, A>(second: LazyArg<Kind2<M, ME, Either<E, A>>>) => (first: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, A>>;

// @public (undocumented)
function alt_7<M extends URIS>(M: Monad1<M>): <E, A>(second: LazyArg<Kind<M, Either<E, A>>>) => (first: Kind<M, Either<E, A>>) => Kind<M, Either<E, A>>;

// @public (undocumented)
function alt_7<M>(M: Monad_6<M>): <E, A>(second: LazyArg<HKT<M, Either<E, A>>>) => (first: HKT<M, Either<E, A>>) => HKT<M, Either<E, A>>;

// @public (undocumented)
const Alt_8: Alt2<URI_13>;

// @public
const alt_8: <A>(that: () => Identity<A>) => (fa: Identity<A>) => Identity<A>;

// @public (undocumented)
const Alt_9: Alt1<URI_14>;

// @public
const alt_9: <E, A>(that: LazyArg<IOEither<E, A>>) => (fa: IOEither<E, A>) => IOEither<E, A>;

// @public (undocumented)
function altAll<F extends URIS4>(F: Alt4<F>): <S, R, E, A>(startWith: Kind4<F, S, R, E, A>) => (as: ReadonlyArray<Kind4<F, S, R, E, A>>) => Kind4<F, S, R, E, A>;

// @public (undocumented)
function altAll<F extends URIS3>(F: Alt3<F>): <R, E, A>(startWith: Kind3<F, R, E, A>) => (as: ReadonlyArray<Kind3<F, R, E, A>>) => Kind3<F, R, E, A>;

// @public (undocumented)
function altAll<F extends URIS3, E>(F: Alt3C<F, E>): <R, A>(startWith: Kind3<F, R, E, A>) => (as: ReadonlyArray<Kind3<F, R, E, A>>) => Kind3<F, R, E, A>;

// @public (undocumented)
function altAll<F extends URIS2>(F: Alt2<F>): <E, A>(startWith: Kind2<F, E, A>) => (as: ReadonlyArray<Kind2<F, E, A>>) => Kind2<F, E, A>;

// @public (undocumented)
function altAll<F extends URIS2, E>(F: Alt2C<F, E>): <A>(startWith: Kind2<F, E, A>) => (as: ReadonlyArray<Kind2<F, E, A>>) => Kind2<F, E, A>;

// @public (undocumented)
function altAll<F extends URIS>(F: Alt1<F>): <A>(startWith: Kind<F, A>) => (as: ReadonlyArray<Kind<F, A>>) => Kind<F, A>;

// @public (undocumented)
function altAll<F>(F: Alt<F>): <A>(startWith: HKT<F, A>) => (as: ReadonlyArray<HKT<F, A>>) => HKT<F, A>;

// @public (undocumented)
function altAll_2<F extends URIS4>(F: Alternative4<F>): <S, R, E, A>(as: ReadonlyArray<Kind4<F, S, R, E, A>>) => Kind4<F, S, R, E, A>;

// @public (undocumented)
function altAll_2<F extends URIS3>(F: Alternative3<F>): <R, E, A>(as: ReadonlyArray<Kind3<F, R, E, A>>) => Kind3<F, R, E, A>;

// @public (undocumented)
function altAll_2<F extends URIS3, E>(F: Alternative3C<F, E>): <R, A>(as: ReadonlyArray<Kind3<F, R, E, A>>) => Kind3<F, R, E, A>;

// @public (undocumented)
function altAll_2<F extends URIS2>(F: Alternative2<F>): <E, A>(as: ReadonlyArray<Kind2<F, E, A>>) => Kind2<F, E, A>;

// @public (undocumented)
function altAll_2<F extends URIS2, E>(F: Alternative2C<F, E>): <A>(as: ReadonlyArray<Kind2<F, E, A>>) => Kind2<F, E, A>;

// @public (undocumented)
function altAll_2<F extends URIS>(F: Alternative1<F>): <A>(as: ReadonlyArray<Kind<F, A>>) => Kind<F, A>;

// @public (undocumented)
function altAll_2<F>(F: Alternative<F>): <A>(as: ReadonlyArray<HKT<F, A>>) => HKT<F, A>;

// @public (undocumented)
interface Alternative<F> extends Applicative<F>, Alt<F>, Zero<F> {
}

declare namespace alternative {
    export {
        altAll_2 as altAll,
        getAlternativeMonoid,
        Alternative,
        Alternative1,
        Alternative2,
        Alternative2C,
        Alternative3,
        Alternative3C,
        Alternative4
    }
}
export { alternative }

// @public (undocumented)
interface Alternative1<F extends URIS> extends Applicative1<F>, Alt1<F>, Zero1<F> {
}

// @public (undocumented)
interface Alternative2<F extends URIS2> extends Applicative2<F>, Alt2<F>, Zero2<F> {
}

// @public (undocumented)
interface Alternative2C<F extends URIS2, E> extends Applicative2C<F, E>, Alt2C<F, E>, Zero2C<F, E> {
}

// @public (undocumented)
interface Alternative3<F extends URIS3> extends Applicative3<F>, Alt3<F>, Zero3<F> {
}

// @public (undocumented)
interface Alternative3C<F extends URIS3, E> extends Applicative3C<F, E>, Alt3C<F, E>, Zero3C<F, E> {
}

// @public (undocumented)
interface Alternative4<F extends URIS4> extends Applicative4<F>, Alt4<F>, Zero4<F> {
}

// @public (undocumented)
const Alternative_2: Alternative1<URI_4>;

// @public (undocumented)
const Alternative_3: Alternative1<URI_7>;

// @public (undocumented)
const Alternative_4: Alternative1<URI_14>;

// @public (undocumented)
const Alternative_5: Alternative1<URI_24>;

// @public (undocumented)
const Alternative_6: Alternative1<URI_33>;

// @public (undocumented)
function altValidation<M extends URIS3, E>(M: Monad3<M>, S: Semigroup<E>): <R, ME, A>(second: LazyArg<Kind3<M, R, ME, Either<E, A>>>) => (first: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, A>>;

// @public (undocumented)
function altValidation<M extends URIS3, ME, E>(M: Monad3C<M, ME>, S: Semigroup<E>): <R, A>(second: LazyArg<Kind3<M, R, ME, Either<E, A>>>) => (first: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, A>>;

// @public (undocumented)
function altValidation<M extends URIS2, E>(M: Monad2<M>, S: Semigroup<E>): <ME, A>(second: LazyArg<Kind2<M, ME, Either<E, A>>>) => (first: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, A>>;

// @public (undocumented)
function altValidation<M extends URIS2, ME, E>(M: Monad2C<M, ME>, S: Semigroup<E>): <A>(second: LazyArg<Kind2<M, ME, Either<E, A>>>) => (first: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, A>>;

// @public (undocumented)
function altValidation<M extends URIS, E>(M: Monad1<M>, S: Semigroup<E>): <A>(second: LazyArg<Kind<M, Either<E, A>>>) => (first: Kind<M, Either<E, A>>) => Kind<M, Either<E, A>>;

// @public (undocumented)
function altValidation<M, E>(M: Monad_6<M>, S: Semigroup<E>): <A>(second: LazyArg<HKT<M, Either<E, A>>>) => (first: HKT<M, Either<E, A>>) => HKT<M, Either<E, A>>;

// @public
const altW: <B>(that: LazyArg<ReadonlyNonEmptyArray<B>>) => <A>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B | A>;

// @public
const altW_10: <E2, B>(that: LazyArg<TaskEither<E2, B>>) => <E1, A>(fa: TaskEither<E1, A>) => TaskEither<E2, A | B>;

// @public
const altW_11: <R2, E2, B>(that: () => ReaderTaskEither<R2, E2, B>) => <R1, E1, A>(fa: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E2, A | B>;

// @public
const altW_12: <B>(that: LazyArg<readonly B[]>) => <A>(fa: readonly A[]) => readonly (B | A)[];

// @public
const altW_13: <S, R2, E2, B>(that: () => StateReaderTaskEither<S, R2, E2, B>) => <R1, E1, A>(fa: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E2, B | A>;

// @public
const altW_14: <B>(second: LazyArg<TaskOption<B>>) => <A>(first: TaskOption<A>) => TaskOption<A | B>;

// @public
const altW_2: <B>(that: LazyArg<NonEmptyArray<B>>) => <A>(as: NonEmptyArray<A>) => NonEmptyArray<B | A>;

// @public
const altW_3: <B>(that: LazyArg<B[]>) => <A>(fa: A[]) => (B | A)[];

// @public
const altW_4: <B>(that: LazyArg<Option_2<B>>) => <A>(fa: Option_2<A>) => Option_2<A | B>;

// @public
const altW_5: <E2, B>(that: LazyArg<Either<E2, B>>) => <E1, A>(fa: Either<E1, A>) => Either<E2, A | B>;

// @public
const altW_6: <B>(that: () => Identity<B>) => <A>(fa: Identity<A>) => Identity<A | B>;

// @public
const altW_7: <E2, B>(that: LazyArg<IOEither<E2, B>>) => <E1, A>(fa: IOEither<E1, A>) => IOEither<E2, A | B>;

// @public
const altW_8: <B>(second: LazyArg<IOOption<B>>) => <A>(first: IOOption<A>) => IOOption<A | B>;

// @public
const altW_9: <R2, E2, B>(that: () => ReaderEither<R2, E2, B>) => <R1, E1, A>(fa: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E2, A | B>;

// @public (undocumented)
const and: <A>(second: Predicate<A>) => (first: Predicate<A>) => Predicate<A>;

// @public (undocumented)
const and_2: <A, C extends A>(second: Refinement<A, C>) => <B extends A>(first: Refinement<A, B>) => Refinement<A, B & C>;

// @public
function ap<F extends URIS4, G extends URIS4>(F: Apply4<F>, G: Apply4<G>): <FS, FR, FE, GS, GR, GE, A>(fa: Kind4<F, FS, FR, FE, Kind4<G, GS, GR, GE, A>>) => <B>(fab: Kind4<F, FS, FR, FE, Kind4<G, GS, GR, GE, (a: A) => B>>) => Kind4<F, FS, FR, FE, Kind4<G, GS, GR, GE, B>>;

// @public (undocumented)
function ap<F extends URIS4, G extends URIS3>(F: Apply4<F>, G: Apply3<G>): <S, FR, FE, GR, GE, A>(fa: Kind4<F, S, FR, FE, Kind3<G, GR, GE, A>>) => <B>(fab: Kind4<F, S, FR, FE, Kind3<G, GR, GE, (a: A) => B>>) => Kind4<F, S, FR, FE, Kind3<G, GR, GE, B>>;

// @public (undocumented)
function ap<F extends URIS4, G extends URIS3, GE>(F: Apply4<F>, G: Apply3C<G, GE>): <S, FR, FE, GR, A>(fa: Kind4<F, S, FR, FE, Kind3<G, GR, GE, A>>) => <B>(fab: Kind4<F, S, FR, FE, Kind3<G, GR, GE, (a: A) => B>>) => Kind4<F, S, FR, FE, Kind3<G, GR, GE, B>>;

// @public (undocumented)
function ap<F extends URIS4, G extends URIS2>(F: Apply4<F>, G: Apply2<G>): <S, R, FE, GE, A>(fa: Kind4<F, S, R, FE, Kind2<G, GE, A>>) => <B>(fab: Kind4<F, S, R, FE, Kind2<G, GE, (a: A) => B>>) => Kind4<F, S, R, FE, Kind2<G, GE, B>>;

// @public (undocumented)
function ap<F extends URIS4, G extends URIS2, GE>(F: Apply4<F>, G: Apply2C<G, GE>): <S, R, FE, A>(fa: Kind4<F, S, R, FE, Kind2<G, GE, A>>) => <B>(fab: Kind4<F, S, R, FE, Kind2<G, GE, (a: A) => B>>) => Kind4<F, S, R, FE, Kind2<G, GE, B>>;

// @public (undocumented)
function ap<F extends URIS4, G extends URIS>(F: Apply4<F>, G: Apply1<G>): <S, R, E, A>(fa: Kind4<F, S, R, E, Kind<G, A>>) => <B>(fab: Kind4<F, S, R, E, Kind<G, (a: A) => B>>) => Kind4<F, S, R, E, Kind<G, B>>;

// @public (undocumented)
function ap<F extends URIS3, FE, G extends URIS4>(F: Apply3C<F, FE>, G: Apply4<G>): <FR, S, GR, GE, A>(fa: Kind3<F, FR, FE, Kind4<G, S, GR, GE, A>>) => <B>(fab: Kind3<F, FR, FE, Kind4<G, S, GR, GE, (a: A) => B>>) => Kind3<F, FR, FE, Kind4<G, S, GR, GE, B>>;

// @public (undocumented)
function ap<F extends URIS3, FE, G extends URIS3>(F: Apply3C<F, FE>, G: Apply3<G>): <FR, GR, GE, A>(fa: Kind3<F, FR, FE, Kind3<G, GR, GE, A>>) => <B>(fab: Kind3<F, FR, FE, Kind3<G, GR, GE, (a: A) => B>>) => Kind3<F, FR, FE, Kind3<G, GR, GE, B>>;

// @public (undocumented)
function ap<F extends URIS3, FE, G extends URIS3, GE>(F: Apply3C<F, FE>, G: Apply3C<G, GE>): <FR, GR, A>(fa: Kind3<F, FR, FE, Kind3<G, GR, GE, A>>) => <B>(fab: Kind3<F, FR, FE, Kind3<G, GR, GE, (a: A) => B>>) => Kind3<F, FR, FE, Kind3<G, GR, GE, B>>;

// @public (undocumented)
function ap<F extends URIS3, FE, G extends URIS2>(F: Apply3C<F, FE>, G: Apply2<G>): <R, GE, A>(fa: Kind3<F, R, FE, Kind2<G, GE, A>>) => <B>(fab: Kind3<F, R, FE, Kind2<G, GE, (a: A) => B>>) => Kind3<F, R, FE, Kind2<G, GE, B>>;

// @public (undocumented)
function ap<F extends URIS3, FE, G extends URIS2, GE>(F: Apply3C<F, FE>, G: Apply2C<G, GE>): <R, A>(fa: Kind3<F, R, FE, Kind2<G, GE, A>>) => <B>(fab: Kind3<F, R, FE, Kind2<G, GE, (a: A) => B>>) => Kind3<F, R, FE, Kind2<G, GE, B>>;

// @public (undocumented)
function ap<F extends URIS3, E, G extends URIS>(F: Apply3C<F, E>, G: Apply1<G>): <R, A>(fa: Kind3<F, R, E, Kind<G, A>>) => <B>(fab: Kind3<F, R, E, Kind<G, (a: A) => B>>) => Kind3<F, R, E, Kind<G, B>>;

// @public (undocumented)
function ap<F extends URIS3, G extends URIS4>(F: Apply3<F>, G: Apply4<G>): <FR, FE, S, GR, GE, A>(fa: Kind3<F, FR, FE, Kind4<G, S, GR, GE, A>>) => <B>(fab: Kind3<F, FR, FE, Kind4<G, S, GR, GE, (a: A) => B>>) => Kind3<F, FR, FE, Kind4<G, S, GR, GE, B>>;

// @public (undocumented)
function ap<F extends URIS3, G extends URIS3>(F: Apply3<F>, G: Apply3<G>): <FR, FE, GR, GE, A>(fa: Kind3<F, FR, FE, Kind3<G, GR, GE, A>>) => <B>(fab: Kind3<F, FR, FE, Kind3<G, GR, GE, (a: A) => B>>) => Kind3<F, FR, FE, Kind3<G, GR, GE, B>>;

// @public (undocumented)
function ap<F extends URIS3, G extends URIS3, GE>(F: Apply3<F>, G: Apply3C<G, GE>): <FR, FE, GR, A>(fa: Kind3<F, FR, FE, Kind3<G, GR, GE, A>>) => <B>(fab: Kind3<F, FR, FE, Kind3<G, GR, GE, (a: A) => B>>) => Kind3<F, FR, FE, Kind3<G, GR, GE, B>>;

// @public (undocumented)
function ap<F extends URIS3, G extends URIS2>(F: Apply3<F>, G: Apply2<G>): <R, FE, GE, A>(fa: Kind3<F, R, FE, Kind2<G, GE, A>>) => <B>(fab: Kind3<F, R, FE, Kind2<G, GE, (a: A) => B>>) => Kind3<F, R, FE, Kind2<G, GE, B>>;

// @public (undocumented)
function ap<F extends URIS3, G extends URIS2, GE>(F: Apply3<F>, G: Apply2C<G, GE>): <R, FE, A>(fa: Kind3<F, R, FE, Kind2<G, GE, A>>) => <B>(fab: Kind3<F, R, FE, Kind2<G, GE, (a: A) => B>>) => Kind3<F, R, FE, Kind2<G, GE, B>>;

// @public (undocumented)
function ap<F extends URIS3, G extends URIS>(F: Apply3<F>, G: Apply1<G>): <R, E, A>(fa: Kind3<F, R, E, Kind<G, A>>) => <B>(fab: Kind3<F, R, E, Kind<G, (a: A) => B>>) => Kind3<F, R, E, Kind<G, B>>;

// @public (undocumented)
function ap<F extends URIS2, FE, G extends URIS4>(F: Apply2C<F, FE>, G: Apply4<G>): <S, R, GE, A>(fa: Kind2<F, FE, Kind4<G, S, R, GE, A>>) => <B>(fab: Kind2<F, FE, Kind4<G, S, R, GE, (a: A) => B>>) => Kind2<F, FE, Kind4<G, S, R, GE, B>>;

// @public (undocumented)
function ap<F extends URIS2, FE, G extends URIS3>(F: Apply2C<F, FE>, G: Apply3<G>): <R, GE, A>(fa: Kind2<F, FE, Kind3<G, R, GE, A>>) => <B>(fab: Kind2<F, FE, Kind3<G, R, GE, (a: A) => B>>) => Kind2<F, FE, Kind3<G, R, GE, B>>;

// @public (undocumented)
function ap<F extends URIS2, FE, G extends URIS3, GE>(F: Apply2C<F, FE>, G: Apply3C<G, GE>): <R, A>(fa: Kind2<F, FE, Kind3<G, R, GE, A>>) => <B>(fab: Kind2<F, FE, Kind3<G, R, GE, (a: A) => B>>) => Kind2<F, FE, Kind3<G, R, GE, B>>;

// @public (undocumented)
function ap<F extends URIS2, FE, G extends URIS2>(F: Apply2C<F, FE>, G: Apply2<G>): <GE, A>(fa: Kind2<F, FE, Kind2<G, GE, A>>) => <B>(fab: Kind2<F, FE, Kind2<G, GE, (a: A) => B>>) => Kind2<F, FE, Kind2<G, GE, B>>;

// @public (undocumented)
function ap<F extends URIS2, FE, G extends URIS2, GE>(F: Apply2C<F, FE>, G: Apply2C<G, GE>): <A>(fa: Kind2<F, FE, Kind2<G, GE, A>>) => <B>(fab: Kind2<F, FE, Kind2<G, GE, (a: A) => B>>) => Kind2<F, FE, Kind2<G, GE, B>>;

// @public (undocumented)
function ap<F extends URIS2, E, G extends URIS>(F: Apply2C<F, E>, G: Apply1<G>): <A>(fa: Kind2<F, E, Kind<G, A>>) => <B>(fab: Kind2<F, E, Kind<G, (a: A) => B>>) => Kind2<F, E, Kind<G, B>>;

// @public (undocumented)
function ap<F extends URIS2, G extends URIS4>(F: Apply2<F>, G: Apply4<G>): <FE, S, R, GE, A>(fa: Kind2<F, FE, Kind4<G, S, R, GE, A>>) => <B>(fab: Kind2<F, FE, Kind4<G, S, R, GE, (a: A) => B>>) => Kind2<F, FE, Kind4<G, S, R, GE, B>>;

// @public (undocumented)
function ap<F extends URIS2, G extends URIS3>(F: Apply2<F>, G: Apply3<G>): <FE, R, GE, A>(fa: Kind2<F, FE, Kind3<G, R, GE, A>>) => <B>(fab: Kind2<F, FE, Kind3<G, R, GE, (a: A) => B>>) => Kind2<F, FE, Kind3<G, R, GE, B>>;

// @public (undocumented)
function ap<F extends URIS2, G extends URIS3, GE>(F: Apply2<F>, G: Apply3C<G, GE>): <FE, R, A>(fa: Kind2<F, FE, Kind3<G, R, GE, A>>) => <B>(fab: Kind2<F, FE, Kind3<G, R, GE, (a: A) => B>>) => Kind2<F, FE, Kind3<G, R, GE, B>>;

// @public (undocumented)
function ap<F extends URIS2, G extends URIS2>(F: Apply2<F>, G: Apply2<G>): <FE, GE, A>(fa: Kind2<F, FE, Kind2<G, GE, A>>) => <B>(fab: Kind2<F, FE, Kind2<G, GE, (a: A) => B>>) => Kind2<F, FE, Kind2<G, GE, B>>;

// @public (undocumented)
function ap<F extends URIS2, G extends URIS2, GE>(F: Apply2<F>, G: Apply2C<G, GE>): <FE, A>(fa: Kind2<F, FE, Kind2<G, GE, A>>) => <B>(fab: Kind2<F, FE, Kind2<G, GE, (a: A) => B>>) => Kind2<F, FE, Kind2<G, GE, B>>;

// @public (undocumented)
function ap<F extends URIS2, G extends URIS>(F: Apply2<F>, G: Apply1<G>): <E, A>(fa: Kind2<F, E, Kind<G, A>>) => <B>(fab: Kind2<F, E, Kind<G, (a: A) => B>>) => Kind2<F, E, Kind<G, B>>;

// @public (undocumented)
function ap<F extends URIS, G extends URIS4>(F: Apply1<F>, G: Apply4<G>): <S, R, E, A>(fa: Kind<F, Kind4<G, S, R, E, A>>) => <B>(fab: Kind<F, Kind4<G, S, R, E, (a: A) => B>>) => Kind<F, Kind4<G, S, R, E, B>>;

// @public (undocumented)
function ap<F extends URIS, G extends URIS3>(F: Apply1<F>, G: Apply3<G>): <R, E, A>(fa: Kind<F, Kind3<G, R, E, A>>) => <B>(fab: Kind<F, Kind3<G, R, E, (a: A) => B>>) => Kind<F, Kind3<G, R, E, B>>;

// @public (undocumented)
function ap<F extends URIS, G extends URIS3, E>(F: Apply1<F>, G: Apply3C<G, E>): <R, A>(fa: Kind<F, Kind3<G, R, E, A>>) => <B>(fab: Kind<F, Kind3<G, R, E, (a: A) => B>>) => Kind<F, Kind3<G, R, E, B>>;

// @public (undocumented)
function ap<F extends URIS, G extends URIS2>(F: Apply1<F>, G: Apply2<G>): <E, A>(fa: Kind<F, Kind2<G, E, A>>) => <B>(fab: Kind<F, Kind2<G, E, (a: A) => B>>) => Kind<F, Kind2<G, E, B>>;

// @public (undocumented)
function ap<F extends URIS, G extends URIS2, E>(F: Apply1<F>, G: Apply2C<G, E>): <A>(fa: Kind<F, Kind2<G, E, A>>) => <B>(fab: Kind<F, Kind2<G, E, (a: A) => B>>) => Kind<F, Kind2<G, E, B>>;

// @public (undocumented)
function ap<F extends URIS, G extends URIS>(F: Apply1<F>, G: Apply1<G>): <A>(fa: Kind<F, Kind<G, A>>) => <B>(fab: Kind<F, Kind<G, (a: A) => B>>) => Kind<F, Kind<G, B>>;

// @public (undocumented)
function ap<F, G extends URIS4>(F: Apply<F>, G: Apply4<G>): <S, R, E, A>(fa: HKT<F, Kind4<G, S, R, E, A>>) => <B>(fab: HKT<F, Kind4<G, S, R, E, (a: A) => B>>) => HKT<F, Kind4<G, S, R, E, B>>;

// @public (undocumented)
function ap<F, G extends URIS3>(F: Apply<F>, G: Apply3<G>): <R, E, A>(fa: HKT<F, Kind3<G, R, E, A>>) => <B>(fab: HKT<F, Kind3<G, R, E, (a: A) => B>>) => HKT<F, Kind3<G, R, E, B>>;

// @public (undocumented)
function ap<F, G extends URIS3, E>(F: Apply<F>, G: Apply3C<G, E>): <R, A>(fa: HKT<F, Kind3<G, R, E, A>>) => <B>(fab: HKT<F, Kind3<G, R, E, (a: A) => B>>) => HKT<F, Kind3<G, R, E, B>>;

// @public (undocumented)
function ap<F, G extends URIS2>(F: Apply<F>, G: Apply2<G>): <E, A>(fa: HKT<F, Kind2<G, E, A>>) => <B>(fab: HKT<F, Kind2<G, E, (a: A) => B>>) => HKT<F, Kind2<G, E, B>>;

// @public (undocumented)
function ap<F, G extends URIS2, E>(F: Apply<F>, G: Apply2C<G, E>): <A>(fa: HKT<F, Kind2<G, E, A>>) => <B>(fab: HKT<F, Kind2<G, E, (a: A) => B>>) => HKT<F, Kind2<G, E, B>>;

// @public (undocumented)
function ap<F, G extends URIS>(F: Apply<F>, G: Apply1<G>): <A>(fa: HKT<F, Kind<G, A>>) => <B>(fab: HKT<F, Kind<G, (a: A) => B>>) => HKT<F, Kind<G, B>>;

// @public (undocumented)
function ap<F, G>(F: Apply<F>, G: Apply<G>): <A>(fa: HKT<F, HKT<G, A>>) => <B>(fab: HKT<F, HKT<G, (a: A) => B>>) => HKT<F, HKT<G, B>>;

// @public (undocumented)
const ap_10: <E, A>(fa: IOEither<E, A>) => <B>(fab: IOEither<E, (a: A) => B>) => IOEither<E, B>;

// @public (undocumented)
const ap_11: <A>(fa: IOOption<A>) => <B>(fab: IOOption<(a: A) => B>) => IOOption<B>;

// @public (undocumented)
function ap_12<F extends URIS4>(F: Apply4<F>): <S, R, E, A>(fa: Kind4<F, S, R, E, Option_2<A>>) => <B>(fab: Kind4<F, S, R, E, Option_2<(a: A) => B>>) => Kind4<F, S, R, E, Option_2<B>>;

// @public (undocumented)
function ap_12<F extends URIS3>(F: Apply3<F>): <R, E, A>(fa: Kind3<F, R, E, Option_2<A>>) => <B>(fab: Kind3<F, R, E, Option_2<(a: A) => B>>) => Kind3<F, R, E, Option_2<B>>;

// @public (undocumented)
function ap_12<F extends URIS3, E>(F: Apply3C<F, E>): <R, A>(fa: Kind3<F, R, E, Option_2<A>>) => <B>(fab: Kind3<F, R, E, Option_2<(a: A) => B>>) => Kind3<F, R, E, Option_2<B>>;

// @public (undocumented)
function ap_12<F extends URIS2>(F: Apply2<F>): <E, A>(fa: Kind2<F, E, Option_2<A>>) => <B>(fab: Kind2<F, E, Option_2<(a: A) => B>>) => Kind2<F, E, Option_2<B>>;

// @public (undocumented)
function ap_12<F extends URIS2, E>(F: Apply2C<F, E>): <A>(fa: Kind2<F, E, Option_2<A>>) => <B>(fab: Kind2<F, E, Option_2<(a: A) => B>>) => Kind2<F, E, Option_2<B>>;

// @public (undocumented)
function ap_12<F extends URIS>(F: Apply1<F>): <A>(fa: Kind<F, Option_2<A>>) => <B>(fab: Kind<F, Option_2<(a: A) => B>>) => Kind<F, Option_2<B>>;

// @public (undocumented)
function ap_12<F>(F: Apply<F>): <A>(fa: HKT<F, Option_2<A>>) => <B>(fab: HKT<F, Option_2<(a: A) => B>>) => HKT<F, Option_2<B>>;

// @public
function ap_13<F extends URIS4>(F: Apply4<F>): <S, R, E, A>(fa: Kind4<F, S, R, E, A>) => <B>(fab: Kind4<F, S, R, E, (a: A) => B>) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function ap_13<F extends URIS3>(F: Apply3<F>): <R, E, A>(fa: Kind3<F, R, E, A>) => <B>(fab: Kind3<F, R, E, (a: A) => B>) => Kind3<F, R, E, B>;

// @public (undocumented)
function ap_13<F extends URIS3, E>(F: Apply3C<F, E>): <R, A>(fa: Kind3<F, R, E, A>) => <B>(fab: Kind3<F, R, E, (a: A) => B>) => Kind3<F, R, E, B>;

// @public (undocumented)
function ap_13<F extends URIS2>(F: Apply2<F>): <E, A>(fa: Kind2<F, E, A>) => <B>(fab: Kind2<F, E, (a: A) => B>) => Kind2<F, E, B>;

// @public (undocumented)
function ap_13<F extends URIS2, E>(F: Apply2C<F, E>): <A>(fa: Kind2<F, E, A>) => <B>(fab: Kind2<F, E, (a: A) => B>) => Kind2<F, E, B>;

// @public (undocumented)
function ap_13<F extends URIS>(F: Apply1<F>): <A>(fa: Kind<F, A>) => <B>(fab: Kind<F, (a: A) => B>) => Kind<F, B>;

// @public (undocumented)
function ap_13<F>(F: Apply<F>): <A>(fa: HKT<F, A>) => <B>(fab: HKT<F, (a: A) => B>) => HKT<F, B>;

// @public (undocumented)
const ap_14: <R, A>(fa: Reader<R, A>) => <B>(fab: Reader<R, (a: A) => B>) => Reader<R, B>;

// @public (undocumented)
const ap_15: <R, E, A>(fa: ReaderEither<R, E, A>) => <B>(fab: ReaderEither<R, E, (a: A) => B>) => ReaderEither<R, E, B>;

// @public (undocumented)
const ap_16: <R, A>(fa: ReaderIO<R, A>) => <B>(fab: ReaderIO<R, (a: A) => B>) => ReaderIO<R, B>;

// @public (undocumented)
function ap_17<F extends URIS4>(F: Apply4<F>): <R, S, FR, FE, A>(fa: Reader<R, Kind4<F, S, FR, FE, A>>) => <B>(fab: Reader<R, Kind4<F, S, FR, FE, (a: A) => B>>) => Reader<R, Kind4<F, S, FR, FE, B>>;

// @public (undocumented)
function ap_17<F extends URIS3>(F: Apply3<F>): <R, FR, FE, A>(fa: Reader<R, Kind3<F, FR, FE, A>>) => <B>(fab: Reader<R, Kind3<F, FR, FE, (a: A) => B>>) => Reader<R, Kind3<F, FR, FE, B>>;

// @public (undocumented)
function ap_17<F extends URIS3, FE>(F: Apply3C<F, FE>): <R, FR, A>(fa: Reader<R, Kind3<F, FR, FE, A>>) => <B>(fab: Reader<R, Kind3<F, FR, FE, (a: A) => B>>) => Reader<R, Kind3<F, FR, FE, B>>;

// @public (undocumented)
function ap_17<F extends URIS2>(F: Apply2<F>): <R, FE, A>(fa: Reader<R, Kind2<F, FE, A>>) => <B>(fab: Reader<R, Kind2<F, FE, (a: A) => B>>) => Reader<R, Kind2<F, FE, B>>;

// @public (undocumented)
function ap_17<F extends URIS2, FE>(F: Apply2C<F, FE>): <R, A>(fa: Reader<R, Kind2<F, FE, A>>) => <B>(fab: Reader<R, Kind2<F, FE, (a: A) => B>>) => Reader<R, Kind2<F, FE, B>>;

// @public (undocumented)
function ap_17<F extends URIS>(F: Apply1<F>): <R, A>(fa: Reader<R, Kind<F, A>>) => <B>(fab: Reader<R, Kind<F, (a: A) => B>>) => Reader<R, Kind<F, B>>;

// @public (undocumented)
function ap_17<F>(F: Apply<F>): <R, A>(fa: Reader<R, HKT<F, A>>) => <B>(fab: Reader<R, HKT<F, (a: A) => B>>) => Reader<R, HKT<F, B>>;

// @public (undocumented)
const ap_18: <R, A>(fa: ReaderTask<R, A>) => <B>(fab: ReaderTask<R, (a: A) => B>) => ReaderTask<R, B>;

// @public (undocumented)
const ap_19: <A>(fa: Task<A>) => <B>(fab: Task<(a: A) => B>) => Task<B>;

// @public (undocumented)
const ap_2: <A>(as: ReadonlyNonEmptyArray<A>) => <B>(fab: ReadonlyNonEmptyArray<(a: A) => B>) => ReadonlyNonEmptyArray<B>;

// @public (undocumented)
const ap_20: <E, A>(fa: TaskEither<E, A>) => <B>(fab: TaskEither<E, (a: A) => B>) => TaskEither<E, B>;

// @public (undocumented)
const ap_21: <R, E, A>(fa: ReaderTaskEither<R, E, A>) => <B>(fab: ReaderTaskEither<R, E, (a: A) => B>) => ReaderTaskEither<R, E, B>;

// @public (undocumented)
const ap_22: <A>(fa: ReadonlyArray<A>) => <B>(fab: ReadonlyArray<(a: A) => B>) => ReadonlyArray<B>;

// @public (undocumented)
const ap_23: <E, A>(fa: State<E, A>) => <B>(fab: State<E, (a: A) => B>) => State<E, B>;

// @public (undocumented)
const ap_24: <S, R, E, A>(fa: StateReaderTaskEither<S, R, E, A>) => <B>(fab: StateReaderTaskEither<S, R, E, (a: A) => B>) => StateReaderTaskEither<S, R, E, B>;

// @public (undocumented)
function ap_25<M extends URIS3>(M: Chain3<M>): <S, R, E, A>(fa: StateT3<M, S, R, E, A>) => <B>(fab: StateT3<M, S, R, E, (a: A) => B>) => StateT3<M, S, R, E, B>;

// @public (undocumented)
function ap_25<M extends URIS3, E>(M: Chain3C<M, E>): <S, R, A>(fa: StateT3<M, S, R, E, A>) => <B>(fab: StateT3<M, S, R, E, (a: A) => B>) => StateT3<M, S, R, E, B>;

// @public (undocumented)
function ap_25<M extends URIS2>(M: Chain2<M>): <S, E, A>(fa: StateT2<M, S, E, A>) => <B>(fab: StateT2<M, S, E, (a: A) => B>) => StateT2<M, S, E, B>;

// @public (undocumented)
function ap_25<M extends URIS2, E>(M: Chain2C<M, E>): <S, A>(fa: StateT2<M, S, E, A>) => <B>(fab: StateT2<M, S, E, (a: A) => B>) => StateT2<M, S, E, B>;

// @public (undocumented)
function ap_25<M extends URIS>(M: Chain1<M>): <S, A>(fa: StateT1<M, S, A>) => <B>(fab: StateT1<M, S, (a: A) => B>) => StateT1<M, S, B>;

// @public (undocumented)
function ap_25<M>(M: Chain_5<M>): <S, A>(fa: StateT<M, S, A>) => <B>(fab: StateT<M, S, (a: A) => B>) => StateT<M, S, B>;

// @public (undocumented)
const ap_26: <A>(fa: TaskOption<A>) => <B>(fab: TaskOption<(a: A) => B>) => TaskOption<B>;

// @public (undocumented)
function ap_27<F extends URIS3, E>(F: Apply3<F>, S: Semigroup<E>): <R, FE, A>(fa: Kind3<F, R, FE, These<E, A>>) => <B>(fab: Kind3<F, R, FE, These<E, (a: A) => B>>) => Kind3<F, R, FE, These<E, B>>;

// @public (undocumented)
function ap_27<F extends URIS3, FE, E>(F: Apply3C<F, FE>, S: Semigroup<E>): <R, A>(fa: Kind3<F, R, FE, These<E, A>>) => <B>(fab: Kind3<F, R, FE, These<E, (a: A) => B>>) => Kind3<F, R, FE, These<E, B>>;

// @public (undocumented)
function ap_27<F extends URIS2, E>(F: Apply2<F>, S: Semigroup<E>): <FE, A>(fa: Kind2<F, FE, These<E, A>>) => <B>(fab: Kind2<F, FE, These<E, (a: A) => B>>) => Kind2<F, FE, These<E, B>>;

// @public (undocumented)
function ap_27<F extends URIS2, FE, E>(F: Apply2C<F, FE>, S: Semigroup<E>): <A>(fa: Kind2<F, FE, These<E, A>>) => <B>(fab: Kind2<F, FE, These<E, (a: A) => B>>) => Kind2<F, FE, These<E, B>>;

// @public (undocumented)
function ap_27<F extends URIS, E>(F: Apply1<F>, S: Semigroup<E>): <A>(fa: Kind<F, These<E, A>>) => <B>(fab: Kind<F, These<E, (a: A) => B>>) => Kind<F, These<E, B>>;

// @public (undocumented)
function ap_27<F, E>(F: Apply<F>, S: Semigroup<E>): <A>(fa: HKT<F, These<E, A>>) => <B>(fab: HKT<F, These<E, (a: A) => B>>) => HKT<F, These<E, B>>;

// @public (undocumented)
const ap_28: <A>(fa: Tree<A>) => <B>(fab: Tree<(a: A) => B>) => Tree<B>;

// @public
const ap_3: <A>(as: NonEmptyArray<A>) => <B>(fab: NonEmptyArray<(a: A) => B>) => NonEmptyArray<B>;

// @public (undocumented)
const ap_4: <A>(fa: Array<A>) => <B>(fab: Array<(a: A) => B>) => Array<B>;

// @public (undocumented)
const ap_5: <A>(fa: Option_2<A>) => <B>(fab: Option_2<(a: A) => B>) => Option_2<B>;

// @public (undocumented)
const ap_6: <E, A>(fa: Either<E, A>) => <B>(fab: Either<E, (a: A) => B>) => Either<E, B>;

// @public (undocumented)
function ap_7<F extends URIS3>(F: Apply3<F>): <R, FE, E, A>(fa: Kind3<F, R, FE, Either<E, A>>) => <B>(fab: Kind3<F, R, FE, Either<E, (a: A) => B>>) => Kind3<F, R, FE, Either<E, B>>;

// @public (undocumented)
function ap_7<F extends URIS3, FE>(F: Apply3C<F, FE>): <R, E, A>(fa: Kind3<F, R, FE, Either<E, A>>) => <B>(fab: Kind3<F, R, FE, Either<E, (a: A) => B>>) => Kind3<F, R, FE, Either<E, B>>;

// @public (undocumented)
function ap_7<F extends URIS2>(F: Apply2<F>): <FE, E, A>(fa: Kind2<F, FE, Either<E, A>>) => <B>(fab: Kind2<F, FE, Either<E, (a: A) => B>>) => Kind2<F, FE, Either<E, B>>;

// @public (undocumented)
function ap_7<F extends URIS2, FE>(F: Apply2C<F, FE>): <E, A>(fa: Kind2<F, FE, Either<E, A>>) => <B>(fab: Kind2<F, FE, Either<E, (a: A) => B>>) => Kind2<F, FE, Either<E, B>>;

// @public (undocumented)
function ap_7<F extends URIS>(F: Apply1<F>): <E, A>(fa: Kind<F, Either<E, A>>) => <B>(fab: Kind<F, Either<E, (a: A) => B>>) => Kind<F, Either<E, B>>;

// @public (undocumented)
function ap_7<F>(F: Apply<F>): <E, A>(fa: HKT<F, Either<E, A>>) => <B>(fab: HKT<F, Either<E, (a: A) => B>>) => HKT<F, Either<E, B>>;

// @public (undocumented)
const ap_8: <A>(fa: Identity<A>) => <B>(fab: Identity<(a: A) => B>) => Identity<B>;

// @public (undocumented)
const ap_9: <A>(fa: IO<A>) => <B>(fab: IO<(a: A) => B>) => IO<B>;

// @public (undocumented)
function apFirst<F extends URIS4>(A: Apply4<F>): <S, R, E, B>(second: Kind4<F, S, R, E, B>) => <A>(first: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>;

// @public (undocumented)
function apFirst<F extends URIS3>(A: Apply3<F>): <R, E, B>(second: Kind3<F, R, E, B>) => <A>(first: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;

// @public (undocumented)
function apFirst<F extends URIS3, E>(A: Apply3C<F, E>): <R, B>(second: Kind3<F, R, E, B>) => <A>(first: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;

// @public (undocumented)
function apFirst<F extends URIS2>(A: Apply2<F>): <E, B>(second: Kind2<F, E, B>) => <A>(first: Kind2<F, E, A>) => Kind2<F, E, A>;

// @public (undocumented)
function apFirst<F extends URIS2, E>(A: Apply2C<F, E>): <B>(second: Kind2<F, E, B>) => <A>(first: Kind2<F, E, A>) => Kind2<F, E, A>;

// @public (undocumented)
function apFirst<F extends URIS>(A: Apply1<F>): <B>(second: Kind<F, B>) => <A>(first: Kind<F, A>) => Kind<F, A>;

// @public (undocumented)
function apFirst<F>(A: Apply<F>): <B>(second: HKT<F, B>) => <A>(first: HKT<F, A>) => HKT<F, A>;

// @public
const apFirst_10: <B>(second: IOOption<B>) => <A>(first: IOOption<A>) => IOOption<A>;

// @public
const apFirst_11: <E, B>(second: Reader<E, B>) => <A>(first: Reader<E, A>) => Reader<E, A>;

// @public
const apFirst_12: <R, E, B>(second: ReaderEither<R, E, B>) => <A>(first: ReaderEither<R, E, A>) => ReaderEither<R, E, A>;

// @public
const apFirst_13: <E, B>(second: ReaderIO<E, B>) => <A>(first: ReaderIO<E, A>) => ReaderIO<E, A>;

// @public
const apFirst_14: <E, B>(second: ReaderTask<E, B>) => <A>(first: ReaderTask<E, A>) => ReaderTask<E, A>;

// @public
const apFirst_15: <B>(second: Task<B>) => <A>(first: Task<A>) => Task<A>;

// @public
const apFirst_16: <E, B>(second: TaskEither<E, B>) => <A>(first: TaskEither<E, A>) => TaskEither<E, A>;

// @public
const apFirst_17: <R, E, B>(second: ReaderTaskEither<R, E, B>) => <A>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;

// @public
const apFirst_18: <B>(second: readonly B[]) => <A>(first: readonly A[]) => readonly A[];

// @public
const apFirst_19: <E, B>(second: State<E, B>) => <A>(first: State<E, A>) => State<E, A>;

// @public
const apFirst_2: <B>(second: ReadonlyNonEmptyArray<B>) => <A>(first: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public
const apFirst_20: <S, R, E, B>(second: StateReaderTaskEither<S, R, E, B>) => <A>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>;

// @public
const apFirst_21: <B>(second: TaskOption<B>) => <A>(first: TaskOption<A>) => TaskOption<A>;

// @public
const apFirst_22: <B>(second: Tree<B>) => <A>(first: Tree<A>) => Tree<A>;

// @public
const apFirst_3: <B>(second: NonEmptyArray<B>) => <A>(first: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public
const apFirst_4: <B>(second: B[]) => <A>(first: A[]) => A[];

// @public
const apFirst_5: <B>(second: Option_2<B>) => <A>(first: Option_2<A>) => Option_2<A>;

// @public
const apFirst_6: <E, B>(second: Either<E, B>) => <A>(first: Either<E, A>) => Either<E, A>;

// @public
const apFirst_7: <B>(second: B) => <A>(first: A) => A;

// @public
const apFirst_8: <B>(second: IO<B>) => <A>(first: IO<A>) => IO<A>;

// @public
const apFirst_9: <E, B>(second: IOEither<E, B>) => <A>(first: IOEither<E, A>) => IOEither<E, A>;

// @public
const apFirstW: <E2, B>(second: Either<E2, B>) => <E1, A>(first: Either<E1, A>) => Either<E1 | E2, A>;

// @public
const apFirstW_2: <E2, B>(second: IOEither<E2, B>) => <E1, A>(first: IOEither<E1, A>) => IOEither<E1 | E2, A>;

// @public
const apFirstW_3: <R2, B>(second: Reader<R2, B>) => <R1, A>(first: Reader<R1, A>) => Reader<R1 & R2, A>;

// @public
const apFirstW_4: <R2, E2, B>(second: ReaderEither<R2, E2, B>) => <R1, E1, A>(first: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E1 | E2, A>;

// @public
const apFirstW_5: <E2, B>(second: TaskEither<E2, B>) => <E1, A>(first: TaskEither<E1, A>) => TaskEither<E1 | E2, A>;

// @public
const apFirstW_6: <R2, E2, B>(second: ReaderTaskEither<R2, E2, B>) => <R1, E1, A>(first: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, A>;

// @public
const apFirstW_7: <S, R2, E2, A, B>(second: StateReaderTaskEither<S, R2, E2, B>) => <R1, E1>(first: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E1 | E2, A>;

// @public
const append: <A>(end: A) => (init: Array<A>) => nonEmptyArray.NonEmptyArray<A>;

// @public
const append_2: <A>(end: A) => (init: readonly A[]) => readonlyNonEmptyArray.ReadonlyNonEmptyArray<A>;

// @public
const appendW: <A, B>(end: B) => (init: Array<A>) => nonEmptyArray.NonEmptyArray<A | B>;

// @public
const appendW_2: <B>(end: B) => <A>(init: readonly A[]) => readonlyNonEmptyArray.ReadonlyNonEmptyArray<B | A>;

// @public (undocumented)
interface Applicative<F> extends Apply<F>, Pointed<F> {
}

declare namespace applicative {
    export {
        getApplicativeMonoid,
        getApplicativeComposition,
        Applicative,
        Applicative1,
        Applicative2,
        Applicative2C,
        Applicative3,
        Applicative3C,
        Applicative4,
        ApplicativeComposition,
        ApplicativeCompositionHKT1,
        ApplicativeCompositionHKT2,
        ApplicativeCompositionHKT2C,
        ApplicativeComposition11,
        ApplicativeComposition12,
        ApplicativeComposition12C,
        ApplicativeComposition21,
        ApplicativeComposition2C1,
        ApplicativeComposition22,
        ApplicativeComposition22C
    }
}
export { applicative }

// @public (undocumented)
interface Applicative1<F extends URIS> extends Apply1<F>, Pointed1<F> {
}

// @public (undocumented)
interface Applicative2<F extends URIS2> extends Apply2<F>, Pointed2<F> {
}

// @public (undocumented)
interface Applicative2C<F extends URIS2, E> extends Apply2C<F, E>, Pointed2C<F, E> {
}

// @public (undocumented)
interface Applicative3<F extends URIS3> extends Apply3<F>, Pointed3<F> {
}

// @public (undocumented)
interface Applicative3C<F extends URIS3, E> extends Apply3C<F, E>, Pointed3C<F, E> {
}

// @public (undocumented)
interface Applicative4<F extends URIS4> extends Apply4<F>, Pointed4<F> {
}

// @public (undocumented)
const Applicative_10: Applicative1<URI_14>;

// @public (undocumented)
const Applicative_11: Applicative2<URI_17>;

// @public (undocumented)
const Applicative_12: Applicative3<URI_18>;

// @public (undocumented)
const Applicative_13: Applicative2<URI_19>;

// @public (undocumented)
const Applicative_14: Applicative1<URI_24>;

// @public (undocumented)
const Applicative_15: Applicative2<URI_30>;

// @public (undocumented)
const Applicative_16: Applicative4<URI_31>;

// @public (undocumented)
const Applicative_17: Applicative1<URI_37>;

// @public (undocumented)
const Applicative_2: Applicative1<URI_2>;

// @public (undocumented)
const Applicative_3: Applicative1<URI_3>;

// @public (undocumented)
const Applicative_4: Applicative1<URI_4>;

// @public (undocumented)
const Applicative_5: Applicative1<URI_7>;

// @public (undocumented)
const Applicative_6: Applicative2<URI_6>;

// @public (undocumented)
const Applicative_7: Applicative1<URI_11>;

// @public (undocumented)
const Applicative_8: Applicative1<URI_12>;

// @public @deprecated
const Applicative_9: Applicative2<URI_13>;

// @public @deprecated (undocumented)
interface ApplicativeComposition<F, G> extends FunctorComposition<F, G> {
    // (undocumented)
    readonly ap: <A, B>(fgab: HKT<F, HKT<G, (a: A) => B>>, fga: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, B>>;
    // (undocumented)
    readonly of: <A>(a: A) => HKT<F, HKT<G, A>>;
}

// @public @deprecated (undocumented)
interface ApplicativeComposition11<F extends URIS, G extends URIS> extends FunctorComposition11<F, G> {
    // (undocumented)
    readonly ap: <A, B>(fgab: Kind<F, Kind<G, (a: A) => B>>, fga: Kind<F, Kind<G, A>>) => Kind<F, Kind<G, B>>;
    // (undocumented)
    readonly of: <A>(a: A) => Kind<F, Kind<G, A>>;
}

// @public @deprecated (undocumented)
interface ApplicativeComposition12<F extends URIS, G extends URIS2> extends FunctorComposition12<F, G> {
    // (undocumented)
    readonly ap: <E, A, B>(fgab: Kind<F, Kind2<G, E, (a: A) => B>>, fga: Kind<F, Kind2<G, E, A>>) => Kind<F, Kind2<G, E, B>>;
    // (undocumented)
    readonly of: <E, A>(a: A) => Kind<F, Kind2<G, E, A>>;
}

// @public @deprecated (undocumented)
interface ApplicativeComposition12C<F extends URIS, G extends URIS2, E> extends FunctorComposition12C<F, G, E> {
    // (undocumented)
    readonly ap: <A, B>(fgab: Kind<F, Kind2<G, E, (a: A) => B>>, fga: Kind<F, Kind2<G, E, A>>) => Kind<F, Kind2<G, E, B>>;
    // (undocumented)
    readonly of: <A>(a: A) => Kind<F, Kind2<G, E, A>>;
}

// @public @deprecated (undocumented)
interface ApplicativeComposition21<F extends URIS2, G extends URIS> extends FunctorComposition21<F, G> {
    // (undocumented)
    readonly ap: <E, A, B>(fgab: Kind2<F, E, Kind<G, (a: A) => B>>, fga: Kind2<F, E, Kind<G, A>>) => Kind2<F, E, Kind<G, B>>;
    // (undocumented)
    readonly of: <E, A>(a: A) => Kind2<F, E, Kind<G, A>>;
}

// @public @deprecated (undocumented)
interface ApplicativeComposition22<F extends URIS2, G extends URIS2> extends FunctorComposition22<F, G> {
    // (undocumented)
    readonly ap: <FE, GE, A, B>(fgab: Kind2<F, FE, Kind2<G, GE, (a: A) => B>>, fga: Kind2<F, FE, Kind2<G, GE, A>>) => Kind2<F, FE, Kind2<G, GE, B>>;
    // (undocumented)
    readonly of: <FE, GE, A>(a: A) => Kind2<F, FE, Kind2<G, GE, A>>;
}

// @public @deprecated (undocumented)
interface ApplicativeComposition22C<F extends URIS2, G extends URIS2, E> extends FunctorComposition22C<F, G, E> {
    // (undocumented)
    readonly ap: <FE, A, B>(fgab: Kind2<F, FE, Kind2<G, E, (a: A) => B>>, fga: Kind2<F, FE, Kind2<G, E, A>>) => Kind2<F, FE, Kind2<G, E, B>>;
    // (undocumented)
    readonly of: <FE, A>(a: A) => Kind2<F, FE, Kind2<G, E, A>>;
}

// @public @deprecated (undocumented)
interface ApplicativeComposition2C1<F extends URIS2, G extends URIS, E> extends FunctorComposition2C1<F, G, E> {
    // (undocumented)
    readonly ap: <A, B>(fgab: Kind2<F, E, Kind<G, (a: A) => B>>, fga: Kind2<F, E, Kind<G, A>>) => Kind2<F, E, Kind<G, B>>;
    // (undocumented)
    readonly of: <A>(a: A) => Kind2<F, E, Kind<G, A>>;
}

// @public @deprecated (undocumented)
interface ApplicativeCompositionHKT1<F, G extends URIS> extends FunctorCompositionHKT1<F, G> {
    // (undocumented)
    readonly ap: <A, B>(fgab: HKT<F, Kind<G, (a: A) => B>>, fga: HKT<F, Kind<G, A>>) => HKT<F, Kind<G, B>>;
    // (undocumented)
    readonly of: <A>(a: A) => HKT<F, Kind<G, A>>;
}

// @public @deprecated (undocumented)
interface ApplicativeCompositionHKT2<F, G extends URIS2> extends FunctorCompositionHKT2<F, G> {
    // (undocumented)
    readonly ap: <E, A, B>(fgab: HKT<F, Kind2<G, E, (a: A) => B>>, fga: HKT<F, Kind2<G, E, A>>) => HKT<F, Kind2<G, E, B>>;
    // (undocumented)
    readonly of: <E, A>(a: A) => HKT<F, Kind2<G, E, A>>;
}

// @public @deprecated (undocumented)
interface ApplicativeCompositionHKT2C<F, G extends URIS2, E> extends FunctorCompositionHKT2C<F, G, E> {
    // (undocumented)
    readonly ap: <A, B>(fgab: HKT<F, Kind2<G, E, (a: A) => B>>, fga: HKT<F, Kind2<G, E, A>>) => HKT<F, Kind2<G, E, B>>;
    // (undocumented)
    readonly of: <A>(a: A) => HKT<F, Kind2<G, E, A>>;
}

// @public
const ApplicativePar: Applicative2<URI_13>;

// @public
const ApplicativePar_2: Applicative2<URI_20>;

// @public
const ApplicativePar_3: Applicative1<URI_21>;

// @public
const ApplicativePar_4: Applicative2<URI_23>;

// @public
const ApplicativePar_5: Applicative3<URI_22>;

// @public
const ApplicativePar_6: Applicative1<URI_33>;

// @public
const ApplicativeSeq: Applicative2<URI_13>;

// @public
const ApplicativeSeq_2: Applicative2<URI_20>;

// @public
const ApplicativeSeq_3: Applicative1<URI_21>;

// @public
const ApplicativeSeq_4: Applicative2<URI_23>;

// @public
const ApplicativeSeq_5: Applicative3<URI_22>;

// @public
const ApplicativeSeq_6: Applicative1<URI_33>;

// @public (undocumented)
interface Apply<F> extends Functor<F> {
    // (undocumented)
    readonly ap: <A, B>(fab: HKT<F, (a: A) => B>, fa: HKT<F, A>) => HKT<F, B>;
}

declare namespace apply {
    export {
        ap,
        apFirst,
        apSecond,
        apS,
        getApplySemigroup,
        sequenceT,
        sequenceS,
        Apply,
        Apply1,
        Apply2,
        Apply2C,
        Apply3,
        Apply3C,
        Apply4
    }
}
export { apply }

// @public (undocumented)
interface Apply1<F extends URIS> extends Functor1<F> {
    // (undocumented)
    readonly ap: <A, B>(fab: Kind<F, (a: A) => B>, fa: Kind<F, A>) => Kind<F, B>;
}

// @public (undocumented)
interface Apply2<F extends URIS2> extends Functor2<F> {
    // (undocumented)
    readonly ap: <E, A, B>(fab: Kind2<F, E, (a: A) => B>, fa: Kind2<F, E, A>) => Kind2<F, E, B>;
}

// @public (undocumented)
interface Apply2C<F extends URIS2, E> extends Functor2C<F, E> {
    // (undocumented)
    readonly ap: <A, B>(fab: Kind2<F, E, (a: A) => B>, fa: Kind2<F, E, A>) => Kind2<F, E, B>;
}

// @public (undocumented)
interface Apply3<F extends URIS3> extends Functor3<F> {
    // (undocumented)
    readonly ap: <R, E, A, B>(fab: Kind3<F, R, E, (a: A) => B>, fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
}

// @public (undocumented)
interface Apply3C<F extends URIS3, E> extends Functor3C<F, E> {
    // (undocumented)
    readonly ap: <R, A, B>(fab: Kind3<F, R, E, (a: A) => B>, fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
}

// @public (undocumented)
interface Apply4<F extends URIS4> extends Functor4<F> {
    // (undocumented)
    readonly ap: <S, R, E, A, B>(fab: Kind4<F, S, R, E, (a: A) => B>, fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;
}

// @public (undocumented)
const Apply_10: Apply2<URI_17>;

// @public (undocumented)
const Apply_11: Apply3<URI_18>;

// @public (undocumented)
const Apply_12: Apply2<URI_19>;

// @public (undocumented)
const Apply_13: Apply1<URI_24>;

// @public (undocumented)
const Apply_14: Apply2<URI_30>;

// @public (undocumented)
const Apply_15: Apply4<URI_31>;

// @public (undocumented)
const Apply_16: Apply1<URI_37>;

// @public (undocumented)
const Apply_2: Apply1<URI_2>;

// @public (undocumented)
const apply_2: <A>(a: A) => <B>(f: (a: A) => B) => B;

// @public (undocumented)
const Apply_3: Apply1<URI_3>;

// @public (undocumented)
const Apply_4: Apply1<URI_4>;

// @public (undocumented)
const Apply_5: Apply1<URI_7>;

// @public (undocumented)
const Apply_6: Apply2<URI_6>;

// @public (undocumented)
const Apply_7: Apply1<URI_11>;

// @public (undocumented)
const Apply_8: Apply1<URI_12>;

// @public (undocumented)
const Apply_9: Apply1<URI_14>;

// @public
const ApplyPar: Apply2<URI_13>;

// @public
const ApplyPar_2: Apply2<URI_20>;

// @public
const ApplyPar_3: Apply1<URI_21>;

// @public
const ApplyPar_4: Apply2<URI_23>;

// @public
const ApplyPar_5: Apply3<URI_22>;

// @public
const ApplyPar_6: Apply1<URI_33>;

// @public
const ApplySeq: Apply2<URI_20>;

// @public
const ApplySeq_2: Apply1<URI_21>;

// @public
const ApplySeq_3: Apply2<URI_23>;

// @public
const ApplySeq_4: Apply3<URI_22>;

// @public
const ApplySeq_5: Apply1<URI_33>;

// @public (undocumented)
function apS<F extends URIS4>(F: Apply4<F>): <N extends string, A, S, R, E, B>(name: Exclude<N, keyof A>, fb: Kind4<F, S, R, E, B>) => (fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function apS<F extends URIS3>(F: Apply3<F>): <N extends string, A, R, E, B>(name: Exclude<N, keyof A>, fb: Kind3<F, R, E, B>) => (fa: Kind3<F, R, E, A>) => Kind3<F, R, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function apS<F extends URIS3, E>(F: Apply3C<F, E>): <N extends string, A, R, B>(name: Exclude<N, keyof A>, fb: Kind3<F, R, E, B>) => (fa: Kind3<F, R, E, A>) => Kind3<F, R, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function apS<F extends URIS2>(F: Apply2<F>): <N extends string, A, E, B>(name: Exclude<N, keyof A>, fb: Kind2<F, E, B>) => (fa: Kind2<F, E, A>) => Kind2<F, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function apS<F extends URIS2, E>(F: Apply2C<F, E>): <N extends string, A, B>(name: Exclude<N, keyof A>, fb: Kind2<F, E, B>) => (fa: Kind2<F, E, A>) => Kind2<F, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function apS<F extends URIS>(F: Apply1<F>): <N extends string, A, B>(name: Exclude<N, keyof A>, fb: Kind<F, B>) => (fa: Kind<F, A>) => Kind<F, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function apS<F>(F: Apply<F>): <N extends string, A, B>(name: Exclude<N, keyof A>, fb: HKT<F, B>) => (fa: HKT<F, A>) => HKT<F, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
const apS_10: <N extends string, A, B>(name: Exclude<N, keyof A>, fb: IOOption<B>) => (fa: IOOption<A>) => IOOption<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_11: <N extends string, A, E, B>(name: Exclude<N, keyof A>, fb: Reader<E, B>) => (fa: Reader<E, A>) => Reader<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_12: <N extends string, A, R, E, B>(name: Exclude<N, keyof A>, fb: ReaderEither<R, E, B>) => (fa: ReaderEither<R, E, A>) => ReaderEither<R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_13: <N extends string, A, E, B>(name: Exclude<N, keyof A>, fb: ReaderIO<E, B>) => (fa: ReaderIO<E, A>) => ReaderIO<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_14: <N extends string, A, B>(name: Exclude<N, keyof A>, fb: Task<B>) => (fa: Task<A>) => Task<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_15: <N extends string, A, E, B>(name: Exclude<N, keyof A>, fb: ReaderTask<E, B>) => (fa: ReaderTask<E, A>) => ReaderTask<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_16: <N extends string, A, E, B>(name: Exclude<N, keyof A>, fb: TaskEither<E, B>) => (fa: TaskEither<E, A>) => TaskEither<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_17: <N extends string, A, R, E, B>(name: Exclude<N, keyof A>, fb: ReaderTaskEither<R, E, B>) => (fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_18: <N extends string, A, B>(name: Exclude<N, keyof A>, fb: readonly B[]) => (fa: readonly A[]) => readonly { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }[];

// @public (undocumented)
const apS_19: <N extends string, A, E, B>(name: Exclude<N, keyof A>, fb: State<E, B>) => (fa: State<E, A>) => State<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_2: <N extends string, A, B>(name: Exclude<N, keyof A>, fb: ReadonlyNonEmptyArray<B>) => (fa: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_20: <N extends string, A, S, R, E, B>(name: Exclude<N, keyof A>, fb: StateReaderTaskEither<S, R, E, B>) => (fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_21: <N extends string, A, B>(name: Exclude<N, keyof A>, fb: TaskOption<B>) => (fa: TaskOption<A>) => TaskOption<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_22: <N extends string, A, B>(name: Exclude<N, keyof A>, fb: Tree<B>) => (fa: Tree<A>) => Tree<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_3: <N extends string, A, B>(name: Exclude<N, keyof A>, fb: NonEmptyArray<B>) => (fa: NonEmptyArray<A>) => NonEmptyArray<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_4: <N extends string, A, B>(name: Exclude<N, keyof A>, fb: Option_2<B>) => (fa: Option_2<A>) => Option_2<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_5: <N extends string, A, E, B>(name: Exclude<N, keyof A>, fb: Either<E, B>) => (fa: Either<E, A>) => Either<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_6: <N extends string, A, B>(name: Exclude<N, keyof A>, fb: B[]) => (fa: A[]) => { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }[];

// @public (undocumented)
const apS_7: <N extends string, A, B>(name: Exclude<N, keyof A>, fb: B) => (fa: A) => { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; };

// @public (undocumented)
const apS_8: <N extends string, A, B>(name: Exclude<N, keyof A>, fb: IO<B>) => (fa: IO<A>) => IO<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const apS_9: <N extends string, A, E, B>(name: Exclude<N, keyof A>, fb: IOEither<E, B>) => (fa: IOEither<E, A>) => IOEither<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
function apSecond<F extends URIS4>(A: Apply4<F>): <S, R, E, B>(second: Kind4<F, S, R, E, B>) => <A>(first: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function apSecond<F extends URIS3>(A: Apply3<F>): <R, E, B>(second: Kind3<F, R, E, B>) => <A>(first: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function apSecond<F extends URIS3, E>(A: Apply3C<F, E>): <R, B>(second: Kind3<F, R, E, B>) => <A>(first: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function apSecond<F extends URIS2>(A: Apply2<F>): <E, B>(second: Kind2<F, E, B>) => <A>(first: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function apSecond<F extends URIS2, E>(A: Apply2C<F, E>): <B>(second: Kind2<F, E, B>) => <A>(first: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function apSecond<F extends URIS>(A: Apply1<F>): <B>(second: Kind<F, B>) => <A>(first: Kind<F, A>) => Kind<F, B>;

// @public (undocumented)
function apSecond<F>(A: Apply<F>): <B>(second: HKT<F, B>) => <A>(first: HKT<F, A>) => HKT<F, B>;

// @public
const apSecond_10: <B>(second: IOOption<B>) => <A>(first: IOOption<A>) => IOOption<B>;

// @public
const apSecond_11: <E, B>(second: Reader<E, B>) => <A>(first: Reader<E, A>) => Reader<E, B>;

// @public
const apSecond_12: <R, E, B>(second: ReaderEither<R, E, B>) => <A>(first: ReaderEither<R, E, A>) => ReaderEither<R, E, B>;

// @public
const apSecond_13: <E, B>(second: ReaderIO<E, B>) => <A>(first: ReaderIO<E, A>) => ReaderIO<E, B>;

// @public
const apSecond_14: <E, B>(second: ReaderTask<E, B>) => <A>(first: ReaderTask<E, A>) => ReaderTask<E, B>;

// @public
const apSecond_15: <B>(second: Task<B>) => <A>(first: Task<A>) => Task<B>;

// @public
const apSecond_16: <E, B>(second: TaskEither<E, B>) => <A>(first: TaskEither<E, A>) => TaskEither<E, B>;

// @public
const apSecond_17: <R, E, B>(second: ReaderTaskEither<R, E, B>) => <A>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;

// @public
const apSecond_18: <B>(second: readonly B[]) => <A>(first: readonly A[]) => readonly B[];

// @public
const apSecond_19: <E, B>(second: State<E, B>) => <A>(first: State<E, A>) => State<E, B>;

// @public
const apSecond_2: <B>(second: ReadonlyNonEmptyArray<B>) => <A>(first: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>;

// @public
const apSecond_20: <S, R, E, B>(second: StateReaderTaskEither<S, R, E, B>) => <A>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;

// @public
const apSecond_21: <B>(second: TaskOption<B>) => <A>(first: TaskOption<A>) => TaskOption<B>;

// @public
const apSecond_22: <B>(second: Tree<B>) => <A>(first: Tree<A>) => Tree<B>;

// @public
const apSecond_3: <B>(second: NonEmptyArray<B>) => <A>(first: NonEmptyArray<A>) => NonEmptyArray<B>;

// @public
const apSecond_4: <B>(second: B[]) => <A>(first: A[]) => B[];

// @public
const apSecond_5: <B>(second: Option_2<B>) => <A>(first: Option_2<A>) => Option_2<B>;

// @public
const apSecond_6: <E, B>(second: Either<E, B>) => <A>(first: Either<E, A>) => Either<E, B>;

// @public
const apSecond_7: <B>(second: B) => <A>(first: A) => B;

// @public
const apSecond_8: <B>(second: IO<B>) => <A>(first: IO<A>) => IO<B>;

// @public
const apSecond_9: <E, B>(second: IOEither<E, B>) => <A>(first: IOEither<E, A>) => IOEither<E, B>;

// @public
const apSecondW: <E2, B>(second: Either<E2, B>) => <E1, A>(first: Either<E1, A>) => Either<E1 | E2, B>;

// @public
const apSecondW_2: <E2, B>(second: IOEither<E2, B>) => <E1, A>(first: IOEither<E1, A>) => IOEither<E1 | E2, B>;

// @public
const apSecondW_3: <R2, B>(second: Reader<R2, B>) => <R1, A>(first: Reader<R1, A>) => Reader<R1 & R2, B>;

// @public
const apSecondW_4: <R2, E2, B>(second: ReaderEither<R2, E2, B>) => <R1, E1, A>(first: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E1 | E2, B>;

// @public
const apSecondW_5: <E2, B>(second: TaskEither<E2, B>) => <E1, A>(first: TaskEither<E1, A>) => TaskEither<E1 | E2, B>;

// @public
const apSecondW_6: <R2, E2, B>(second: ReaderTaskEither<R2, E2, B>) => <R1, E1, A>(first: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, B>;

// @public
const apSecondW_7: <S, R2, E2, A, B>(second: StateReaderTaskEither<S, R2, E2, B>) => <R1, E1>(first: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E1 | E2, B>;

// @public
const apSW: <A, N extends string, E2, B>(name: Exclude<N, keyof A>, fb: Either<E2, B>) => <E1>(fa: Either<E1, A>) => Either<E1 | E2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const apSW_2: <A, N extends string, E2, B>(name: Exclude<N, keyof A>, fb: IOEither<E2, B>) => <E1>(fa: IOEither<E1, A>) => IOEither<E1 | E2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const apSW_3: <A, N extends string, R2, B>(name: Exclude<N, keyof A>, fb: Reader<R2, B>) => <R1>(fa: Reader<R1, A>) => Reader<R1 & R2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const apSW_4: <A, N extends string, R2, E2, B>(name: Exclude<N, keyof A>, fb: ReaderEither<R2, E2, B>) => <R1, E1>(fa: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E1 | E2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const apSW_5: <N extends string, A, R2, B>(name: Exclude<N, keyof A>, fb: ReaderIO<R2, B>) => <R1>(fa: ReaderIO<R1, A>) => ReaderIO<R1 & R2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const apSW_6: <A, N extends string, R2, B>(name: Exclude<N, keyof A>, fb: ReaderTask<R2, B>) => <R1>(fa: ReaderTask<R1, A>) => ReaderTask<R1 & R2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const apSW_7: <A, N extends string, E2, B>(name: Exclude<N, keyof A>, fb: TaskEither<E2, B>) => <E1>(fa: TaskEither<E1, A>) => TaskEither<E1 | E2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const apSW_8: <A, N extends string, R2, E2, B>(name: Exclude<N, keyof A>, fb: ReaderTaskEither<R2, E2, B>) => <R1, E1>(fa: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const apSW_9: <A, N extends string, S, R2, E2, B>(name: Exclude<N, keyof A>, fb: StateReaderTaskEither<S, R2, E2, B>) => <R1, E1>(fa: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E1 | E2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
const ApT: Option_2<readonly []>;

// @public (undocumented)
const ApT_10: ReaderTask<unknown, readonly []>;

// @public (undocumented)
const ApT_11: TaskEither<never, readonly []>;

// @public (undocumented)
const ApT_12: ReaderTaskEither<unknown, never, readonly []>;

// @public (undocumented)
const ApT_13: TaskOption<readonly []>;

// @public (undocumented)
const ApT_14: These<never, readonly []>;

// @public (undocumented)
const ApT_15: TaskThese<never, readonly []>;

// @public (undocumented)
const ApT_2: Either<never, readonly []>;

// @public (undocumented)
const ApT_3: IO<readonly []>;

// @public (undocumented)
const ApT_4: IOEither<never, readonly []>;

// @public (undocumented)
const ApT_5: IOOption<readonly []>;

// @public (undocumented)
const ApT_6: Reader<unknown, readonly []>;

// @public (undocumented)
const ApT_7: ReaderEither<unknown, never, readonly []>;

// @public (undocumented)
const ApT_8: ReaderIO<unknown, readonly []>;

// @public (undocumented)
const ApT_9: Task<readonly []>;

// @public
const apW: <E2, A>(fa: Either<E2, A>) => <E1, B>(fab: Either<E1, (a: A) => B>) => Either<E1 | E2, B>;

// @public
const apW_2: <E2, A>(fa: IOEither<E2, A>) => <E1, B>(fab: IOEither<E1, (a: A) => B>) => IOEither<E1 | E2, B>;

// @public
const apW_3: <R2, A>(fa: Reader<R2, A>) => <R1, B>(fab: Reader<R1, (a: A) => B>) => Reader<R1 & R2, B>;

// @public
const apW_4: <R2, E2, A>(fa: ReaderEither<R2, E2, A>) => <R1, E1, B>(fab: ReaderEither<R1, E1, (a: A) => B>) => ReaderEither<R1 & R2, E1 | E2, B>;

// @public
const apW_5: <R2, A>(fa: ReaderIO<R2, A>) => <R1, B>(fab: ReaderIO<R1, (a: A) => B>) => ReaderIO<R1 & R2, B>;

// @public
const apW_6: <R2, A>(fa: ReaderTask<R2, A>) => <R1, B>(fab: ReaderTask<R1, (a: A) => B>) => ReaderTask<R1 & R2, B>;

// @public
const apW_7: <E2, A>(fa: TaskEither<E2, A>) => <E1, B>(fab: TaskEither<E1, (a: A) => B>) => TaskEither<E1 | E2, B>;

// @public
const apW_8: <R2, E2, A>(fa: ReaderTaskEither<R2, E2, A>) => <R1, E1, B>(fab: ReaderTaskEither<R1, E1, (a: A) => B>) => ReaderTaskEither<R1 & R2, E1 | E2, B>;

// @public
const apW_9: <S, R2, E2, A>(fa: StateReaderTaskEither<S, R2, E2, A>) => <R1, E1, B>(fab: StateReaderTaskEither<S, R1, E1, (a: A) => B>) => StateReaderTaskEither<S, R1 & R2, E1 | E2, B>;

declare namespace array {
    export {
        fromPredicate,
        takeLeftWhile,
        spanLeft,
        dropLeftWhile,
        findFirst,
        findLast,
        zip,
        comprehension,
        union,
        intersection,
        difference,
        isEmpty,
        isNonEmpty,
        prepend,
        prependW,
        append,
        appendW,
        makeBy_3 as makeBy,
        replicate_3 as replicate,
        fromOption,
        fromEither_2 as fromEither,
        matchW,
        match,
        matchLeftW,
        matchLeft_3 as matchLeft,
        foldLeft,
        matchRightW,
        matchRight_3 as matchRight,
        foldRight,
        chainWithIndex_3 as chainWithIndex,
        scanLeft,
        scanRight,
        size,
        isOutOfBound,
        lookup,
        head_3 as head,
        last_4 as last,
        tail_3 as tail,
        init_3 as init,
        takeLeft,
        takeRight,
        Spanned,
        dropLeft,
        dropRight,
        findIndex,
        findFirstMap,
        findLastMap,
        findLastIndex,
        copy_2 as copy,
        insertAt_3 as insertAt,
        updateAt_3 as updateAt,
        deleteAt,
        modifyAt_3 as modifyAt,
        reverse_5 as reverse,
        rights,
        lefts,
        sort_3 as sort,
        zipWith_3 as zipWith,
        unzip_3 as unzip,
        prependAll_3 as prependAll,
        intersperse_3 as intersperse,
        rotate_3 as rotate,
        elem,
        uniq_3 as uniq,
        sortBy_3 as sortBy,
        chop_3 as chop,
        splitAt_3 as splitAt,
        chunksOf_3 as chunksOf,
        fromOptionK,
        concatW_3 as concatW,
        concat_3 as concat,
        of_3 as of,
        zero_2 as zero,
        map_4 as map,
        ap_4 as ap,
        flatMap_3 as flatMap,
        flatten_3 as flatten,
        mapWithIndex_3 as mapWithIndex,
        filterMapWithIndex,
        filterMap,
        compact,
        separate,
        filter_3 as filter,
        partition,
        partitionWithIndex,
        partitionMap,
        partitionMapWithIndex,
        altW_3 as altW,
        alt_4 as alt,
        filterWithIndex_3 as filterWithIndex,
        extend_4 as extend,
        duplicate_3 as duplicate,
        foldMap_3 as foldMap,
        foldMapWithIndex_3 as foldMapWithIndex,
        reduce_3 as reduce,
        reduceWithIndex_3 as reduceWithIndex,
        reduceRight_3 as reduceRight,
        reduceRightWithIndex_3 as reduceRightWithIndex,
        traverse_3 as traverse,
        sequence_3 as sequence,
        traverseWithIndex_3 as traverseWithIndex,
        wither,
        wilt,
        unfold,
        URI_4 as URI,
        getShow_3 as getShow,
        getSemigroup_4 as getSemigroup,
        getMonoid_2 as getMonoid,
        getEq_3 as getEq,
        getOrd,
        getUnionSemigroup_3 as getUnionSemigroup,
        getUnionMonoid,
        getIntersectionSemigroup,
        getDifferenceMagma,
        Functor_4 as Functor,
        flap_3 as flap,
        Pointed_4 as Pointed,
        FunctorWithIndex_3 as FunctorWithIndex,
        Apply_4 as Apply,
        apFirst_4 as apFirst,
        apSecond_4 as apSecond,
        Applicative_4 as Applicative,
        Chain_3 as Chain,
        chainFirst_3 as chainFirst,
        Monad_3 as Monad,
        Unfoldable,
        Alt_4 as Alt,
        Zero_2 as Zero,
        guard,
        Alternative_2 as Alternative,
        Extend,
        Compactable,
        Filterable,
        FilterableWithIndex,
        Foldable_3 as Foldable,
        FoldableWithIndex_3 as FoldableWithIndex,
        Traversable_3 as Traversable,
        TraversableWithIndex_3 as TraversableWithIndex,
        Witherable,
        chainRecDepthFirst,
        ChainRecDepthFirst,
        chainRecBreadthFirst,
        ChainRecBreadthFirst,
        filterE,
        FromEither_3 as FromEither,
        fromEitherK_2 as fromEitherK,
        unsafeInsertAt,
        unsafeUpdateAt,
        unsafeDeleteAt,
        every,
        some_2 as some,
        exists_3 as exists,
        intercalate_4 as intercalate,
        Do_5 as Do,
        bindTo_5 as bindTo,
        let__5 as let,
        bind_6 as bind,
        apS_6 as apS,
        chain_6 as chain,
        range_3 as range,
        empty,
        cons_3 as cons,
        snoc_3 as snoc,
        prependToAll_3 as prependToAll,
        array_2 as array
    }
}
export { array }

// @public @deprecated
const array_2: FunctorWithIndex1<URI_4, number> & Monad1<URI_4> & Unfoldable1<URI_4> & Alternative1<URI_4> & Extend1<URI_4> & FilterableWithIndex1<URI_4, number> & FoldableWithIndex1<URI_4, number> & TraversableWithIndex1<URI_4, number> & Witherable1<URI_4>;

// @public
const as: {
    <A>(a: A): <_>(self: Option_2<_>) => Option_2<A>;
    <_, A>(self: Option_2<_>, a: A): Option_2<A>;
};

// @public
const as_10: {
    <A>(a: A): <E, _>(self: TaskEither<E, _>) => TaskEither<E, A>;
    <E, _, A>(self: TaskEither<E, _>, a: A): TaskEither<E, A>;
};

// @public
const as_11: {
    <A>(a: A): <R, E, _>(self: ReaderTaskEither<R, E, _>) => ReaderTaskEither<R, E, A>;
    <R, E, _, A>(self: ReaderTaskEither<R, E, _>, a: A): ReaderTaskEither<R, E, A>;
};

// @public
const as_12: {
    <A>(a: A): <S, R, E, _>(self: StateReaderTaskEither<S, R, E, _>) => StateReaderTaskEither<S, R, E, A>;
    <S, R, E, _, A>(self: StateReaderTaskEither<S, R, E, _>, a: A): StateReaderTaskEither<S, R, E, A>;
};

// @public
const as_13: {
    <A>(a: A): <_>(self: TaskOption<_>) => TaskOption<A>;
    <_, A>(self: TaskOption<_>, a: A): TaskOption<A>;
};

// @public
const as_2: {
    <A>(a: A): <E, _>(self: Either<E, _>) => Either<E, A>;
    <E, _, A>(self: Either<E, _>, a: A): Either<E, A>;
};

// @public
const as_3: {
    <A>(a: A): <_>(self: IO<_>) => IO<A>;
    <_, A>(self: IO<_>, a: A): IO<A>;
};

// @public
const as_4: {
    <A>(a: A): <E, _>(self: IOEither<E, _>) => IOEither<E, A>;
    <E, _, A>(self: IOEither<E, _>, a: A): IOEither<E, A>;
};

// @public
const as_5: {
    <A>(a: A): <_>(self: IOOption<_>) => IOOption<A>;
    <_, A>(self: IOOption<_>, a: A): IOOption<A>;
};

// @public
const as_6: {
    <A>(a: A): <R, E, _>(self: ReaderEither<R, E, _>) => ReaderEither<R, E, A>;
    <R, E, _, A>(self: ReaderEither<R, E, _>, a: A): ReaderEither<R, E, A>;
};

// @public
const as_7: {
    <A>(a: A): <R, _>(self: ReaderIO<R, _>) => ReaderIO<R, A>;
    <R, _, A>(self: ReaderIO<R, _>, a: A): ReaderIO<R, A>;
};

// @public
const as_8: {
    <A>(a: A): <R, _>(self: ReaderTask<R, _>) => ReaderTask<R, A>;
    <R, _, A>(self: ReaderTask<R, _>, a: A): ReaderTask<R, A>;
};

// @public
const as_9: {
    <A>(a: A): <_>(self: Task<_>) => Task<A>;
    <_, A>(self: Task<_>, a: A): Task<A>;
};

// @public (undocumented)
function ask<F extends URIS4>(F: FromReader4<F>): <S, R, E>() => Kind4<F, S, R, E, R>;

// @public (undocumented)
function ask<F extends URIS3>(F: FromReader3<F>): <R, E>() => Kind3<F, R, E, R>;

// @public (undocumented)
function ask<F extends URIS3, E>(F: FromReader3C<F, E>): <R>() => Kind3<F, R, E, R>;

// @public (undocumented)
function ask<F extends URIS2>(F: FromReader2<F>): <R>() => Kind2<F, R, R>;

// @public (undocumented)
function ask<F>(F: FromReader<F>): <R>() => HKT2<F, R, R>;

// @public
const ask_2: <R>() => Reader<R, R>;

// @public
const ask_3: <R, E = never>() => ReaderEither<R, E, R>;

// @public
const ask_4: <R>() => ReaderIO<R, R>;

// @public
const ask_5: <R>() => ReaderTask<R, R>;

// @public
const ask_6: <R, E = never>() => ReaderTaskEither<R, E, R>;

// @public
const ask_7: <S, R, E = never>() => StateReaderTaskEither<S, R, E, R>;

// @public (undocumented)
function asks<F extends URIS4>(F: FromReader4<F>): <R, A, S, E>(f: (r: R) => A) => Kind4<F, S, R, E, A>;

// @public (undocumented)
function asks<F extends URIS3>(F: FromReader3<F>): <R, A, E>(f: (r: R) => A) => Kind3<F, R, E, A>;

// @public (undocumented)
function asks<F extends URIS3, E>(F: FromReader3C<F, E>): <R, A>(f: (r: R) => A) => Kind3<F, R, E, A>;

// @public (undocumented)
function asks<F extends URIS2>(F: FromReader2<F>): <R, A>(f: (r: R) => A) => Kind2<F, R, A>;

// @public (undocumented)
function asks<F>(F: FromReader<F>): <R, A>(f: (r: R) => A) => HKT2<F, R, A>;

// @public
const asks_2: <R, A>(f: (r: R) => A) => Reader<R, A>;

// @public
const asks_3: <R, A, E = never>(f: (r: R) => A) => ReaderEither<R, E, A>;

// @public
const asks_4: <R, A>(f: (r: R) => A) => ReaderIO<R, A>;

// @public
const asks_5: <R, A>(f: (r: R) => A) => ReaderTask<R, A>;

// @public
const asks_6: <R, A, E = never>(f: (r: R) => A) => ReaderTaskEither<R, E, A>;

// @public
const asks_7: <S, R, A, E = never>(f: (r: R) => A) => StateReaderTaskEither<S, R, E, A>;

// @public
const asksReader: <R, A>(f: (r: R) => Reader<R, A>) => Reader<R, A>;

// @public
const asksReaderEither: <R, E, A>(f: (r: R) => ReaderEither<R, E, A>) => ReaderEither<R, E, A>;

// @public
const asksReaderEitherW: <R1, R2, E, A>(f: (r1: R1) => ReaderEither<R2, E, A>) => ReaderEither<R1 & R2, E, A>;

// @public
const asksReaderIO: <R, A>(f: (r: R) => ReaderIO<R, A>) => ReaderIO<R, A>;

// @public
const asksReaderIOW: <R1, R2, A>(f: (r1: R1) => ReaderIO<R2, A>) => ReaderIO<R1 & R2, A>;

// @public
const asksReaderTask: <R, A>(f: (r: R) => ReaderTask<R, A>) => ReaderTask<R, A>;

// @public
const asksReaderTaskEither: <R, E, A>(f: (r: R) => ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;

// @public
const asksReaderTaskEitherW: <R1, R2, E, A>(f: (r1: R1) => ReaderTaskEither<R2, E, A>) => ReaderTaskEither<R1 & R2, E, A>;

// @public
const asksReaderTaskW: <R1, R2, A>(f: (r1: R1) => ReaderTask<R2, A>) => ReaderTask<R1 & R2, A>;

// @public
const asksReaderW: <R1, R2, A>(f: (r1: R1) => Reader<R2, A>) => Reader<R1 & R2, A>;

// @public
const asksStateReaderTaskEither: <R, S, E, A>(f: (r: R) => StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>;

// @public
const asksStateReaderTaskEitherW: <R1, S, R2, E, A>(f: (r1: R1) => StateReaderTaskEither<S, R2, E, A>) => StateReaderTaskEither<S, R1 & R2, E, A>;

// @public
const asUnit: <_>(self: Option_2<_>) => Option_2<void>;

// @public
const asUnit_10: <E, _>(self: TaskEither<E, _>) => TaskEither<E, void>;

// @public
const asUnit_11: <R, E, _>(self: ReaderTaskEither<R, E, _>) => ReaderTaskEither<R, E, void>;

// @public
const asUnit_12: <S, R, E, _>(self: StateReaderTaskEither<S, R, E, _>) => StateReaderTaskEither<S, R, E, void>;

// @public
const asUnit_13: <_>(self: TaskOption<_>) => TaskOption<void>;

// @public
const asUnit_2: <E, _>(self: Either<E, _>) => Either<E, void>;

// @public
const asUnit_3: <_>(self: IO<_>) => IO<void>;

// @public
const asUnit_4: <E, _>(self: IOEither<E, _>) => IOEither<E, void>;

// @public
const asUnit_5: <_>(self: IOOption<_>) => IOOption<void>;

// @public
const asUnit_6: <R, E, _>(self: ReaderEither<R, E, _>) => ReaderEither<R, E, void>;

// @public
const asUnit_7: <R, _>(self: ReaderIO<R, _>) => ReaderIO<R, void>;

// @public
const asUnit_8: <R, _>(self: ReaderTask<R, _>) => ReaderTask<R, void>;

// @public
const asUnit_9: <_>(self: Task<_>) => Task<void>;

// @public
const between: <A>(O: Ord<A>) => (low: A, hi: A) => (a: A) => boolean;

// @public (undocumented)
const Bifunctor: Bifunctor2<URI_5>;

declare namespace bifunctor {
    export {
        Bifunctor_3 as Bifunctor,
        Bifunctor2,
        Bifunctor2C,
        Bifunctor3,
        Bifunctor3C,
        Bifunctor4
    }
}
export { bifunctor }

// @public (undocumented)
interface Bifunctor2<F extends URIS2> {
    // (undocumented)
    readonly bimap: <E, A, G, B>(fea: Kind2<F, E, A>, f: (e: E) => G, g: (a: A) => B) => Kind2<F, G, B>;
    // (undocumented)
    readonly mapLeft: <E, A, G>(fea: Kind2<F, E, A>, f: (e: E) => G) => Kind2<F, G, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Bifunctor2C<F extends URIS2, E> {
    // (undocumented)
    readonly bimap: <A, G, B>(fea: Kind2<F, E, A>, f: (e: E) => G, g: (a: A) => B) => Kind2<F, G, B>;
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly mapLeft: <A, M>(fea: Kind2<F, E, A>, f: (e: E) => M) => Kind2<F, M, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Bifunctor3<F extends URIS3> {
    // (undocumented)
    readonly bimap: <R, E, A, G, B>(fea: Kind3<F, R, E, A>, f: (e: E) => G, g: (a: A) => B) => Kind3<F, R, G, B>;
    // (undocumented)
    readonly mapLeft: <R, E, A, G>(fea: Kind3<F, R, E, A>, f: (e: E) => G) => Kind3<F, R, G, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Bifunctor3C<F extends URIS3, E> {
    // (undocumented)
    readonly bimap: <R, A, G, B>(fea: Kind3<F, R, E, A>, f: (e: E) => G, g: (a: A) => B) => Kind3<F, R, G, B>;
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly mapLeft: <R, A, G>(fea: Kind3<F, R, E, A>, f: (e: E) => G) => Kind3<F, R, G, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Bifunctor4<F extends URIS4> {
    // (undocumented)
    readonly bimap: <S, R, E, A, G, B>(fea: Kind4<F, S, R, E, A>, f: (e: E) => G, g: (a: A) => B) => Kind4<F, S, R, G, B>;
    // (undocumented)
    readonly mapLeft: <S, R, E, A, G>(fea: Kind4<F, S, R, E, A>, f: (e: E) => G) => Kind4<F, S, R, G, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const Bifunctor_10: Bifunctor4<URI_31>;

// @public (undocumented)
const Bifunctor_11: Bifunctor2<URI_34>;

// @public (undocumented)
const Bifunctor_12: Bifunctor2<URI_35>;

// @public (undocumented)
const Bifunctor_13: Bifunctor2<URI_38>;

// @public (undocumented)
const Bifunctor_2: Bifunctor2<URI_6>;

// @public (undocumented)
interface Bifunctor_3<F> {
    // (undocumented)
    readonly bimap: <E, A, G, B>(fea: HKT2<F, E, A>, f: (e: E) => G, g: (a: A) => B) => HKT2<F, G, B>;
    // (undocumented)
    readonly mapLeft: <E, A, G>(fea: HKT2<F, E, A>, f: (e: E) => G) => HKT2<F, G, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const Bifunctor_4: Bifunctor2<URI_9>;

// @public (undocumented)
const Bifunctor_5: Bifunctor2<URI_13>;

// @public (undocumented)
const Bifunctor_6: Bifunctor3<URI_18>;

// @public (undocumented)
const Bifunctor_7: Bifunctor2<URI_23>;

// @public (undocumented)
const Bifunctor_8: Bifunctor3<URI_22>;

// @public (undocumented)
const Bifunctor_9: Bifunctor2<URI_28>;

// @public @deprecated
const bifunctorTaskThese: Bifunctor2<URI_34>;

// @public
const bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: Separated<E, A>) => Separated<G, B>;

// @public
const bimap_10: <E, G, A, B>(mapSnd: (e: E) => G, mapFst: (a: A) => B) => (fa: readonly [A, E]) => readonly [B, G];

// @public
const bimap_11: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <S, R>(fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, G, B>;

// @public
const bimap_12: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: TaskThese<E, A>) => TaskThese<G, B>;

// @public
const bimap_13: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: These<E, A>) => These<G, B>;

// @public (undocumented)
function bimap_14<F extends URIS3>(F: Functor3<F>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R, FE>(fea: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<G, B>>;

// @public (undocumented)
function bimap_14<F extends URIS3, FE>(F: Functor3C<F, FE>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R>(fea: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<G, B>>;

// @public (undocumented)
function bimap_14<F extends URIS2>(F: Functor2<F>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <FE>(fea: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<G, B>>;

// @public (undocumented)
function bimap_14<F extends URIS2, FE>(F: Functor2C<F, FE>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<G, B>>;

// @public (undocumented)
function bimap_14<F extends URIS>(F: Functor1<F>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: Kind<F, These<E, A>>) => Kind<F, These<G, B>>;

// @public (undocumented)
function bimap_14<F>(F: Functor<F>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: HKT<F, These<E, A>>) => HKT<F, These<G, B>>;

// @public
const bimap_15: <E, G, A, B>(mapSnd: (e: E) => G, mapFst: (a: A) => B) => (fa: [A, E]) => [B, G];

// @public
const bimap_2: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: Either<E, A>) => Either<G, B>;

// @public
const bimap_3: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: Const<E, A>) => Const<G, B>;

// @public (undocumented)
function bimap_4<F extends URIS3>(F: Functor3<F>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R, FE>(self: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<G, B>>;

// @public (undocumented)
function bimap_4<F extends URIS3, FE>(F: Functor3C<F, FE>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R>(self: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<G, B>>;

// @public (undocumented)
function bimap_4<F extends URIS2>(F: Functor2<F>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <FE>(self: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<G, B>>;

// @public (undocumented)
function bimap_4<F extends URIS2, FE>(F: Functor2C<F, FE>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (self: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<G, B>>;

// @public (undocumented)
function bimap_4<F extends URIS>(F: Functor1<F>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (self: Kind<F, Either<E, A>>) => Kind<F, Either<G, B>>;

// @public (undocumented)
function bimap_4<F>(F: Functor<F>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (self: HKT<F, Either<E, A>>) => HKT<F, Either<G, B>>;

// @public
const bimap_5: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: IOEither<E, A>) => IOEither<G, B>;

// @public
function bimap_6<F extends URIS4>(F: Bifunctor4<F>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <S, R>(fea: Kind4<F, S, R, E, A>) => Kind4<F, S, R, G, B>;

// @public (undocumented)
function bimap_6<F extends URIS3>(F: Bifunctor3<F>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R>(fea: Kind3<F, R, E, A>) => Kind3<F, R, G, B>;

// @public (undocumented)
function bimap_6<F extends URIS3, E>(F: Bifunctor3C<F, E>): <G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R>(fea: Kind3<F, R, E, A>) => Kind3<F, R, G, B>;

// @public (undocumented)
function bimap_6<F extends URIS2>(F: Bifunctor2<F>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: Kind2<F, E, A>) => Kind2<F, G, B>;

// @public (undocumented)
function bimap_6<F extends URIS2, E>(F: Bifunctor2C<F, E>): <G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: Kind2<F, E, A>) => Kind2<F, G, B>;

// @public (undocumented)
function bimap_6<F>(F: Bifunctor_3<F>): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: HKT2<F, E, A>) => HKT2<F, G, B>;

// @public
const bimap_7: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R>(fa: ReaderEither<R, E, A>) => ReaderEither<R, G, B>;

// @public
const bimap_8: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: TaskEither<E, A>) => TaskEither<G, B>;

// @public
const bimap_9: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R>(fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, G, B>;

// @public (undocumented)
const bind: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => ReadonlyNonEmptyArray<B>) => (ma: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_10: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => IOOption<B>) => (ma: IOOption<A>) => IOOption<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_11: <N extends string, A, E, B>(name: Exclude<N, keyof A>, f: (a: A) => Reader<E, B>) => (ma: Reader<E, A>) => Reader<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_12: <N extends string, A, R, E, B>(name: Exclude<N, keyof A>, f: (a: A) => ReaderEither<R, E, B>) => (ma: ReaderEither<R, E, A>) => ReaderEither<R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_13: <N extends string, A, E, B>(name: Exclude<N, keyof A>, f: (a: A) => ReaderIO<E, B>) => (ma: ReaderIO<E, A>) => ReaderIO<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_14: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => Task<B>) => (ma: Task<A>) => Task<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_15: <N extends string, A, E, B>(name: Exclude<N, keyof A>, f: (a: A) => ReaderTask<E, B>) => (ma: ReaderTask<E, A>) => ReaderTask<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_16: <N extends string, A, E, B>(name: Exclude<N, keyof A>, f: (a: A) => TaskEither<E, B>) => (ma: TaskEither<E, A>) => TaskEither<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_17: <N extends string, A, R, E, B>(name: Exclude<N, keyof A>, f: (a: A) => ReaderTaskEither<R, E, B>) => (ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_18: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => readonly B[]) => (ma: readonly A[]) => readonly { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }[];

// @public (undocumented)
const bind_19: <N extends string, A, E, B>(name: Exclude<N, keyof A>, f: (a: A) => State<E, B>) => (ma: State<E, A>) => State<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_2: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => NonEmptyArray<B>) => (ma: NonEmptyArray<A>) => NonEmptyArray<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_20: <N extends string, A, S, R, E, B>(name: Exclude<N, keyof A>, f: (a: A) => StateReaderTaskEither<S, R, E, B>) => (ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_21: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => TaskOption<B>) => (ma: TaskOption<A>) => TaskOption<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_22: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => Tree<B>) => (ma: Tree<A>) => Tree<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
function bind_3<M extends URIS4>(M: Chain4<M>): <N extends string, A, S, R, E, B>(name: Exclude<N, keyof A>, f: (a: A) => Kind4<M, S, R, E, B>) => (ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function bind_3<M extends URIS3>(M: Chain3<M>): <N extends string, A, R, E, B>(name: Exclude<N, keyof A>, f: (a: A) => Kind3<M, R, E, B>) => (ma: Kind3<M, R, E, A>) => Kind3<M, R, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function bind_3<M extends URIS3, E>(M: Chain3C<M, E>): <N extends string, A, R, B>(name: Exclude<N, keyof A>, f: (a: A) => Kind3<M, R, E, B>) => (ma: Kind3<M, R, E, A>) => Kind3<M, R, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function bind_3<M extends URIS2>(M: Chain2<M>): <N extends string, A, E, B>(name: Exclude<N, keyof A>, f: (a: A) => Kind2<M, E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function bind_3<M extends URIS2, E>(M: Chain2C<M, E>): <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => Kind2<M, E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function bind_3<M extends URIS>(M: Chain1<M>): <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => Kind<M, B>) => (ma: Kind<M, A>) => Kind<M, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function bind_3<M>(M: Chain_5<M>): <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => HKT<M, B>) => (ma: HKT<M, A>) => HKT<M, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
const bind_4: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => Option_2<B>) => (ma: Option_2<A>) => Option_2<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_5: <N extends string, A, E, B>(name: Exclude<N, keyof A>, f: (a: A) => Either<E, B>) => (ma: Either<E, A>) => Either<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_6: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B[]) => (ma: A[]) => { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }[];

// @public (undocumented)
const bind_7: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (ma: A) => { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; };

// @public (undocumented)
const bind_8: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => IO<B>) => (ma: IO<A>) => IO<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bind_9: <N extends string, A, E, B>(name: Exclude<N, keyof A>, f: (a: A) => IOEither<E, B>) => (ma: IOEither<E, A>) => IOEither<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const bindTo: <N extends string>(name: N) => <A>(fa: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<{ readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_10: <N extends string>(name: N) => <A>(fa: IOOption<A>) => IOOption<{ readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_11: <N extends string>(name: N) => <E, A>(fa: Reader<E, A>) => Reader<E, { readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_12: <N extends string>(name: N) => <R, E, A>(fa: ReaderEither<R, E, A>) => ReaderEither<R, E, { readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_13: <N extends string>(name: N) => <E, A>(fa: ReaderIO<E, A>) => ReaderIO<E, { readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_14: <N extends string>(name: N) => <A>(fa: Task<A>) => Task<{ readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_15: <N extends string>(name: N) => <E, A>(fa: ReaderTask<E, A>) => ReaderTask<E, { readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_16: <N extends string>(name: N) => <E, A>(fa: TaskEither<E, A>) => TaskEither<E, { readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_17: <N extends string>(name: N) => <R, E, A>(fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, { readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_18: <N extends string>(name: N) => <A>(fa: readonly A[]) => readonly { readonly [K in N]: A; }[];

// @public (undocumented)
const bindTo_19: <N extends string>(name: N) => <E, A>(fa: State<E, A>) => State<E, { readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_2: <N extends string>(name: N) => <A>(fa: NonEmptyArray<A>) => NonEmptyArray<{ readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_20: <N extends string>(name: N) => <S, R, E, A>(fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, { readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_21: <N extends string>(name: N) => <A>(fa: TaskOption<A>) => TaskOption<{ readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_22: <N extends string>(name: N) => <A>(fa: Tree<A>) => Tree<{ readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_3: <N extends string>(name: N) => <A>(fa: Option_2<A>) => Option_2<{ readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_4: <N extends string>(name: N) => <E, A>(fa: Either<E, A>) => Either<E, { readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_5: <N extends string>(name: N) => <A>(fa: A[]) => { readonly [K in N]: A; }[];

// @public (undocumented)
function bindTo_6<F extends URIS4>(F: Functor4<F>): <N extends string>(name: N) => <S, R, E, A>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, {
    readonly [K in N]: A;
}>;

// @public (undocumented)
function bindTo_6<F extends URIS3>(F: Functor3<F>): <N extends string>(name: N) => <R, E, A>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, {
    readonly [K in N]: A;
}>;

// @public (undocumented)
function bindTo_6<F extends URIS3, E>(F: Functor3C<F, E>): <N extends string>(name: N) => <R, A>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, {
    readonly [K in N]: A;
}>;

// @public (undocumented)
function bindTo_6<F extends URIS2>(F: Functor2<F>): <N extends string>(name: N) => <E, A>(fa: Kind2<F, E, A>) => Kind2<F, E, {
    readonly [K in N]: A;
}>;

// @public (undocumented)
function bindTo_6<F extends URIS2, E>(F: Functor2C<F, E>): <N extends string>(name: N) => <A>(fa: Kind2<F, E, A>) => Kind2<F, E, {
    readonly [K in N]: A;
}>;

// @public (undocumented)
function bindTo_6<F extends URIS>(F: Functor1<F>): <N extends string>(name: N) => <A>(fa: Kind<F, A>) => Kind<F, {
    readonly [K in N]: A;
}>;

// @public (undocumented)
function bindTo_6<F>(F: Functor<F>): <N extends string>(name: N) => <A>(fa: HKT<F, A>) => HKT<F, {
    readonly [K in N]: A;
}>;

// @public (undocumented)
const bindTo_7: <N extends string>(name: N) => <A>(fa: A) => { readonly [K in N]: A; };

// @public (undocumented)
const bindTo_8: <N extends string>(name: N) => <A>(fa: IO<A>) => IO<{ readonly [K in N]: A; }>;

// @public (undocumented)
const bindTo_9: <N extends string>(name: N) => <E, A>(fa: IOEither<E, A>) => IOEither<E, { readonly [K in N]: A; }>;

// @public
const bindW: <N extends string, A, E2, B>(name: Exclude<N, keyof A>, f: (a: A) => Either<E2, B>) => <E1>(fa: Either<E1, A>) => Either<E1 | E2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const bindW_2: <N extends string, A, E2, B>(name: Exclude<N, keyof A>, f: (a: A) => IOEither<E2, B>) => <E1>(fa: IOEither<E1, A>) => IOEither<E1 | E2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const bindW_3: <N extends string, A, R2, B>(name: Exclude<N, keyof A>, f: (a: A) => Reader<R2, B>) => <R1>(fa: Reader<R1, A>) => Reader<R1 & R2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const bindW_4: <N extends string, A, R2, E2, B>(name: Exclude<N, keyof A>, f: (a: A) => ReaderEither<R2, E2, B>) => <R1, E1>(fa: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E1 | E2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const bindW_5: <N extends string, A, R2, B>(name: Exclude<N, keyof A>, f: (a: A) => ReaderIO<R2, B>) => <R1>(fa: ReaderIO<R1, A>) => ReaderIO<R1 & R2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const bindW_6: <N extends string, A, R2, B>(name: Exclude<N, keyof A>, f: (a: A) => ReaderTask<R2, B>) => <R1>(fa: ReaderTask<R1, A>) => ReaderTask<R1 & R2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const bindW_7: <N extends string, A, E2, B>(name: Exclude<N, keyof A>, f: (a: A) => TaskEither<E2, B>) => <E1>(fa: TaskEither<E1, A>) => TaskEither<E1 | E2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const bindW_8: <N extends string, A, R2, E2, B>(name: Exclude<N, keyof A>, f: (a: A) => ReaderTaskEither<R2, E2, B>) => <R1, E1>(fa: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public
const bindW_9: <N extends string, A, S, R2, E2, B>(name: Exclude<N, keyof A>, f: (a: A) => StateReaderTaskEither<S, R2, E2, B>) => <R1, E1>(fa: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E1 | E2, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

declare namespace boolean {
    export {
        isBoolean,
        matchW_4 as matchW,
        foldW_3 as foldW,
        match_4 as match,
        fold_7 as fold,
        Eq_2 as Eq,
        BooleanAlgebra,
        SemigroupAll,
        SemigroupAny,
        MonoidAll,
        MonoidAny,
        Ord_2 as Ord,
        Show_2 as Show
    }
}
export { boolean }

// @public (undocumented)
const BooleanAlgebra: booleanAlgebra.BooleanAlgebra<boolean>;

declare namespace booleanAlgebra {
    export {
        BooleanAlgebra_2 as BooleanAlgebra,
        reverse_7 as reverse,
        booleanAlgebraVoid,
        getDualBooleanAlgebra,
        booleanAlgebraBoolean,
        getFunctionBooleanAlgebra
    }
}
export { booleanAlgebra }

// @public (undocumented)
interface BooleanAlgebra_2<A> extends HeytingAlgebra<A> {
}

// @public @deprecated
const booleanAlgebraBoolean: BooleanAlgebra_2<boolean>;

// @public (undocumented)
const booleanAlgebraVoid: BooleanAlgebra_2<void>;

// @public (undocumented)
interface Both<E, A> {
    // (undocumented)
    readonly left: E;
    // (undocumented)
    readonly right: A;
    // (undocumented)
    readonly _tag: 'Both';
}

// @public (undocumented)
const both: <E, A>(e: E, a: A) => TaskThese<E, A>;

// @public (undocumented)
function both_2<E, A>(left: E, right: A): These<E, A>;

// @public (undocumented)
function both_3<F extends URIS3>(F: Pointed3<F>): <E, A, S, R>(e: E, a: A) => Kind3<F, S, R, These<E, A>>;

// @public (undocumented)
function both_3<F extends URIS3, R>(F: Pointed3C<F, R>): <E, A>(e: E, a: A) => Kind3<F, R, R, These<E, A>>;

// @public (undocumented)
function both_3<F extends URIS2>(F: Pointed2<F>): <E, A, R>(e: E, a: A) => Kind2<F, R, These<E, A>>;

// @public (undocumented)
function both_3<F extends URIS2, R>(F: Pointed2C<F, R>): <E, A>(e: E, a: A) => Kind2<F, R, These<E, A>>;

// @public (undocumented)
function both_3<F extends URIS>(F: Pointed1<F>): <E, A>(e: E, a: A) => Kind<F, These<E, A>>;

// @public (undocumented)
function both_3<F>(F: Pointed<F>): <E, A = never>(e: E, a: A) => HKT<F, These<E, A>>;

// @public (undocumented)
interface Bounded<A> extends Ord<A> {
    // (undocumented)
    readonly bottom: A;
    // (undocumented)
    readonly top: A;
}

declare namespace bounded {
    export {
        Bounded,
        clamp_2 as clamp,
        reverse_8 as reverse,
        boundedNumber
    }
}
export { bounded }

// @public (undocumented)
const Bounded_2: bounded.Bounded<number>;

// @public (undocumented)
interface BoundedDistributiveLattice<A> extends BoundedLattice<A>, DistributiveLattice<A> {
}

declare namespace boundedDistributiveLattice {
    export {
        getMinMaxBoundedDistributiveLattice,
        BoundedDistributiveLattice
    }
}
export { boundedDistributiveLattice }

// @public (undocumented)
interface BoundedJoinSemilattice<A> extends JoinSemilattice<A> {
    // (undocumented)
    readonly zero: A;
}

declare namespace boundedJoinSemilattice {
    export {
        BoundedJoinSemilattice
    }
}
export { boundedJoinSemilattice }

// @public (undocumented)
interface BoundedLattice<A> extends BoundedJoinSemilattice<A>, BoundedMeetSemilattice<A> {
}

declare namespace boundedLattice {
    export {
        BoundedLattice
    }
}
export { boundedLattice }

// @public (undocumented)
interface BoundedMeetSemilattice<A> extends MeetSemilattice<A> {
    // (undocumented)
    readonly one: A;
}

declare namespace boundedMeetSemilattice {
    export {
        BoundedMeetSemilattice
    }
}
export { boundedMeetSemilattice }

// @public @deprecated
const boundedNumber: Bounded<number>;

// @public
const bracket: <E, A, B>(acquire: IOEither<E, A>, use: (a: A) => IOEither<E, B>, release: (a: A, e: either.Either<E, B>) => IOEither<E, void>) => IOEither<E, B>;

// @public
function bracket_2<R, E, A, B>(acquire: ReaderTaskEither<R, E, A>, use: (a: A) => ReaderTaskEither<R, E, B>, release: (a: A, e: Either<E, B>) => ReaderTaskEither<R, E, void>): ReaderTaskEither<R, E, B>;

// @public
const bracket_3: <E, A, B>(acquire: TaskEither<E, A>, use: (a: A) => TaskEither<E, B>, release: (a: A, e: either.Either<E, B>) => TaskEither<E, void>) => TaskEither<E, B>;

// @public
const bracketW: <E1, A, E2, B, E3>(acquire: IOEither<E1, A>, use: (a: A) => IOEither<E2, B>, release: (a: A, e: either.Either<E2, B>) => IOEither<E3, void>) => IOEither<E1 | E2 | E3, B>;

// @public
function bracketW_2<R1, E1, A, R2, E2, B, R3, E3>(acquire: ReaderTaskEither<R1, E1, A>, use: (a: A) => ReaderTaskEither<R2, E2, B>, release: (a: A, e: Either<E2, B>) => ReaderTaskEither<R3, E3, void>): ReaderTaskEither<R1 & R2 & R3, E1 | E2 | E3, B>;

// @public
const bracketW_3: <E1, A, E2, B, E3>(acquire: TaskEither<E1, A>, use: (a: A) => TaskEither<E2, B>, release: (a: A, e: either.Either<E2, B>) => TaskEither<E3, void>) => TaskEither<E1 | E2 | E3, B>;

// @public (undocumented)
interface Category<F> extends Semigroupoid<F> {
    // (undocumented)
    readonly id: <A>() => HKT2<F, A, A>;
}

declare namespace category {
    export {
        Category,
        Category2,
        Category3,
        Category4
    }
}
export { category }

// @public (undocumented)
interface Category2<F extends URIS2> extends Semigroupoid2<F> {
    // (undocumented)
    readonly id: <A>() => Kind2<F, A, A>;
}

// @public (undocumented)
interface Category3<F extends URIS3> extends Semigroupoid3<F> {
    // (undocumented)
    readonly id: <R, A>() => Kind3<F, R, A, A>;
}

// @public (undocumented)
interface Category4<F extends URIS4> extends Semigroupoid4<F> {
    // (undocumented)
    readonly id: <S, R, A>() => Kind4<F, S, R, A, A>;
}

// @public (undocumented)
const Category_2: Category2<URI_17>;

// @public
function censor<P>(f: (p: P) => P): <A>(wa: Traced<P, A>) => Traced<P, A>;

// @public
const censor_2: <W>(f: (w: W) => W) => <A>(fa: Writer<W, A>) => Writer<W, A>;

// @public (undocumented)
const Chain: Chain1<URI_2>;

declare namespace chain {
    export {
        chainFirst_4 as chainFirst,
        bind_3 as bind,
        Chain_5 as Chain,
        Chain1,
        Chain2,
        Chain2C,
        Chain3,
        Chain3C,
        Chain4
    }
}
export { chain }

// @public (undocumented)
interface Chain1<F extends URIS> extends Apply1<F> {
    // (undocumented)
    readonly chain: <A, B>(fa: Kind<F, A>, f: (a: A) => Kind<F, B>) => Kind<F, B>;
}

// @public (undocumented)
interface Chain2<F extends URIS2> extends Apply2<F> {
    // (undocumented)
    readonly chain: <E, A, B>(fa: Kind2<F, E, A>, f: (a: A) => Kind2<F, E, B>) => Kind2<F, E, B>;
}

// @public (undocumented)
interface Chain2C<F extends URIS2, E> extends Apply2C<F, E> {
    // (undocumented)
    readonly chain: <A, B>(fa: Kind2<F, E, A>, f: (a: A) => Kind2<F, E, B>) => Kind2<F, E, B>;
}

// @public (undocumented)
interface Chain3<F extends URIS3> extends Apply3<F> {
    // (undocumented)
    readonly chain: <R, E, A, B>(fa: Kind3<F, R, E, A>, f: (a: A) => Kind3<F, R, E, B>) => Kind3<F, R, E, B>;
}

// @public (undocumented)
interface Chain3C<F extends URIS3, E> extends Apply3C<F, E> {
    // (undocumented)
    readonly chain: <R, A, B>(fa: Kind3<F, R, E, A>, f: (a: A) => Kind3<F, R, E, B>) => Kind3<F, R, E, B>;
}

// @public (undocumented)
interface Chain4<F extends URIS4> extends Apply4<F> {
    // (undocumented)
    readonly chain: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, f: (a: A) => Kind4<F, S, R, E, B>) => Kind4<F, S, R, E, B>;
}

// @public (undocumented)
const Chain_10: chain.Chain1<URI_14>;

// @public
const chain_10: <E, A, B>(f: (a: A) => IOEither<E, B>) => (ma: IOEither<E, A>) => IOEither<E, B>;

// @public (undocumented)
const Chain_11: chain.Chain2<URI_17>;

// @public
const chain_11: <A, B>(f: (a: A) => IOOption<B>) => (ma: IOOption<A>) => IOOption<B>;

// @public (undocumented)
const Chain_12: chain.Chain3<URI_18>;

// @public (undocumented)
function chain_12<M extends URIS4>(M: Monad4<M>): <A, S, R, E, B>(f: (a: A) => Kind4<M, S, R, E, Option_2<B>>) => (ma: Kind4<M, S, R, E, Option_2<A>>) => Kind4<M, S, R, E, Option_2<B>>;

// @public (undocumented)
function chain_12<M extends URIS3>(M: Monad3<M>): <A, R, E, B>(f: (a: A) => Kind3<M, R, E, Option_2<B>>) => (ma: Kind3<M, R, E, Option_2<A>>) => Kind3<M, R, E, Option_2<B>>;

// @public (undocumented)
function chain_12<M extends URIS3, E>(M: Monad3C<M, E>): <A, R, B>(f: (a: A) => Kind3<M, R, E, Option_2<B>>) => (ma: Kind3<M, R, E, Option_2<A>>) => Kind3<M, R, E, Option_2<B>>;

// @public (undocumented)
function chain_12<M extends URIS2>(M: Monad2<M>): <A, E, B>(f: (a: A) => Kind2<M, E, Option_2<B>>) => (ma: Kind2<M, E, Option_2<A>>) => Kind2<M, E, Option_2<B>>;

// @public (undocumented)
function chain_12<M extends URIS2, E>(M: Monad2C<M, E>): <A, B>(f: (a: A) => Kind2<M, E, Option_2<B>>) => (ma: Kind2<M, E, Option_2<A>>) => Kind2<M, E, Option_2<B>>;

// @public (undocumented)
function chain_12<M extends URIS>(M: Monad1<M>): <A, B>(f: (a: A) => Kind<M, Option_2<B>>) => (ma: Kind<M, Option_2<A>>) => Kind<M, Option_2<B>>;

// @public (undocumented)
function chain_12<M>(M: Monad_6<M>): <A, B>(f: (a: A) => HKT<M, Option_2<B>>) => (ma: HKT<M, Option_2<A>>) => HKT<M, Option_2<B>>;

// @public (undocumented)
const Chain_13: chain.Chain2<URI_19>;

// @public
function chain_13<F extends URIS4>(F: Chain4<F>): <A, S, R, E, B>(f: (a: A) => Kind4<F, S, R, E, B>) => (fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function chain_13<F extends URIS3>(F: Chain3<F>): <A, R, E, B>(f: (a: A) => Kind3<F, R, E, B>) => (fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function chain_13<F extends URIS3, E>(F: Chain3C<F, E>): <A, R, B>(f: (a: A) => Kind3<F, R, E, B>) => (fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function chain_13<F extends URIS2>(F: Chain2<F>): <A, E, B>(f: (a: A) => Kind2<F, E, B>) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function chain_13<F extends URIS2, E>(F: Chain2C<F, E>): <A, B>(f: (a: A) => Kind2<F, E, B>) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function chain_13<F extends URIS>(F: Chain1<F>): <A, B>(f: (a: A) => Kind<F, B>) => (fa: Kind<F, A>) => Kind<F, B>;

// @public (undocumented)
function chain_13<F>(F: Chain_5<F>): <A, B>(f: (a: A) => HKT<F, B>) => (fa: HKT<F, A>) => HKT<F, B>;

// @public (undocumented)
const Chain_14: chain.Chain2<URI_20>;

// @public
const chain_14: <A, R, B>(f: (a: A) => Reader<R, B>) => (ma: Reader<R, A>) => Reader<R, B>;

// @public (undocumented)
const Chain_15: chain.Chain1<URI_21>;

// @public
const chain_15: <R, E, A, B>(f: (a: A) => ReaderEither<R, E, B>) => (ma: ReaderEither<R, E, A>) => ReaderEither<R, E, B>;

// @public (undocumented)
const Chain_16: chain.Chain2<URI_23>;

// @public
const chain_16: <A, R, B>(f: (a: A) => ReaderIO<R, B>) => (ma: ReaderIO<R, A>) => ReaderIO<R, B>;

// @public (undocumented)
const Chain_17: chain.Chain3<URI_22>;

// @public (undocumented)
function chain_17<M extends URIS4>(M: Chain4<M>): <A, R, S, FR, FE, B>(f: (a: A) => Reader<R, Kind4<M, S, FR, FE, B>>) => (ma: Reader<R, Kind4<M, S, FR, FE, A>>) => Reader<R, Kind4<M, S, FR, FE, B>>;

// @public (undocumented)
function chain_17<M extends URIS3>(M: Chain3<M>): <A, R, FR, FE, B>(f: (a: A) => Reader<R, Kind3<M, FR, FE, B>>) => (ma: Reader<R, Kind3<M, FR, FE, A>>) => Reader<R, Kind3<M, FR, FE, B>>;

// @public (undocumented)
function chain_17<M extends URIS3, FE>(M: Chain3C<M, FE>): <A, R, FR, B>(f: (a: A) => Reader<R, Kind3<M, FR, FE, B>>) => (ma: Reader<R, Kind3<M, FR, FE, A>>) => Reader<R, Kind3<M, FR, FE, B>>;

// @public (undocumented)
function chain_17<M extends URIS2>(M: Chain2<M>): <A, R, FE, B>(f: (a: A) => Reader<R, Kind2<M, FE, B>>) => (ma: Reader<R, Kind2<M, FE, A>>) => Reader<R, Kind2<M, FE, B>>;

// @public (undocumented)
function chain_17<M extends URIS2, FE>(M: Chain2C<M, FE>): <A, R, B>(f: (a: A) => Reader<R, Kind2<M, FE, B>>) => (ma: Reader<R, Kind2<M, FE, A>>) => Reader<R, Kind2<M, FE, B>>;

// @public (undocumented)
function chain_17<M extends URIS>(M: Chain1<M>): <A, R, B>(f: (a: A) => Reader<R, Kind<M, B>>) => (ma: Reader<R, Kind<M, A>>) => Reader<R, Kind<M, B>>;

// @public (undocumented)
function chain_17<M>(M: Chain_5<M>): <A, R, B>(f: (a: A) => Reader<R, HKT<M, B>>) => (ma: Reader<R, HKT<M, A>>) => Reader<R, HKT<M, B>>;

// @public (undocumented)
const Chain_18: Chain1<URI_24>;

// @public
const chain_18: <A, B>(f: (a: A) => Task<B>) => (ma: Task<A>) => Task<B>;

// @public (undocumented)
const Chain_19: chain.Chain2<URI_30>;

// @public
const chain_19: <A, R, B>(f: (a: A) => ReaderTask<R, B>) => (ma: ReaderTask<R, A>) => ReaderTask<R, B>;

// @public (undocumented)
const Chain_2: Chain1<URI_3>;

// @public
const chain_2: <A, B>(f: (a: A) => ReadonlyNonEmptyArray<B>) => (ma: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>;

// @public (undocumented)
const Chain_20: chain.Chain4<URI_31>;

// @public
const chain_20: <E, A, B>(f: (a: A) => TaskEither<E, B>) => (ma: TaskEither<E, A>) => TaskEither<E, B>;

// @public (undocumented)
const Chain_21: chain.Chain1<URI_33>;

// @public
const chain_21: <R, E, A, B>(f: (a: A) => ReaderTaskEither<R, E, B>) => (ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;

// @public (undocumented)
const Chain_22: Chain1<URI_37>;

// @public
const chain_22: <A, B>(f: (a: A) => ReadonlyArray<B>) => (ma: ReadonlyArray<A>) => ReadonlyArray<B>;

// @public (undocumented)
function chain_23<B>(E: Eq<B>): <A>(f: (x: A) => ReadonlySet<B>) => (set: ReadonlySet<A>) => ReadonlySet<B>;

// @public
function chain_24<B>(E: Eq<B>): <A>(f: (x: A) => Set<B>) => (set: Set<A>) => Set<B>;

// @public
const chain_25: <S, A, B>(f: (a: A) => State<S, B>) => (ma: State<S, A>) => State<S, B>;

// @public
const chain_26: <S, R, E, A, B>(f: (a: A) => StateReaderTaskEither<S, R, E, B>) => (ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;

// @public (undocumented)
function chain_27<M extends URIS3>(M: Chain3<M>): <A, S, R, E, B>(f: (a: A) => StateT3<M, S, R, E, B>) => (ma: StateT3<M, S, R, E, A>) => StateT3<M, S, R, E, B>;

// @public (undocumented)
function chain_27<M extends URIS3, E>(M: Chain3C<M, E>): <A, S, R, B>(f: (a: A) => StateT3<M, S, R, E, B>) => (ma: StateT3<M, S, R, E, A>) => StateT3<M, S, R, E, B>;

// @public (undocumented)
function chain_27<M extends URIS2>(M: Chain2<M>): <A, S, E, B>(f: (a: A) => StateT2<M, S, E, B>) => (ma: StateT2<M, S, E, A>) => StateT2<M, S, E, B>;

// @public (undocumented)
function chain_27<M extends URIS2, E>(M: Chain2C<M, E>): <A, S, B>(f: (a: A) => StateT2<M, S, E, B>) => (ma: StateT2<M, S, E, A>) => StateT2<M, S, E, B>;

// @public (undocumented)
function chain_27<M extends URIS>(M: Chain1<M>): <A, S, B>(f: (a: A) => StateT1<M, S, B>) => (ma: StateT1<M, S, A>) => StateT1<M, S, B>;

// @public (undocumented)
function chain_27<M>(M: Chain_5<M>): <A, S, B>(f: (a: A) => StateT<M, S, B>) => (ma: StateT<M, S, A>) => StateT<M, S, B>;

// @public
const chain_28: <A, B>(f: (a: A) => TaskOption<B>) => (ma: TaskOption<A>) => TaskOption<B>;

// @public (undocumented)
function chain_29<M extends URIS3, E>(M: Monad3<M>, S: Semigroup<E>): <A, R, ME, B>(f: (a: A) => Kind3<M, R, ME, These<E, B>>) => (ma: Kind3<M, R, ME, These<E, A>>) => Kind3<M, R, ME, These<E, B>>;

// @public (undocumented)
function chain_29<M extends URIS3, ME, E>(M: Monad3C<M, ME>, S: Semigroup<E>): <A, R, B>(f: (a: A) => Kind3<M, R, ME, These<E, B>>) => (ma: Kind3<M, R, ME, These<E, A>>) => Kind3<M, R, ME, These<E, B>>;

// @public (undocumented)
function chain_29<M extends URIS2, E>(M: Monad2<M>, S: Semigroup<E>): <A, ME, B>(f: (a: A) => Kind2<M, ME, These<E, B>>) => (ma: Kind2<M, ME, These<E, A>>) => Kind2<M, ME, These<E, B>>;

// @public (undocumented)
function chain_29<M extends URIS2, ME, E>(M: Monad2C<M, ME>, S: Semigroup<E>): <A, B>(f: (a: A) => Kind2<M, ME, These<E, B>>) => (ma: Kind2<M, ME, These<E, A>>) => Kind2<M, ME, These<E, B>>;

// @public (undocumented)
function chain_29<M extends URIS, E>(M: Monad1<M>, S: Semigroup<E>): <A, B>(f: (a: A) => Kind<M, These<E, B>>) => (ma: Kind<M, These<E, A>>) => Kind<M, These<E, B>>;

// @public (undocumented)
function chain_29<M, E>(M: Monad_6<M>, S: Semigroup<E>): <A, B>(f: (a: A) => HKT<M, These<E, B>>) => (ma: HKT<M, These<E, A>>) => HKT<M, These<E, B>>;

// @public (undocumented)
const Chain_3: Chain1<URI_4>;

// @public
const chain_3: <A, B>(f: (a: A) => NonEmptyArray<B>) => (ma: NonEmptyArray<A>) => NonEmptyArray<B>;

// @public
const chain_30: <A, B>(f: (a: A) => Tree<B>) => (ma: Tree<A>) => Tree<B>;

// @public (undocumented)
const Chain_4: chain.Chain1<URI_7>;

// @public
const chain_4: <A, B>(f: (a: A) => Option_2<B>) => (ma: Option_2<A>) => Option_2<B>;

// @public (undocumented)
interface Chain_5<F> extends Apply<F> {
    // (undocumented)
    readonly chain: <A, B>(fa: HKT<F, A>, f: (a: A) => HKT<F, B>) => HKT<F, B>;
}

// @public
const chain_5: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Either<E, A>) => Either<E, B>;

// @public (undocumented)
const Chain_6: chain.Chain2<URI_6>;

// @public
const chain_6: <A, B>(f: (a: A) => Array<B>) => (ma: Array<A>) => Array<B>;

// @public (undocumented)
const Chain_7: Chain1<URI_11>;

// @public (undocumented)
function chain_7<M extends URIS3>(M: Monad3<M>): <A, R, ME, E, B>(f: (a: A) => Kind3<M, R, ME, Either<E, B>>) => (ma: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, B>>;

// @public (undocumented)
function chain_7<M extends URIS3, ME>(M: Monad3C<M, ME>): <A, R, E, B>(f: (a: A) => Kind3<M, R, ME, Either<E, B>>) => (ma: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, B>>;

// @public (undocumented)
function chain_7<M extends URIS2>(M: Monad2<M>): <A, ME, E, B>(f: (a: A) => Kind2<M, ME, Either<E, B>>) => (ma: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, B>>;

// @public (undocumented)
function chain_7<M extends URIS2, ME>(M: Monad2C<M, ME>): <A, E, B>(f: (a: A) => Kind2<M, ME, Either<E, B>>) => (ma: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, B>>;

// @public (undocumented)
function chain_7<M extends URIS>(M: Monad1<M>): <A, E, B>(f: (a: A) => Kind<M, Either<E, B>>) => (ma: Kind<M, Either<E, A>>) => Kind<M, Either<E, B>>;

// @public (undocumented)
function chain_7<M>(M: Monad_6<M>): <A, E, B>(f: (a: A) => HKT<M, Either<E, B>>) => (ma: HKT<M, Either<E, A>>) => HKT<M, Either<E, B>>;

// @public (undocumented)
const Chain_8: chain.Chain1<URI_12>;

// @public
const chain_8: <A, B>(f: (a: A) => Identity<B>) => (ma: Identity<A>) => Identity<B>;

// @public (undocumented)
const Chain_9: chain.Chain2<URI_13>;

// @public
const chain_9: <A, B>(f: (a: A) => IO<B>) => (ma: IO<A>) => IO<B>;

// @public (undocumented)
const chainEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Option_2<A>) => Option_2<B>;

// @public (undocumented)
function chainEitherK_2<M extends URIS4>(F: FromEither4<M>, M: Chain4<M>): <A, E, B>(f: (a: A) => Either<E, B>) => <S, R>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>;

// @public (undocumented)
function chainEitherK_2<M extends URIS3>(F: FromEither3<M>, M: Chain3<M>): <A, E, B>(f: (a: A) => Either<E, B>) => <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>;

// @public (undocumented)
function chainEitherK_2<M extends URIS3, E>(F: FromEither3C<M, E>, M: Chain3C<M, E>): <A, B>(f: (a: A) => Either<E, B>) => <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>;

// @public (undocumented)
function chainEitherK_2<M extends URIS2>(F: FromEither2<M>, M: Chain2<M>): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, B>;

// @public (undocumented)
function chainEitherK_2<M extends URIS2, E>(F: FromEither2C<M, E>, M: Chain2C<M, E>): <A, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, B>;

// @public (undocumented)
function chainEitherK_2<M extends URIS>(F: FromEither1<M>, M: Chain1<M>): <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Kind<M, A>) => Kind<M, B>;

// @public (undocumented)
function chainEitherK_2<M>(F: FromEither_4<M>, M: Chain_5<M>): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: HKT2<M, E, A>) => HKT2<M, E, B>;

// @public
const chainEitherK_3: <E, A, B>(f: (a: A) => either.Either<E, B>) => (ma: IOEither<E, A>) => IOEither<E, B>;

// @public
const chainEitherK_4: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: IOOption<A>) => IOOption<B>;

// @public
const chainEitherK_5: <E, A, B>(f: (a: A) => either.Either<E, B>) => <R>(ma: ReaderEither<R, E, A>) => ReaderEither<R, E, B>;

// @public
const chainEitherK_6: <E, A, B>(f: (a: A) => either.Either<E, B>) => (ma: TaskEither<E, A>) => TaskEither<E, B>;

// @public
const chainEitherK_7: <E, A, B>(f: (a: A) => either.Either<E, B>) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;

// @public
const chainEitherK_8: <E, A, B>(f: (a: A) => either.Either<E, B>) => <S, R>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;

// @public (undocumented)
const chainEitherK_9: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: TaskOption<A>) => TaskOption<B>;

// @public
const chainEitherKW: <E2, A, B>(f: (a: A) => Either<E2, B>) => <E1>(ma: IOEither<E1, A>) => IOEither<E1 | E2, B>;

// @public
const chainEitherKW_2: <E2, A, B>(f: (a: A) => Either<E2, B>) => <R, E1>(ma: ReaderEither<R, E1, A>) => ReaderEither<R, E1 | E2, B>;

// @public
const chainEitherKW_3: <E2, A, B>(f: (a: A) => Either<E2, B>) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, B>;

// @public
const chainEitherKW_4: <E2, A, B>(f: (a: A) => Either<E2, B>) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, B>;

// @public
const chainEitherKW_5: <E2, A, B>(f: (a: A) => Either<E2, B>) => <S, R, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, B>;

// @public
const chainFirst: <A, B>(f: (a: A) => ReadonlyNonEmptyArray<B>) => (first: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public
const chainFirst_10: <A, B>(f: (a: A) => IOOption<B>) => (first: IOOption<A>) => IOOption<A>;

// @public
const chainFirst_11: <A, R, B>(f: (a: A) => Reader<R, B>) => (first: Reader<R, A>) => Reader<R, A>;

// @public
const chainFirst_12: <R, E, A, B>(f: (a: A) => ReaderEither<R, E, B>) => (ma: ReaderEither<R, E, A>) => ReaderEither<R, E, A>;

// @public
const chainFirst_13: <A, R, B>(f: (a: A) => ReaderIO<R, B>) => (first: ReaderIO<R, A>) => ReaderIO<R, A>;

// @public
const chainFirst_14: <A, B>(f: (a: A) => Task<B>) => (first: Task<A>) => Task<A>;

// @public
const chainFirst_15: <A, R, B>(f: (a: A) => ReaderTask<R, B>) => (first: ReaderTask<R, A>) => ReaderTask<R, A>;

// @public
const chainFirst_16: <E, A, B>(f: (a: A) => TaskEither<E, B>) => (ma: TaskEither<E, A>) => TaskEither<E, A>;

// @public
const chainFirst_17: <R, E, A, B>(f: (a: A) => ReaderTaskEither<R, E, B>) => (ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;

// @public
const chainFirst_18: <A, B>(f: (a: A) => ReadonlyArray<B>) => (first: ReadonlyArray<A>) => ReadonlyArray<A>;

// @public
const chainFirst_19: <S, A, B>(f: (a: A) => State<S, B>) => (ma: State<S, A>) => State<S, A>;

// @public
const chainFirst_2: <A, B>(f: (a: A) => NonEmptyArray<B>) => (first: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public
const chainFirst_20: <S, R, E, A, B>(f: (a: A) => StateReaderTaskEither<S, R, E, B>) => (ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>;

// @public
const chainFirst_21: <A, B>(f: (a: A) => TaskOption<B>) => (first: TaskOption<A>) => TaskOption<A>;

// @public
const chainFirst_22: <A, B>(f: (a: A) => Tree<B>) => (first: Tree<A>) => Tree<A>;

// @public
const chainFirst_3: <A, B>(f: (a: A) => Array<B>) => (first: Array<A>) => Array<A>;

// @public (undocumented)
function chainFirst_4<M extends URIS4>(M: Chain4<M>): <A, S, R, E, _>(f: (a: A) => Kind4<M, S, R, E, _>) => (first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>;

// @public (undocumented)
function chainFirst_4<M extends URIS3>(M: Chain3<M>): <A, R, E, _>(f: (a: A) => Kind3<M, R, E, _>) => (first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>;

// @public (undocumented)
function chainFirst_4<M extends URIS3, E>(M: Chain3C<M, E>): <A, R, _>(f: (a: A) => Kind3<M, R, E, _>) => (first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>;

// @public (undocumented)
function chainFirst_4<M extends URIS2>(M: Chain2<M>): <A, E, _>(f: (a: A) => Kind2<M, E, _>) => (first: Kind2<M, E, A>) => Kind2<M, E, A>;

// @public (undocumented)
function chainFirst_4<M extends URIS2, E>(M: Chain2C<M, E>): <A, _>(f: (a: A) => Kind2<M, E, _>) => (first: Kind2<M, E, A>) => Kind2<M, E, A>;

// @public (undocumented)
function chainFirst_4<M extends URIS>(M: Chain1<M>): <A, _>(f: (a: A) => Kind<M, _>) => (first: Kind<M, A>) => Kind<M, A>;

// @public (undocumented)
function chainFirst_4<M>(M: Chain_5<M>): <A, _>(f: (a: A) => HKT<M, _>) => (first: HKT<M, A>) => HKT<M, A>;

// @public
const chainFirst_5: <A, B>(f: (a: A) => Option_2<B>) => (first: Option_2<A>) => Option_2<A>;

// @public
const chainFirst_6: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Either<E, A>) => Either<E, A>;

// @public
const chainFirst_7: <A, B>(f: (a: A) => B) => (first: A) => A;

// @public
const chainFirst_8: <A, B>(f: (a: A) => IO<B>) => (first: IO<A>) => IO<A>;

// @public
const chainFirst_9: <E, A, B>(f: (a: A) => IOEither<E, B>) => (ma: IOEither<E, A>) => IOEither<E, A>;

// @public
const chainFirstEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Option_2<A>) => Option_2<A>;

// @public (undocumented)
function chainFirstEitherK_2<M extends URIS4>(F: FromEither4<M>, M: Chain4<M>): <A, E, B>(f: (a: A) => Either<E, B>) => <S, R>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>;

// @public (undocumented)
function chainFirstEitherK_2<M extends URIS3>(F: FromEither3<M>, M: Chain3<M>): <A, E, B>(f: (a: A) => Either<E, B>) => <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>;

// @public (undocumented)
function chainFirstEitherK_2<M extends URIS3, E>(F: FromEither3C<M, E>, M: Chain3C<M, E>): <A, B>(f: (a: A) => Either<E, B>) => <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>;

// @public (undocumented)
function chainFirstEitherK_2<M extends URIS2>(F: FromEither2<M>, M: Chain2<M>): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, A>;

// @public (undocumented)
function chainFirstEitherK_2<M extends URIS2, E>(F: FromEither2C<M, E>, M: Chain2C<M, E>): <A, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, A>;

// @public (undocumented)
function chainFirstEitherK_2<M extends URIS>(F: FromEither1<M>, M: Chain1<M>): <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Kind<M, A>) => Kind<M, A>;

// @public (undocumented)
function chainFirstEitherK_2<M>(F: FromEither_4<M>, M: Chain_5<M>): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: HKT2<M, E, A>) => HKT2<M, E, A>;

// @public
const chainFirstEitherK_3: <A, E, B>(f: (a: A) => either.Either<E, B>) => (ma: IOEither<E, A>) => IOEither<E, A>;

// @public
const chainFirstEitherK_4: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: IOOption<A>) => IOOption<A>;

// @public
const chainFirstEitherK_5: <A, E, B>(f: (a: A) => either.Either<E, B>) => <R>(ma: ReaderEither<R, E, A>) => ReaderEither<R, E, A>;

// @public
const chainFirstEitherK_6: <A, E, B>(f: (a: A) => either.Either<E, B>) => (ma: TaskEither<E, A>) => TaskEither<E, A>;

// @public
const chainFirstEitherK_7: <A, E, B>(f: (a: A) => either.Either<E, B>) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;

// @public
const chainFirstEitherK_8: <A, E, B>(f: (a: A) => either.Either<E, B>) => <S, R>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>;

// @public
const chainFirstEitherK_9: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: TaskOption<A>) => TaskOption<A>;

// @public
const chainFirstEitherKW: <A, E2, B>(f: (a: A) => either.Either<E2, B>) => <E1>(ma: IOEither<E1, A>) => IOEither<E1 | E2, A>;

// @public
const chainFirstEitherKW_2: <A, E2, B>(f: (a: A) => Either<E2, B>) => <R, E1>(ma: ReaderEither<R, E1, A>) => ReaderEither<R, E1 | E2, A>;

// @public
const chainFirstEitherKW_3: <A, E2, B>(f: (a: A) => either.Either<E2, B>) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, A>;

// @public
const chainFirstEitherKW_4: <A, E2, B>(f: (a: A) => Either<E2, B>) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, A>;

// @public
const chainFirstEitherKW_5: <A, E2, B>(f: (a: A) => Either<E2, B>) => <S, R, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, A>;

// @public (undocumented)
function chainFirstIOK<M extends URIS4>(F: FromIO4<M>, M: Chain4<M>): <A, B>(f: (a: A) => IO<B>) => <S, R, E>(first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>;

// @public (undocumented)
function chainFirstIOK<M extends URIS3>(F: FromIO3<M>, M: Chain3<M>): <A, B>(f: (a: A) => IO<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>;

// @public (undocumented)
function chainFirstIOK<M extends URIS3, E>(F: FromIO3C<M, E>, M: Chain3C<M, E>): <A, B>(f: (a: A) => IO<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>;

// @public (undocumented)
function chainFirstIOK<M extends URIS2>(F: FromIO2<M>, M: Chain2<M>): <A, B>(f: (a: A) => IO<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, A>;

// @public (undocumented)
function chainFirstIOK<M extends URIS2, E>(F: FromIO2C<M, E>, M: Chain2C<M, E>): <A, B>(f: (a: A) => IO<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, A>;

// @public (undocumented)
function chainFirstIOK<M extends URIS>(F: FromIO1<M>, M: Chain1<M>): <A, B>(f: (a: A) => IO<B>) => (first: Kind<M, A>) => Kind<M, A>;

// @public (undocumented)
function chainFirstIOK<M>(F: FromIO<M>, M: Chain_5<M>): <A, B>(f: (a: A) => IO<B>) => (first: HKT<M, A>) => HKT<M, A>;

// @public
const chainFirstIOK_10: <A, B>(f: (a: A) => IO<B>) => (first: TaskOption<A>) => TaskOption<A>;

// @public
const chainFirstIOK_2: <A, B>(f: (a: A) => io.IO<B>) => <E>(first: IOEither<E, A>) => IOEither<E, A>;

// @public
const chainFirstIOK_3: <A, B>(f: (a: A) => io.IO<B>) => (first: IOOption<A>) => IOOption<A>;

// @public
const chainFirstIOK_4: <A, B>(f: (a: A) => io.IO<B>) => <E>(first: ReaderIO<E, A>) => ReaderIO<E, A>;

// @public
const chainFirstIOK_5: <A, B>(f: (a: A) => IO<B>) => <R>(first: ReaderTask<R, A>) => ReaderTask<R, A>;

// @public
const chainFirstIOK_6: <A, B>(f: (a: A) => IO<B>) => (first: Task<A>) => Task<A>;

// @public
const chainFirstIOK_7: <A, B>(f: (a: A) => IO<B>) => <E>(first: TaskEither<E, A>) => TaskEither<E, A>;

// @public
const chainFirstIOK_8: <A, B>(f: (a: A) => IO<B>) => <R, E>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;

// @public
const chainFirstIOK_9: <A, B>(f: (a: A) => IO<B>) => <S, R, E>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>;

// @public
const chainFirstReaderEitherK: <R, E, A, B>(f: (a: A) => ReaderEither<R, E, B>) => (ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;

// @public
const chainFirstReaderEitherKW: <R2, E2, A, B>(f: (a: A) => ReaderEither<R2, E2, B>) => <R1, E1>(ma: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, A>;

// @public
const chainFirstReaderIOK: <A, R, B>(f: (a: A) => ReaderIO<R, B>) => (ma: ReaderTask<R, A>) => ReaderTask<R, A>;

// @public
const chainFirstReaderIOK_2: <A, R, B>(f: (a: A) => ReaderIO<R, B>) => <E>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;

// @public
const chainFirstReaderIOKW: <A, R2, B>(f: (a: A) => ReaderIO<R2, B>) => <R1>(ma: ReaderTask<R1, A>) => ReaderTask<R1 & R2, A>;

// @public
const chainFirstReaderIOKW_2: <A, R2, B>(f: (a: A) => ReaderIO<R2, B>) => <R1, E>(ma: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, A>;

// @public (undocumented)
function chainFirstReaderK<M extends URIS4>(F: FromReader4<M>, M: Chain4<M>): <A, R, B>(f: (a: A) => Reader<R, B>) => <S, E>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>;

// @public (undocumented)
function chainFirstReaderK<M extends URIS3>(F: FromReader3<M>, M: Chain3<M>): <A, R, B>(f: (a: A) => Reader<R, B>) => <E>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>;

// @public (undocumented)
function chainFirstReaderK<M extends URIS3, E>(F: FromReader3C<M, E>, M: Chain3C<M, E>): <A, R, B>(f: (a: A) => Reader<R, B>) => (ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>;

// @public (undocumented)
function chainFirstReaderK<M extends URIS2>(F: FromReader2<M>, M: Chain2<M>): <A, R, B>(f: (a: A) => Reader<R, B>) => (ma: Kind2<M, R, A>) => Kind2<M, R, A>;

// @public (undocumented)
function chainFirstReaderK<M>(F: FromReader<M>, M: Chain_5<M>): <A, R, B>(f: (a: A) => Reader<R, B>) => (ma: HKT2<M, R, A>) => HKT2<M, R, A>;

// @public
const chainFirstReaderK_2: <A, R, B>(f: (a: A) => Reader<R, B>) => <E>(ma: ReaderEither<R, E, A>) => ReaderEither<R, E, A>;

// @public
const chainFirstReaderK_3: <A, R, B>(f: (a: A) => reader.Reader<R, B>) => (ma: ReaderIO<R, A>) => ReaderIO<R, A>;

// @public
const chainFirstReaderK_4: <A, R, B>(f: (a: A) => reader.Reader<R, B>) => (ma: ReaderTask<R, A>) => ReaderTask<R, A>;

// @public
const chainFirstReaderK_5: <A, R, B>(f: (a: A) => reader.Reader<R, B>) => <E>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;

// @public
const chainFirstReaderK_6: <A, R, B>(f: (a: A) => Reader<R, B>) => <S, E>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>;

// @public
const chainFirstReaderKW: <A, R1, B>(f: (a: A) => Reader<R1, B>) => <R2, E>(ma: ReaderEither<R2, E, A>) => ReaderEither<R1 & R2, E, A>;

// @public
const chainFirstReaderKW_2: <A, R1, B>(f: (a: A) => reader.Reader<R1, B>) => <R2>(ma: ReaderIO<R2, A>) => ReaderIO<R1 & R2, A>;

// @public
const chainFirstReaderKW_3: <A, R1, B>(f: (a: A) => reader.Reader<R1, B>) => <R2>(ma: ReaderTask<R2, A>) => ReaderTask<R1 & R2, A>;

// @public
const chainFirstReaderKW_4: <A, R1, B>(f: (a: A) => reader.Reader<R1, B>) => <R2, E>(ma: ReaderTaskEither<R2, E, A>) => ReaderTaskEither<R1 & R2, E, A>;

// @public
const chainFirstReaderKW_5: <A, R1, B>(f: (a: A) => Reader<R1, B>) => <S, R2, E>(ma: StateReaderTaskEither<S, R2, E, A>) => StateReaderTaskEither<S, R1 & R2, E, A>;

// @public
const chainFirstReaderTaskK: <A, R, B>(f: (a: A) => readerTask.ReaderTask<R, B>) => <E>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;

// @public
const chainFirstReaderTaskKW: <A, R2, B>(f: (a: A) => readerTask.ReaderTask<R2, B>) => <R1, E>(ma: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, A>;

// @public
const chainFirstTaskEitherK: <E, A, B>(f: (a: A) => TaskEither<E, B>) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;

// @public
const chainFirstTaskEitherKW: <E2, A, B>(f: (a: A) => TaskEither<E2, B>) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, A>;

// @public (undocumented)
function chainFirstTaskK<M extends URIS4>(F: FromTask4<M>, M: Chain4<M>): <A, B>(f: (a: A) => Task<B>) => <S, R, E>(first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>;

// @public (undocumented)
function chainFirstTaskK<M extends URIS3>(F: FromTask3<M>, M: Chain3<M>): <A, B>(f: (a: A) => Task<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>;

// @public (undocumented)
function chainFirstTaskK<M extends URIS3, E>(F: FromTask3C<M, E>, M: Chain3C<M, E>): <A, B>(f: (a: A) => Task<B>) => <R>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>;

// @public (undocumented)
function chainFirstTaskK<M extends URIS2>(F: FromTask2<M>, M: Chain2<M>): <A, B>(f: (a: A) => Task<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, A>;

// @public (undocumented)
function chainFirstTaskK<M extends URIS2, E>(F: FromTask2C<M, E>, M: Chain2C<M, E>): <A, B>(f: (a: A) => Task<B>) => (first: Kind2<M, E, A>) => Kind2<M, E, A>;

// @public (undocumented)
function chainFirstTaskK<M extends URIS>(F: FromTask1<M>, M: Chain1<M>): <A, B>(f: (a: A) => Task<B>) => (first: Kind<M, A>) => Kind<M, A>;

// @public (undocumented)
function chainFirstTaskK<M>(F: FromTask<M>, M: Chain_5<M>): <A, B>(f: (a: A) => Task<B>) => (first: HKT<M, A>) => HKT<M, A>;

// @public
const chainFirstTaskK_2: <A, B>(f: (a: A) => task.Task<B>) => <R>(first: ReaderTask<R, A>) => ReaderTask<R, A>;

// @public
const chainFirstTaskK_3: <A, B>(f: (a: A) => task.Task<B>) => <E>(first: TaskEither<E, A>) => TaskEither<E, A>;

// @public
const chainFirstTaskK_4: <A, B>(f: (a: A) => task.Task<B>) => <R, E>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;

// @public
const chainFirstTaskK_5: <A, B>(f: (a: A) => Task<B>) => <S, R, E>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>;

// @public
const chainFirstTaskK_6: <A, B>(f: (a: A) => task.Task<B>) => (first: TaskOption<A>) => TaskOption<A>;

// @public
const chainFirstW: <E2, A, B>(f: (a: A) => Either<E2, B>) => <E1>(ma: Either<E1, A>) => Either<E1 | E2, A>;

// @public
const chainFirstW_2: <E2, A, B>(f: (a: A) => IOEither<E2, B>) => <E1>(ma: IOEither<E1, A>) => IOEither<E1 | E2, A>;

// @public
const chainFirstW_3: <R2, A, B>(f: (a: A) => Reader<R2, B>) => <R1>(ma: Reader<R1, A>) => Reader<R1 & R2, A>;

// @public
const chainFirstW_4: <R2, E2, A, B>(f: (a: A) => ReaderEither<R2, E2, B>) => <R1, E1>(ma: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E1 | E2, A>;

// @public
const chainFirstW_5: <A, R2, B>(f: (a: A) => ReaderIO<R2, B>) => <R1>(ma: ReaderIO<R1, A>) => ReaderIO<R1 & R2, A>;

// @public
const chainFirstW_6: <R2, A, B>(f: (a: A) => ReaderTask<R2, B>) => <R1>(ma: ReaderTask<R1, A>) => ReaderTask<R1 & R2, A>;

// @public
const chainFirstW_7: <E2, A, B>(f: (a: A) => TaskEither<E2, B>) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, A>;

// @public
const chainFirstW_8: <R2, E2, A, B>(f: (a: A) => ReaderTaskEither<R2, E2, B>) => <R1, E1>(ma: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, A>;

// @public
const chainFirstW_9: <S, R2, E2, A, B>(f: (a: A) => StateReaderTaskEither<S, R2, E2, B>) => <R1, E1>(ma: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E1 | E2, A>;

// @public
const chainIOEitherK: <E, A, B>(f: (a: A) => IOEither<E, B>) => (ma: TaskEither<E, A>) => TaskEither<E, B>;

// @public
const chainIOEitherK_2: <E, A, B>(f: (a: A) => IOEither<E, B>) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;

// @public
const chainIOEitherK_3: <E, A, B>(f: (a: A) => IOEither<E, B>) => <S, R>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;

// @public
const chainIOEitherKW: <E2, A, B>(f: (a: A) => IOEither<E2, B>) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, B>;

// @public
const chainIOEitherKW_2: <E2, A, B>(f: (a: A) => IOEither<E2, B>) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, B>;

// @public
const chainIOEitherKW_3: <E2, A, B>(f: (a: A) => IOEither<E2, B>) => <S, R, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, B>;

// @public (undocumented)
function chainIOK<M extends URIS4>(F: FromIO4<M>, M: Chain4<M>): <A, B>(f: (a: A) => IO<B>) => <S, R, E>(first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>;

// @public (undocumented)
function chainIOK<M extends URIS3>(F: FromIO3<M>, M: Chain3<M>): <A, B>(f: (a: A) => IO<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, B>;

// @public (undocumented)
function chainIOK<M extends URIS3, E>(F: FromIO3C<M, E>, M: Chain3C<M, E>): <A, B>(f: (a: A) => IO<B>) => <R>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, B>;

// @public (undocumented)
function chainIOK<M extends URIS2>(F: FromIO2<M>, M: Chain2<M>): <A, B>(f: (a: A) => IO<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, B>;

// @public (undocumented)
function chainIOK<M extends URIS2, E>(F: FromIO2C<M, E>, M: Chain2C<M, E>): <A, B>(f: (a: A) => IO<B>) => (first: Kind2<M, E, A>) => Kind2<M, E, B>;

// @public (undocumented)
function chainIOK<M extends URIS>(F: FromIO1<M>, M: Chain1<M>): <A, B>(f: (a: A) => IO<B>) => (first: Kind<M, A>) => Kind<M, B>;

// @public (undocumented)
function chainIOK<M>(F: FromIO<M>, M: Chain_5<M>): <A, B>(f: (a: A) => IO<B>) => (first: HKT<M, A>) => HKT<M, B>;

// @public
const chainIOK_10: <A, B>(f: (a: A) => IO<B>) => (first: TaskOption<A>) => TaskOption<B>;

// @public
const chainIOK_2: <A, B>(f: (a: A) => io.IO<B>) => <E>(first: IOEither<E, A>) => IOEither<E, B>;

// @public
const chainIOK_3: <A, B>(f: (a: A) => io.IO<B>) => (first: IOOption<A>) => IOOption<B>;

// @public
const chainIOK_4: <A, B>(f: (a: A) => io.IO<B>) => <E>(first: ReaderIO<E, A>) => ReaderIO<E, B>;

// @public
const chainIOK_5: <A, B>(f: (a: A) => IO<B>) => <R>(first: ReaderTask<R, A>) => ReaderTask<R, B>;

// @public
const chainIOK_6: <A, B>(f: (a: A) => IO<B>) => (first: Task<A>) => Task<B>;

// @public
const chainIOK_7: <A, B>(f: (a: A) => IO<B>) => <E>(first: TaskEither<E, A>) => TaskEither<E, B>;

// @public
const chainIOK_8: <A, B>(f: (a: A) => IO<B>) => <R, E>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;

// @public
const chainIOK_9: <A, B>(f: (a: A) => IO<B>) => <S, R, E>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;

// @public
const chainNullableK: <A, B>(f: (a: A) => B | null | undefined) => (ma: Option_2<A>) => Option_2<NonNullable<B>>;

// @public
const chainNullableK_2: <E>(e: E) => <A, B>(f: (a: A) => B | null | undefined) => (ma: Either<E, A>) => Either<E, NonNullable<B>>;

// @public (undocumented)
function chainNullableK_3<M extends URIS3>(M: Monad3<M>): <E>(e: E) => <A, B>(f: (a: A) => B | null | undefined) => <S, R>(ma: Kind3<M, S, R, Either<E, A>>) => Kind3<M, S, R, Either<E, NonNullable<B>>>;

// @public (undocumented)
function chainNullableK_3<M extends URIS3, R>(M: Monad3C<M, R>): <E>(e: E) => <A, B>(f: (a: A) => B | null | undefined) => <S>(ma: Kind3<M, S, R, Either<E, A>>) => Kind3<M, S, R, Either<E, NonNullable<B>>>;

// @public (undocumented)
function chainNullableK_3<M extends URIS2>(M: Monad2<M>): <E>(e: E) => <A, B>(f: (a: A) => B | null | undefined) => <R>(ma: Kind2<M, R, Either<E, A>>) => Kind2<M, R, Either<E, NonNullable<B>>>;

// @public (undocumented)
function chainNullableK_3<M extends URIS2, T>(M: Monad2C<M, T>): <E>(e: E) => <A, B>(f: (a: A) => B | null | undefined) => (ma: Kind2<M, T, Either<E, A>>) => Kind2<M, T, Either<E, NonNullable<B>>>;

// @public (undocumented)
function chainNullableK_3<M extends URIS>(M: Monad1<M>): <E>(e: E) => <A, B>(f: (a: A) => B | null | undefined) => (ma: Kind<M, Either<E, A>>) => Kind<M, Either<E, NonNullable<B>>>;

// @public (undocumented)
function chainNullableK_3<M>(M: Monad_6<M>): <E>(e: E) => <A, B>(f: (a: A) => B | null | undefined) => (ma: HKT<M, Either<E, A>>) => HKT<M, Either<E, NonNullable<B>>>;

// @public
const chainNullableK_4: <A, B>(f: (a: A) => B | null | undefined) => (ma: IOOption<A>) => IOOption<NonNullable<B>>;

// @public (undocumented)
function chainNullableK_5<M extends URIS4>(M: Monad4<M>): <A, B>(f: (a: A) => B | null | undefined) => <S, R, E>(ma: Kind4<M, S, R, E, Option_2<A>>) => Kind4<M, S, R, E, Option_2<NonNullable<B>>>;

// @public (undocumented)
function chainNullableK_5<M extends URIS3>(M: Monad3<M>): <A, B>(f: (a: A) => B | null | undefined) => <R, E>(ma: Kind3<M, R, E, Option_2<A>>) => Kind3<M, R, E, Option_2<NonNullable<B>>>;

// @public (undocumented)
function chainNullableK_5<M extends URIS3, E>(M: Monad3C<M, E>): <A, B>(f: (a: A) => B | null | undefined) => <R>(ma: Kind3<M, R, E, Option_2<A>>) => Kind3<M, R, E, Option_2<NonNullable<B>>>;

// @public (undocumented)
function chainNullableK_5<M extends URIS2>(M: Monad2<M>): <A, B>(f: (a: A) => B | null | undefined) => <E>(ma: Kind2<M, E, Option_2<A>>) => Kind2<M, E, Option_2<NonNullable<B>>>;

// @public (undocumented)
function chainNullableK_5<M extends URIS2, E>(M: Monad2C<M, E>): <A, B>(f: (a: A) => B | null | undefined) => (ma: Kind2<M, E, Option_2<A>>) => Kind2<M, E, Option_2<NonNullable<B>>>;

// @public (undocumented)
function chainNullableK_5<M extends URIS>(M: Monad1<M>): <A, B>(f: (a: A) => B | null | undefined) => (ma: Kind<M, Option_2<A>>) => Kind<M, Option_2<NonNullable<B>>>;

// @public (undocumented)
function chainNullableK_5<M>(M: Monad_6<M>): <A, B>(f: (a: A) => B | null | undefined) => (ma: HKT<M, Option_2<A>>) => HKT<M, Option_2<NonNullable<B>>>;

// @public
const chainNullableK_6: <E>(e: E) => <A, B>(f: (a: A) => B | null | undefined) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, NonNullable<B>>;

// @public
const chainNullableK_7: <E>(e: E) => <A, B>(f: (a: A) => B | null | undefined) => (ma: TaskEither<E, A>) => TaskEither<E, NonNullable<B>>;

// @public (undocumented)
const chainNullableK_8: <A, B>(f: (a: A) => B | null | undefined) => (ma: TaskOption<A>) => TaskOption<NonNullable<B>>;

// @public
const chainOptionK: <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option_2<B>) => (ma: Either<E, A>) => Either<E, B>;

// @public (undocumented)
const chainOptionK_10: <A, B>(f: (a: A) => Option_2<B>) => (ma: TaskOption<A>) => TaskOption<B>;

// @public (undocumented)
function chainOptionK_2<F extends URIS4>(F: FromEither4<F>, M: Chain4<F>): <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option_2<B>) => <S, R>(ma: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function chainOptionK_2<F extends URIS3>(F: FromEither3<F>, M: Chain3<F>): <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option_2<B>) => <R>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function chainOptionK_2<F extends URIS3, E>(F: FromEither3C<F, E>, M: Chain3C<F, E>): (onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option_2<B>) => <R>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function chainOptionK_2<F extends URIS2>(F: FromEither2<F>, M: Chain2<F>): <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option_2<B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function chainOptionK_2<F extends URIS2, E>(F: FromEither2C<F, E>, M: Chain2C<F, E>): (onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option_2<B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function chainOptionK_2<F>(F: FromEither_4<F>, M: Chain_5<F>): <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option_2<B>) => (ma: HKT2<F, E, A>) => HKT2<F, E, B>;

// @public
const chainOptionK_3: <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option_2<B>) => (ma: IOEither<E, A>) => IOEither<E, B>;

// @public
const chainOptionK_4: <A, B>(f: (a: A) => Option_2<B>) => (ma: IOOption<A>) => IOOption<B>;

// @public (undocumented)
function chainOptionK_5<M extends URIS4>(M: Monad4<M>): <A, B>(f: (a: A) => Option_2<B>) => <S, R, E>(ma: Kind4<M, S, R, E, Option_2<A>>) => Kind4<M, S, R, E, Option_2<B>>;

// @public (undocumented)
function chainOptionK_5<M extends URIS3>(M: Monad3<M>): <A, B>(f: (a: A) => Option_2<B>) => <R, E>(ma: Kind3<M, R, E, Option_2<A>>) => Kind3<M, R, E, Option_2<B>>;

// @public (undocumented)
function chainOptionK_5<M extends URIS3, E>(M: Monad3C<M, E>): <A, B>(f: (a: A) => Option_2<B>) => <R>(ma: Kind3<M, R, E, Option_2<A>>) => Kind3<M, R, E, Option_2<B>>;

// @public (undocumented)
function chainOptionK_5<M extends URIS2>(M: Monad2<M>): <A, B>(f: (a: A) => Option_2<B>) => <E>(ma: Kind2<M, E, Option_2<A>>) => Kind2<M, E, Option_2<B>>;

// @public (undocumented)
function chainOptionK_5<M extends URIS2, E>(M: Monad2C<M, E>): <A, B>(f: (a: A) => Option_2<B>) => (ma: Kind2<M, E, Option_2<A>>) => Kind2<M, E, Option_2<B>>;

// @public (undocumented)
function chainOptionK_5<M extends URIS>(M: Monad1<M>): <A, B>(f: (a: A) => Option_2<B>) => (ma: Kind<M, Option_2<A>>) => Kind<M, Option_2<B>>;

// @public (undocumented)
function chainOptionK_5<M>(M: Monad_6<M>): <A, B>(f: (a: A) => Option_2<B>) => (ma: HKT<M, Option_2<A>>) => HKT<M, Option_2<B>>;

// @public
const chainOptionK_6: <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option_2<B>) => <R>(ma: ReaderEither<R, E, A>) => ReaderEither<R, E, B>;

// @public
const chainOptionK_7: <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option_2<B>) => (ma: TaskEither<E, A>) => TaskEither<E, B>;

// @public
const chainOptionK_8: <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option_2<B>) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;

// @public
const chainOptionK_9: <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option_2<B>) => <S, R>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;

// @public
const chainOptionKW: <E2>(onNone: LazyArg<E2>) => <A, B>(f: (a: A) => Option_2<B>) => <E1>(ma: Either<E1, A>) => Either<E1 | E2, B>;

// @public
const chainOptionKW_2: <E2>(onNone: LazyArg<E2>) => <A, B>(f: (a: A) => Option_2<B>) => <E1>(ma: IOEither<E1, A>) => IOEither<E1 | E2, B>;

// @public
const chainOptionKW_3: <E2>(onNone: LazyArg<E2>) => <A, B>(f: (a: A) => Option_2<B>) => <R, E1>(ma: ReaderEither<R, E1, A>) => ReaderEither<R, E1 | E2, B>;

// @public
const chainOptionKW_4: <E2>(onNone: LazyArg<E2>) => <A, B>(f: (a: A) => Option_2<B>) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, B>;

// @public
const chainOptionKW_5: <E2>(onNone: LazyArg<E2>) => <A, B>(f: (a: A) => Option_2<B>) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, B>;

// @public
const chainOptionKW_6: <E2>(onNone: LazyArg<E2>) => <A, B>(f: (a: A) => Option_2<B>) => <S, R, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, B>;

// @public
const chainReaderEitherK: <R, E, A, B>(f: (a: A) => ReaderEither<R, E, B>) => (ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;

// @public
const chainReaderEitherKW: <R2, E2, A, B>(f: (a: A) => ReaderEither<R2, E2, B>) => <R1, E1>(ma: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, B>;

// @public
const chainReaderIOK: <A, R, B>(f: (a: A) => ReaderIO<R, B>) => (ma: ReaderTask<R, A>) => ReaderTask<R, B>;

// @public
const chainReaderIOK_2: <A, R, B>(f: (a: A) => ReaderIO<R, B>) => <E>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;

// @public
const chainReaderIOKW: <A, R2, B>(f: (a: A) => ReaderIO<R2, B>) => <R1>(ma: ReaderTask<R1, A>) => ReaderTask<R1 & R2, B>;

// @public
const chainReaderIOKW_2: <A, R2, B>(f: (a: A) => ReaderIO<R2, B>) => <R1, E>(ma: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, B>;

// @public (undocumented)
function chainReaderK<M extends URIS4>(F: FromReader4<M>, M: Chain4<M>): <A, R, B>(f: (a: A) => Reader<R, B>) => <S, E>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>;

// @public (undocumented)
function chainReaderK<M extends URIS3>(F: FromReader3<M>, M: Chain3<M>): <A, R, B>(f: (a: A) => Reader<R, B>) => <E>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>;

// @public (undocumented)
function chainReaderK<M extends URIS3, E>(F: FromReader3C<M, E>, M: Chain3C<M, E>): <A, R, B>(f: (a: A) => Reader<R, B>) => (ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>;

// @public (undocumented)
function chainReaderK<M extends URIS2>(F: FromReader2<M>, M: Chain2<M>): <A, R, B>(f: (a: A) => Reader<R, B>) => (ma: Kind2<M, R, A>) => Kind2<M, R, B>;

// @public (undocumented)
function chainReaderK<M>(F: FromReader<M>, M: Chain_5<M>): <A, R, B>(f: (a: A) => Reader<R, B>) => (ma: HKT2<M, R, A>) => HKT2<M, R, B>;

// @public
const chainReaderK_2: <A, R, B>(f: (a: A) => Reader<R, B>) => <E>(ma: ReaderEither<R, E, A>) => ReaderEither<R, E, B>;

// @public
const chainReaderK_3: <A, R, B>(f: (a: A) => reader.Reader<R, B>) => (ma: ReaderIO<R, A>) => ReaderIO<R, B>;

// @public
const chainReaderK_4: <A, R, B>(f: (a: A) => reader.Reader<R, B>) => (ma: ReaderTask<R, A>) => ReaderTask<R, B>;

// @public
const chainReaderK_5: <A, R, B>(f: (a: A) => Reader<R, B>) => <E>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;

// @public
const chainReaderK_6: <A, R, B>(f: (a: A) => Reader<R, B>) => <S, E>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;

// @public
const chainReaderKW: <A, R2, B>(f: (a: A) => Reader<R2, B>) => <R1, E>(ma: ReaderEither<R1, E, A>) => ReaderEither<R1 & R2, E, B>;

// @public
const chainReaderKW_2: <A, R1, B>(f: (a: A) => reader.Reader<R1, B>) => <R2>(ma: ReaderIO<R2, A>) => ReaderIO<R1 & R2, B>;

// @public
const chainReaderKW_3: <A, R1, B>(f: (a: A) => reader.Reader<R1, B>) => <R2>(ma: ReaderTask<R2, A>) => ReaderTask<R1 & R2, B>;

// @public
const chainReaderKW_4: <A, R1, B>(f: (a: A) => reader.Reader<R1, B>) => <R2, E>(ma: ReaderTaskEither<R2, E, A>) => ReaderTaskEither<R1 & R2, E, B>;

// @public
const chainReaderKW_5: <A, R1, B>(f: (a: A) => Reader<R1, B>) => <S, R2, E>(ma: StateReaderTaskEither<S, R2, E, A>) => StateReaderTaskEither<S, R1 & R2, E, B>;

// @public
const chainReaderTaskEitherK: <R, E, A, B>(f: (a: A) => ReaderTaskEither<R, E, B>) => <S>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;

// @public
const chainReaderTaskEitherKW: <R, E2, A, B>(f: (a: A) => readerTaskEither.ReaderTaskEither<R, E2, B>) => <S, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E2 | E1, B>;

// @public
const chainReaderTaskK: <A, R, B>(f: (a: A) => readerTask.ReaderTask<R, B>) => <E>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;

// @public
const chainReaderTaskKW: <A, R2, B>(f: (a: A) => readerTask.ReaderTask<R2, B>) => <R1, E>(ma: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, B>;

// @public
const ChainRec: ChainRec1<URI_7>;

declare namespace chainRec {
    export {
        forever,
        whileSome,
        untilSome,
        chainRec2,
        chainRec3,
        ChainRec_2 as ChainRec,
        ChainRec1,
        ChainRec2,
        ChainRec2C,
        ChainRec3,
        ChainRec3C,
        ChainRec4,
        tailRec,
        tailRec2,
        tailRec3,
        do__2 as do,
        KindGenerator2
    }
}
export { chainRec }

// @public (undocumented)
interface ChainRec1<F extends URIS> extends Chain1<F> {
    // (undocumented)
    readonly chainRec: <A, B>(a: A, f: (a: A) => Kind<F, either.Either<A, B>>) => Kind<F, B>;
}

// @public (undocumented)
interface ChainRec2<F extends URIS2> extends Chain2<F> {
    // (undocumented)
    readonly chainRec: <E, A, B>(a: A, f: (a: A) => Kind2<F, E, either.Either<A, B>>) => Kind2<F, E, B>;
}

// @public (undocumented)
function chainRec2<M extends URIS4>(M: ChainRec4<M>): <S, R, E, A, B, C>(a: A, b: B, f: (a: A, b: B) => Kind4<M, S, R, E, either.Either<[A, B], C>>) => Kind4<M, S, R, E, C>;

// @public (undocumented)
function chainRec2<M extends URIS3>(M: ChainRec3<M>): <R, E, A, B, C>(a: A, b: B, f: (a: A, b: B) => Kind3<M, R, E, either.Either<[A, B], C>>) => Kind3<M, R, E, C>;

// @public (undocumented)
function chainRec2<M extends URIS3, E>(M: ChainRec3C<M, E>): <R, A, B, C>(a: A, b: B, f: (a: A, b: B) => Kind3<M, R, E, either.Either<[A, B], C>>) => Kind3<M, R, E, C>;

// @public (undocumented)
function chainRec2<M extends URIS2>(M: ChainRec2<M>): <E, A, B, C>(a: A, b: B, f: (a: A, b: B) => Kind2<M, E, either.Either<[A, B], C>>) => Kind2<M, E, C>;

// @public (undocumented)
function chainRec2<M extends URIS2, E>(M: ChainRec2C<M, E>): <A, B, C>(a: A, b: B, f: (a: A, b: B) => Kind2<M, E, either.Either<[A, B], C>>) => Kind2<M, E, C>;

// @public (undocumented)
function chainRec2<M extends URIS>(M: ChainRec1<M>): <A, B, C>(a: A, b: B, f: (a: A, b: B) => Kind<M, either.Either<[A, B], C>>) => Kind<M, C>;

// @public (undocumented)
interface ChainRec2C<F extends URIS2, E> extends Chain2C<F, E> {
    // (undocumented)
    readonly chainRec: <A, B>(a: A, f: (a: A) => Kind2<F, E, either.Either<A, B>>) => Kind2<F, E, B>;
}

// @public (undocumented)
interface ChainRec3<F extends URIS3> extends Chain3<F> {
    // (undocumented)
    readonly chainRec: <R, E, A, B>(a: A, f: (a: A) => Kind3<F, R, E, either.Either<A, B>>) => Kind3<F, R, E, B>;
}

// @public (undocumented)
function chainRec3<M extends URIS4>(M: ChainRec4<M>): <S, R, E, A, B, C, D>(a: A, b: B, c: C, f: (a: A, b: B, c: C) => Kind4<M, S, R, E, either.Either<[A, B, C], D>>) => Kind4<M, S, R, E, D>;

// @public (undocumented)
function chainRec3<M extends URIS3>(M: ChainRec3<M>): <R, E, A, B, C, D>(a: A, b: B, c: C, f: (a: A, b: B, c: C) => Kind3<M, R, E, either.Either<[A, B, C], D>>) => Kind3<M, R, E, D>;

// @public (undocumented)
function chainRec3<M extends URIS3, E>(M: ChainRec3C<M, E>): <R, A, B, C, D>(a: A, b: B, c: C, f: (a: A, b: B, c: C) => Kind3<M, R, E, either.Either<[A, B, C], D>>) => Kind3<M, R, E, D>;

// @public (undocumented)
function chainRec3<M extends URIS2>(M: ChainRec2<M>): <E, A, B, C, D>(a: A, b: B, c: C, f: (a: A, b: B, c: C) => Kind2<M, E, either.Either<[A, B, C], D>>) => Kind2<M, E, D>;

// @public (undocumented)
function chainRec3<M extends URIS2, E>(M: ChainRec2C<M, E>): <A, B, C, D>(a: A, b: B, c: C, f: (a: A, b: B, c: C) => Kind2<M, E, either.Either<[A, B, C], D>>) => Kind2<M, E, D>;

// @public (undocumented)
function chainRec3<M extends URIS>(M: ChainRec1<M>): <A, B, C, D>(a: A, b: B, c: C, f: (a: A, b: B, c: C) => Kind<M, either.Either<[A, B, C], D>>) => Kind<M, D>;

// @public (undocumented)
interface ChainRec3C<F extends URIS3, E> extends Chain3C<F, E> {
    // (undocumented)
    readonly chainRec: <R, A, B>(a: A, f: (a: A) => Kind3<F, R, E, either.Either<A, B>>) => Kind3<F, R, E, B>;
}

// @public (undocumented)
interface ChainRec4<F extends URIS4> extends Chain4<F> {
    // (undocumented)
    readonly chainRec: <S, R, E, A, B>(a: A, f: (a: A) => Kind4<F, S, R, E, either.Either<A, B>>) => Kind4<F, S, R, E, B>;
}

// @public
const ChainRec_10: ChainRec2<URI_19>;

// @public (undocumented)
const chainRec_10: ChainRec2<URI_20>['chainRec'];

// @public
const ChainRec_11: ChainRec2<URI_20>;

// @public (undocumented)
const chainRec_11: ChainRec1<URI_21>['chainRec'];

// @public
const ChainRec_12: ChainRec1<URI_21>;

// @public (undocumented)
const chainRec_12: ChainRec2<URI_23>['chainRec'];

// @public
const ChainRec_13: ChainRec2<URI_23>;

// @public (undocumented)
const chainRec_13: ChainRec3<URI_22>['chainRec'];

// @public
const ChainRec_14: ChainRec3<URI_22>;

// @public (undocumented)
const chainRec_14: ChainRec2<URI_30>['chainRec'];

// @public
const ChainRec_15: ChainRec2<URI_30>;

// @public (undocumented)
const chainRec_15: ChainRec4<URI_31>['chainRec'];

// @public
const ChainRec_16: ChainRec4<URI_31>;

// @public (undocumented)
const chainRec_16: ChainRec1<URI_33>['chainRec'];

// @public
const ChainRec_17: ChainRec1<URI_33>;

// @public (undocumented)
interface ChainRec_2<F> extends Chain_5<F> {
    // (undocumented)
    readonly chainRec: <A, B>(a: A, f: (a: A) => HKT<F, either.Either<A, B>>) => HKT<F, B>;
}

// @public (undocumented)
const chainRec_2: ChainRec1<URI_7>['chainRec'];

// @public (undocumented)
const ChainRec_3: chainRec.ChainRec2<URI_6>;

// @public (undocumented)
const chainRec_3: ChainRec1<URI_11>['chainRec'];

// @public (undocumented)
const ChainRec_4: ChainRec1<URI_11>;

// @public (undocumented)
const chainRec_4: ChainRec1<URI_12>['chainRec'];

// @public (undocumented)
const ChainRec_5: ChainRec1<URI_12>;

// @public (undocumented)
const chainRec_5: ChainRec2<URI_13>['chainRec'];

// @public (undocumented)
const ChainRec_6: ChainRec2<URI_13>;

// @public (undocumented)
const chainRec_6: ChainRec1<URI_14>['chainRec'];

// @public
const ChainRec_7: ChainRec1<URI_14>;

// @public (undocumented)
const chainRec_7: ChainRec2<URI_17>['chainRec'];

// @public
const ChainRec_8: ChainRec2<URI_17>;

// @public (undocumented)
const chainRec_8: ChainRec3<URI_18>['chainRec'];

// @public
const ChainRec_9: ChainRec3<URI_18>;

// @public (undocumented)
const chainRec_9: ChainRec2<URI_19>['chainRec'];

// @public (undocumented)
const ChainRecBreadthFirst: ChainRec1<URI_4>;

// @public (undocumented)
const chainRecBreadthFirst: <A, B>(f: (a: A) => Array<Either<A, B>>) => (a: A) => Array<B>;

// @public (undocumented)
const ChainRecBreadthFirst_2: ChainRec1<URI_24>;

// @public (undocumented)
const chainRecBreadthFirst_2: <A, B>(f: (a: A) => readonly Either<A, B>[]) => (a: A) => readonly B[];

// @public (undocumented)
const ChainRecDepthFirst: ChainRec1<URI_4>;

// @public (undocumented)
const chainRecDepthFirst: <A, B>(f: (a: A) => Array<Either<A, B>>) => (a: A) => Array<B>;

// @public (undocumented)
const ChainRecDepthFirst_2: ChainRec1<URI_24>;

// @public (undocumented)
const chainRecDepthFirst_2: <A, B>(f: (a: A) => readonly Either<A, B>[]) => (a: A) => readonly B[];

// @public (undocumented)
function chainStateK<M extends URIS4>(F: FromState4<M>, M: Chain4<M>): <A, S, B>(f: (a: A) => State<S, B>) => <R, E>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>;

// @public (undocumented)
function chainStateK<M extends URIS3>(F: FromState3<M>, M: Chain3<M>): <A, S, B>(f: (a: A) => State<S, B>) => <E>(ma: Kind3<M, S, E, A>) => Kind3<M, S, E, B>;

// @public (undocumented)
function chainStateK<M extends URIS2>(F: FromState2<M>, M: Chain2<M>): <A, S, B>(f: (a: A) => State<S, B>) => (ma: Kind2<M, S, A>) => Kind2<M, S, B>;

// @public (undocumented)
function chainStateK<M>(F: FromState<M>, M: Chain_5<M>): <A, S, B>(f: (a: A) => State<S, B>) => (ma: HKT2<M, S, A>) => HKT2<M, S, B>;

// @public
const chainStateK_2: <A, S, B>(f: (a: A) => State<S, B>) => <R, E>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;

// @public
const chainTaskEitherK: <E, A, B>(f: (a: A) => TaskEither<E, B>) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;

// @public
const chainTaskEitherK_2: <E, A, B>(f: (a: A) => TaskEither<E, B>) => <S, R>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;

// @public
const chainTaskEitherKW: <E2, A, B>(f: (a: A) => TaskEither<E2, B>) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, B>;

// @public
const chainTaskEitherKW_2: <E2, A, B>(f: (a: A) => TaskEither<E2, B>) => <S, R, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, B>;

// @public (undocumented)
function chainTaskK<M extends URIS4>(F: FromTask4<M>, M: Chain4<M>): <A, B>(f: (a: A) => Task<B>) => <S, R, E>(first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>;

// @public (undocumented)
function chainTaskK<M extends URIS3>(F: FromTask3<M>, M: Chain3<M>): <A, B>(f: (a: A) => Task<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, B>;

// @public (undocumented)
function chainTaskK<M extends URIS3, E>(F: FromTask3C<M, E>, M: Chain3C<M, E>): <A, B>(f: (a: A) => Task<B>) => <R>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, B>;

// @public (undocumented)
function chainTaskK<M extends URIS2>(F: FromTask2<M>, M: Chain2<M>): <A, B>(f: (a: A) => Task<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, B>;

// @public (undocumented)
function chainTaskK<M extends URIS2, E>(F: FromTask2C<M, E>, M: Chain2C<M, E>): <A, B>(f: (a: A) => Task<B>) => (first: Kind2<M, E, A>) => Kind2<M, E, B>;

// @public (undocumented)
function chainTaskK<M extends URIS>(F: FromTask1<M>, M: Chain1<M>): <A, B>(f: (a: A) => Task<B>) => (first: Kind<M, A>) => Kind<M, B>;

// @public (undocumented)
function chainTaskK<M>(F: FromTask<M>, M: Chain_5<M>): <A, B>(f: (a: A) => Task<B>) => (first: HKT<M, A>) => HKT<M, B>;

// @public
const chainTaskK_2: <A, B>(f: (a: A) => task.Task<B>) => <R>(first: ReaderTask<R, A>) => ReaderTask<R, B>;

// @public
const chainTaskK_3: <A, B>(f: (a: A) => task.Task<B>) => <E>(first: TaskEither<E, A>) => TaskEither<E, B>;

// @public
const chainTaskK_4: <A, B>(f: (a: A) => task.Task<B>) => <R, E>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;

// @public
const chainTaskK_5: <A, B>(f: (a: A) => Task<B>) => <S, R, E>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;

// @public
const chainTaskK_6: <A, B>(f: (a: A) => task.Task<B>) => (first: TaskOption<A>) => TaskOption<B>;

// @public
const chainTaskOptionK: <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => TaskOption<B>) => (ma: TaskEither<E, A>) => TaskEither<E, B>;

// @public
const chainTaskOptionKW: <E2>(onNone: LazyArg<E2>) => <A, B>(f: (a: A) => TaskOption<B>) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E2 | E1, B>;

// @public
const chainW: <E2, A, B>(f: (a: A) => Either<E2, B>) => <E1>(ma: Either<E1, A>) => Either<E2 | E1, B>;

// @public
const chainW_2: <E2, A, B>(f: (a: A) => IOEither<E2, B>) => <E1>(ma: IOEither<E1, A>) => IOEither<E1 | E2, B>;

// @public
const chainW_3: <R2, A, B>(f: (a: A) => Reader<R2, B>) => <R1>(ma: Reader<R1, A>) => Reader<R1 & R2, B>;

// @public
const chainW_4: <R2, E2, A, B>(f: (a: A) => ReaderEither<R2, E2, B>) => <R1, E1>(ma: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E1 | E2, B>;

// @public
const chainW_5: <A, R2, B>(f: (a: A) => ReaderIO<R2, B>) => <R1>(ma: ReaderIO<R1, A>) => ReaderIO<R1 & R2, B>;

// @public
const chainW_6: <R2, A, B>(f: (a: A) => ReaderTask<R2, B>) => <R1>(ma: ReaderTask<R1, A>) => ReaderTask<R1 & R2, B>;

// @public
const chainW_7: <E2, A, B>(f: (a: A) => TaskEither<E2, B>) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, B>;

// @public
const chainW_8: <R2, E2, A, B>(f: (a: A) => ReaderTaskEither<R2, E2, B>) => <R1, E1>(ma: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, B>;

// @public
const chainW_9: <S, R2, E2, A, B>(f: (a: A) => StateReaderTaskEither<S, R2, E2, B>) => <R1, E1>(ma: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E1 | E2, B>;

// @public (undocumented)
const chainWithIndex: <A, B>(f: (i: number, a: A) => ReadonlyNonEmptyArray<B>) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>;

// @public (undocumented)
const chainWithIndex_2: <A, B>(f: (i: number, a: A) => NonEmptyArray<B>) => (as: NonEmptyArray<A>) => NonEmptyArray<B>;

// @public
const chainWithIndex_3: <A, B>(f: (i: number, a: A) => B[]) => (as: A[]) => B[];

// @public (undocumented)
const chainWithIndex_4: <A, B>(f: (i: number, a: A) => readonly B[]) => (as: readonly A[]) => readonly B[];

// @public (undocumented)
interface Choice<F> extends Profunctor<F> {
    // (undocumented)
    readonly left: <A, B, C>(pab: HKT2<F, A, B>) => HKT2<F, Either<A, C>, Either<B, C>>;
    // (undocumented)
    readonly right: <A, B, C>(pbc: HKT2<F, B, C>) => HKT2<F, Either<A, B>, Either<A, C>>;
}

declare namespace choice {
    export {
        split,
        fanIn,
        splitChoice,
        fanin,
        Choice,
        Choice2,
        Choice3,
        Choice4
    }
}
export { choice }

// @public (undocumented)
interface Choice2<F extends URIS2> extends Profunctor2<F> {
    // (undocumented)
    readonly left: <A, B, C>(pab: Kind2<F, A, B>) => Kind2<F, Either<A, C>, Either<B, C>>;
    // (undocumented)
    readonly right: <A, B, C>(pbc: Kind2<F, B, C>) => Kind2<F, Either<A, B>, Either<A, C>>;
}

// @public (undocumented)
interface Choice3<F extends URIS3> extends Profunctor3<F> {
    // (undocumented)
    readonly left: <R, A, B, C>(pab: Kind3<F, R, A, B>) => Kind3<F, R, Either<A, C>, Either<B, C>>;
    // (undocumented)
    readonly right: <R, A, B, C>(pbc: Kind3<F, R, B, C>) => Kind3<F, R, Either<A, B>, Either<A, C>>;
}

// @public (undocumented)
interface Choice4<F extends URIS4> extends Profunctor4<F> {
    // (undocumented)
    readonly left: <S, R, A, B, C>(pab: Kind4<F, S, R, A, B>) => Kind4<F, S, R, Either<A, C>, Either<B, C>>;
    // (undocumented)
    readonly right: <S, R, A, B, C>(pbc: Kind4<F, S, R, B, C>) => Kind4<F, S, R, Either<A, B>, Either<A, C>>;
}

// @public (undocumented)
const Choice_2: Choice2<URI_17>;

// @public
const chop: <A, B>(f: (as: ReadonlyNonEmptyArray<A>) => readonly [B, readonly A[]]) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>;

// @public (undocumented)
const chop_2: <A, B>(f: (as: NonEmptyArray<A>) => [B, A[]]) => (as: NonEmptyArray<A>) => NonEmptyArray<B>;

// @public
const chop_3: <A, B>(f: (as: nonEmptyArray.NonEmptyArray<A>) => [B, A[]]) => (as: A[]) => B[];

// @public
const chop_4: <A, B>(f: (as: readonlyNonEmptyArray.ReadonlyNonEmptyArray<A>) => readonly [B, readonly A[]]) => (as: readonly A[]) => readonly B[];

// @public
const chunksOf: (n: number) => <A>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<ReadonlyNonEmptyArray<A>>;

// @public (undocumented)
const chunksOf_2: (n: number) => <A>(as: NonEmptyArray<A>) => NonEmptyArray<NonEmptyArray<A>>;

// @public
const chunksOf_3: (n: number) => <A>(as: A[]) => nonEmptyArray.NonEmptyArray<A>[];

// @public
const chunksOf_4: (n: number) => <A>(as: readonly A[]) => readonly readonlyNonEmptyArray.ReadonlyNonEmptyArray<A>[];

// @public
const clamp: <A>(O: Ord<A>) => (low: A, hi: A) => (a: A) => A;

// @public
const clamp_2: <A>(B: Bounded<A>) => (a: A) => A;

// @public (undocumented)
function collect<K>(O: Ord<K>): <A, B>(f: (k: K, a: A) => B) => (m: Map<K, A>) => Array<B>;

// @public (undocumented)
function collect_2<K>(O: Ord<K>): <A, B>(f: (k: K, a: A) => B) => (m: ReadonlyMap<K, A>) => ReadonlyArray<B>;

// @public
function collect_3(O: Ord<string>): <K extends string, A, B>(f: (k: K, a: A) => B) => (r: ReadonlyRecord<K, A>) => ReadonlyArray<B>;

// @public @deprecated
function collect_3<K extends string, A, B>(f: (k: K, a: A) => B): (r: ReadonlyRecord<K, A>) => ReadonlyArray<B>;

// @public
function collect_4(O: Ord<string>): <K extends string, A, B>(f: (k: K, a: A) => B) => (r: Record<K, A>) => Array<B>;

// @public @deprecated
function collect_4<K extends string, A, B>(f: (k: K, a: A) => B): (r: Record<K, A>) => Array<B>;

// @public (undocumented)
const Comonad: Comonad1<URI_2>;

declare namespace comonad {
    export {
        Comonad_3 as Comonad,
        Comonad1,
        Comonad2,
        Comonad2C,
        Comonad3,
        Comonad3C,
        Comonad4
    }
}
export { comonad }

// @public (undocumented)
interface Comonad1<W extends URIS> extends Extend1<W> {
    // (undocumented)
    readonly extract: <A>(wa: Kind<W, A>) => A;
}

// @public (undocumented)
interface Comonad2<W extends URIS2> extends Extend2<W> {
    // (undocumented)
    readonly extract: <E, A>(wa: Kind2<W, E, A>) => A;
}

// @public (undocumented)
interface Comonad2C<W extends URIS2, E> extends Extend2C<W, E> {
    // (undocumented)
    readonly extract: <A>(wa: Kind2<W, E, A>) => A;
}

// @public (undocumented)
interface Comonad3<W extends URIS3> extends Extend3<W> {
    // (undocumented)
    readonly extract: <R, E, A>(wa: Kind3<W, R, E, A>) => A;
}

// @public (undocumented)
interface Comonad3C<W extends URIS3, E> extends Extend3C<W, E> {
    // (undocumented)
    readonly extract: <R, A>(wa: Kind3<W, R, E, A>) => A;
}

// @public (undocumented)
interface Comonad4<W extends URIS4> extends Extend4<W> {
    // (undocumented)
    readonly extract: <S, R, E, A>(wa: Kind4<W, S, R, E, A>) => A;
}

// @public (undocumented)
const Comonad_2: Comonad1<URI_3>;

// @public (undocumented)
interface Comonad_3<W> extends Extend_4<W> {
    // (undocumented)
    readonly extract: <A>(wa: HKT<W, A>) => A;
}

// @public (undocumented)
const Comonad_4: Comonad1<URI_11>;

// @public (undocumented)
const Comonad_5: Comonad2<URI_28>;

// @public (undocumented)
const Comonad_6: Comonad2<URI_32>;

// @public (undocumented)
const Comonad_7: Comonad1<URI_37>;

// @public (undocumented)
const Comonad_8: Comonad2<URI_38>;

// @public
const compact: <A>(fa: Array<Option_2<A>>) => Array<A>;

// @public
const compact_10: <A>(fa: Record<string, Option_2<A>>) => Record<string, A>;

// @public (undocumented)
const compact_11: <A>(E: Eq<A>) => (fa: Set<Option_2<A>>) => Set<A>;

// @public (undocumented)
const compact_12: Compactable1<URI_33>['compact'];

// @public (undocumented)
const compact_2: <A>(fa: Option_2<Option_2<A>>) => Option_2<A>;

// @public
function compact_3<F extends URIS2, G extends URIS2, E>(F: Functor2<F>, G: Compactable2C<G, E>): <FE, A>(fa: Kind2<F, FE, Kind2<G, E, Option_2<A>>>) => Kind2<F, FE, Kind2<G, E, A>>;

// @public (undocumented)
function compact_3<F extends URIS, G extends URIS2, E>(F: Functor1<F>, G: Compactable2C<G, E>): <A>(fa: Kind<F, Kind2<G, E, Option_2<A>>>) => Kind<F, Kind2<G, E, A>>;

// @public (undocumented)
function compact_3<F extends URIS, G extends URIS>(F: Functor1<F>, G: Compactable1<G>): <A>(fa: Kind<F, Kind<G, Option_2<A>>>) => Kind<F, Kind<G, A>>;

// @public (undocumented)
function compact_3<F, G>(F: Functor<F>, G: Compactable_3<G>): <A>(fa: HKT<F, HKT<G, Option_2<A>>>) => HKT<F, HKT<G, A>>;

// @public (undocumented)
const compact_4: Compactable1<URI_14>['compact'];

// @public (undocumented)
const compact_5: <K, A>(fa: Map<K, option.Option<A>>) => Map<K, A>;

// @public (undocumented)
const compact_6: <A>(fa: ReadonlyArray<Option_2<A>>) => ReadonlyArray<A>;

// @public (undocumented)
const compact_7: <K, A>(fa: ReadonlyMap<K, option.Option<A>>) => ReadonlyMap<K, A>;

// @public
const compact_8: <A>(r: Readonly<Record<string, Option_2<A>>>) => Readonly<Record<string, A>>;

// @public (undocumented)
const compact_9: <A>(E: Eq<A>) => (fa: ReadonlySet<Option_2<A>>) => ReadonlySet<A>;

// @public (undocumented)
const Compactable: Compactable1<URI_4>;

declare namespace compactable {
    export {
        compact_3 as compact,
        separate_3 as separate,
        getCompactableComposition,
        Compactable_3 as Compactable,
        Compactable1,
        Compactable2,
        Compactable2C,
        Compactable3,
        Compactable3C,
        Compactable4,
        CompactableComposition,
        CompactableComposition11,
        CompactableComposition12,
        CompactableComposition12C,
        CompactableComposition21,
        CompactableComposition2C1,
        CompactableComposition22,
        CompactableComposition22C,
        CompactableComposition23,
        CompactableComposition23C,
        Separated_2 as Separated
    }
}
export { compactable }

// @public (undocumented)
interface Compactable1<F extends URIS> {
    // (undocumented)
    readonly compact: <A>(fa: Kind<F, Option_2<A>>) => Kind<F, A>;
    // (undocumented)
    readonly separate: <A, B>(fa: Kind<F, Either<A, B>>) => separated.Separated<Kind<F, A>, Kind<F, B>>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Compactable2<F extends URIS2> {
    // (undocumented)
    readonly compact: <E, A>(fa: Kind2<F, E, Option_2<A>>) => Kind2<F, E, A>;
    // (undocumented)
    readonly separate: <E, A, B>(fa: Kind2<F, E, Either<A, B>>) => separated.Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Compactable2C<F extends URIS2, E> {
    // (undocumented)
    readonly compact: <A>(fa: Kind2<F, E, Option_2<A>>) => Kind2<F, E, A>;
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly separate: <A, B>(fa: Kind2<F, E, Either<A, B>>) => separated.Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Compactable3<F extends URIS3> {
    // (undocumented)
    readonly compact: <R, E, A>(fa: Kind3<F, R, E, Option_2<A>>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly separate: <R, E, A, B>(fa: Kind3<F, R, E, Either<A, B>>) => separated.Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Compactable3C<F extends URIS3, E> {
    // (undocumented)
    readonly compact: <R, A>(fa: Kind3<F, R, E, Option_2<A>>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly separate: <R, A, B>(fa: Kind3<F, R, E, Either<A, B>>) => separated.Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Compactable4<F extends URIS4> {
    // (undocumented)
    readonly compact: <S, R, E, A>(fa: Kind4<F, S, R, E, Option_2<A>>) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly separate: <S, R, E, A, B>(fa: Kind4<F, S, R, E, Either<A, B>>) => separated.Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, B>>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const Compactable_10: Compactable1<URI_33>;

// @public (undocumented)
const Compactable_2: Compactable1<URI_7>;

// @public (undocumented)
interface Compactable_3<F> {
    readonly compact: <A>(fa: HKT<F, Option_2<A>>) => HKT<F, A>;
    readonly separate: <A, B>(fa: HKT<F, Either<A, B>>) => separated.Separated<HKT<F, A>, HKT<F, B>>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const Compactable_4: Compactable1<URI_14>;

// @public (undocumented)
const Compactable_5: Compactable2<URI_15>;

// @public (undocumented)
const Compactable_6: Compactable1<URI_24>;

// @public (undocumented)
const Compactable_7: Compactable2<URI_25>;

// @public (undocumented)
const Compactable_8: Compactable1<URI_26>;

// @public (undocumented)
const Compactable_9: Compactable1<URI_29>;

// @public @deprecated (undocumented)
interface CompactableComposition<F, G> extends FunctorComposition<F, G> {
    // (undocumented)
    readonly compact: <A>(fga: HKT<F, HKT<G, Option_2<A>>>) => HKT<F, HKT<G, A>>;
    // (undocumented)
    readonly separate: <A, B>(fge: HKT<F, HKT<G, Either<A, B>>>) => Separated_2<HKT<F, HKT<G, A>>, HKT<F, HKT<G, B>>>;
}

// @public @deprecated (undocumented)
interface CompactableComposition11<F extends URIS, G extends URIS> extends FunctorComposition11<F, G> {
    // (undocumented)
    readonly compact: <A>(fga: Kind<F, Kind<G, Option_2<A>>>) => Kind<F, Kind<G, A>>;
    // (undocumented)
    readonly separate: <A, B>(fge: Kind<F, Kind<G, Either<A, B>>>) => Separated_2<Kind<F, Kind<G, A>>, Kind<F, Kind<G, B>>>;
}

// @public @deprecated (undocumented)
interface CompactableComposition12<F extends URIS, G extends URIS2> extends FunctorComposition12<F, G> {
    // (undocumented)
    readonly compact: <E, A>(fga: Kind<F, Kind2<G, E, Option_2<A>>>) => Kind<F, Kind2<G, E, A>>;
    // (undocumented)
    readonly separate: <E, A, B>(fge: Kind<F, Kind2<G, E, Either<A, B>>>) => Separated_2<Kind<F, Kind2<G, E, A>>, Kind<F, Kind2<G, E, B>>>;
}

// @public @deprecated (undocumented)
interface CompactableComposition12C<F extends URIS, G extends URIS2, E> extends FunctorComposition12C<F, G, E> {
    // (undocumented)
    readonly compact: <A>(fga: Kind<F, Kind2<G, E, Option_2<A>>>) => Kind<F, Kind2<G, E, A>>;
    // (undocumented)
    readonly separate: <A, B>(fge: Kind<F, Kind2<G, E, Either<A, B>>>) => Separated_2<Kind<F, Kind2<G, E, A>>, Kind<F, Kind2<G, E, B>>>;
}

// @public @deprecated (undocumented)
interface CompactableComposition21<F extends URIS2, G extends URIS> extends FunctorComposition21<F, G> {
    // (undocumented)
    readonly compact: <FE, A>(fga: Kind2<F, FE, Kind<G, Option_2<A>>>) => Kind2<F, FE, Kind<G, A>>;
    // (undocumented)
    readonly separate: <FE, A, B>(fge: Kind2<F, FE, Kind<G, Either<A, B>>>) => Separated_2<Kind2<F, FE, Kind<G, A>>, Kind2<F, FE, Kind<G, B>>>;
}

// @public @deprecated (undocumented)
interface CompactableComposition22<F extends URIS2, G extends URIS2> extends FunctorComposition22<F, G> {
    // (undocumented)
    readonly compact: <FE, GE, A>(fga: Kind2<F, FE, Kind2<G, GE, Option_2<A>>>) => Kind2<F, FE, Kind2<G, GE, A>>;
    // (undocumented)
    readonly separate: <FE, GE, A, B>(fge: Kind2<F, FE, Kind2<G, GE, Either<A, B>>>) => Separated_2<Kind2<F, FE, Kind2<G, GE, A>>, Kind2<F, FE, Kind2<G, GE, B>>>;
}

// @public @deprecated (undocumented)
interface CompactableComposition22C<F extends URIS2, G extends URIS2, E> extends FunctorComposition22C<F, G, E> {
    // (undocumented)
    readonly compact: <FE, A>(fga: Kind2<F, FE, Kind2<G, E, Option_2<A>>>) => Kind2<F, FE, Kind2<G, E, A>>;
    // (undocumented)
    readonly separate: <FE, A, B>(fge: Kind2<F, FE, Kind2<G, E, Either<A, B>>>) => Separated_2<Kind2<F, FE, Kind2<G, E, A>>, Kind2<F, FE, Kind2<G, E, B>>>;
}

// @public @deprecated (undocumented)
interface CompactableComposition23<F extends URIS2, G extends URIS3> extends FunctorComposition23<F, G> {
    // (undocumented)
    readonly compact: <R, FE, GE, A>(fga: Kind2<F, FE, Kind3<G, R, GE, Option_2<A>>>) => Kind2<F, FE, Kind3<G, R, GE, A>>;
    // (undocumented)
    readonly separate: <R, FE, GE, A, B>(fge: Kind2<F, FE, Kind3<G, R, GE, Either<A, B>>>) => Separated_2<Kind2<F, FE, Kind3<G, R, GE, A>>, Kind2<F, FE, Kind3<G, R, GE, B>>>;
}

// @public @deprecated (undocumented)
interface CompactableComposition23C<F extends URIS2, G extends URIS3, E> extends FunctorComposition23C<F, G, E> {
    // (undocumented)
    readonly compact: <FE, R, A>(fga: Kind2<F, FE, Kind3<G, R, E, Option_2<A>>>) => Kind2<F, FE, Kind3<G, R, E, A>>;
    // (undocumented)
    readonly separate: <FE, R, A, B>(fge: Kind2<F, FE, Kind3<G, R, E, Either<A, B>>>) => Separated_2<Kind2<F, FE, Kind3<G, R, E, A>>, Kind2<F, FE, Kind3<G, R, E, B>>>;
}

// @public @deprecated (undocumented)
interface CompactableComposition2C1<F extends URIS2, G extends URIS, E> extends FunctorComposition2C1<F, G, E> {
    // (undocumented)
    readonly compact: <A>(fga: Kind2<F, E, Kind<G, Option_2<A>>>) => Kind2<F, E, Kind<G, A>>;
    // (undocumented)
    readonly separate: <A, B>(fge: Kind2<F, E, Kind<G, Either<A, B>>>) => Separated_2<Kind2<F, E, Kind<G, A>>, Kind2<F, E, Kind<G, B>>>;
}

// @public
function compose<F extends URIS4>(F: Semigroupoid4<F>): <S, R, E, A>(ea: Kind4<F, S, R, E, A>) => <B>(ab: Kind4<F, S, R, A, B>) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function compose<F extends URIS3>(F: Semigroupoid3<F>): <R, E, A>(ea: Kind3<F, R, E, A>) => <B>(ab: Kind3<F, R, A, B>) => Kind3<F, R, E, B>;

// @public (undocumented)
function compose<F extends URIS3, E>(F: Semigroupoid3C<F, E>): <R, A>(ea: Kind3<F, R, E, A>) => <B>(ab: Kind3<F, R, A, B>) => Kind3<F, R, E, B>;

// @public (undocumented)
function compose<F extends URIS2>(F: Semigroupoid2<F>): <E, A>(ea: Kind2<F, E, A>) => <B>(ab: Kind2<F, A, B>) => Kind2<F, E, B>;

// @public (undocumented)
function compose<F extends URIS2, E>(F: Semigroupoid2C<F, E>): <A>(ea: Kind2<F, E, A>) => <B>(ab: Kind2<F, A, B>) => Kind2<F, E, B>;

// @public (undocumented)
function compose<F>(F: Semigroupoid<F>): <E, A>(ea: HKT2<F, E, A>) => <B>(ab: HKT2<F, A, B>) => HKT2<F, E, B>;

// @public (undocumented)
const compose_2: <A, B>(ab: Reader<A, B>) => <C>(bc: Reader<B, C>) => Reader<A, C>;

// @public (undocumented)
const compose_3: <A, B>(ab: readonly [B, A]) => <C>(bc: readonly [C, B]) => readonly [C, A];

// @public (undocumented)
const compose_4: <A, B extends A, C extends B>(bc: Refinement<B, C>) => (ab: Refinement<A, B>) => Refinement<A, C>;

// @public (undocumented)
const compose_5: <A, B>(ab: [B, A]) => <C>(bc: [C, B]) => [C, A];

// @public
function comprehension<A, B, C, D, R>(input: [Array<A>, Array<B>, Array<C>, Array<D>], f: (a: A, b: B, c: C, d: D) => R, g?: (a: A, b: B, c: C, d: D) => boolean): Array<R>;

// @public (undocumented)
function comprehension<A, B, C, R>(input: [Array<A>, Array<B>, Array<C>], f: (a: A, b: B, c: C) => R, g?: (a: A, b: B, c: C) => boolean): Array<R>;

// @public (undocumented)
function comprehension<A, B, R>(input: [Array<A>, Array<B>], f: (a: A, b: B) => R, g?: (a: A, b: B) => boolean): Array<R>;

// @public (undocumented)
function comprehension<A, R>(input: [Array<A>], f: (a: A) => R, g?: (a: A) => boolean): Array<R>;

// @public
function comprehension_2<A, B, C, D, R>(input: readonly [ReadonlyArray<A>, ReadonlyArray<B>, ReadonlyArray<C>, ReadonlyArray<D>], f: (a: A, b: B, c: C, d: D) => R, g?: (a: A, b: B, c: C, d: D) => boolean): ReadonlyArray<R>;

// @public (undocumented)
function comprehension_2<A, B, C, R>(input: readonly [ReadonlyArray<A>, ReadonlyArray<B>, ReadonlyArray<C>], f: (a: A, b: B, c: C) => R, g?: (a: A, b: B, c: C) => boolean): ReadonlyArray<R>;

// @public (undocumented)
function comprehension_2<A, B, R>(input: readonly [ReadonlyArray<A>, ReadonlyArray<B>], f: (a: A, b: B) => R, g?: (a: A, b: B) => boolean): ReadonlyArray<R>;

// @public (undocumented)
function comprehension_2<A, R>(input: readonly [ReadonlyArray<A>], f: (a: A) => R, g?: (a: A) => boolean): ReadonlyArray<R>;

// @public (undocumented)
function concat<A>(second: NonEmptyArray<A>): (first: Array<A>) => NonEmptyArray<A>;

// @public (undocumented)
function concat<A>(second: Array<A>): (first: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public @deprecated (undocumented)
function concat<A>(first: Array<A>, second: NonEmptyArray<A>): NonEmptyArray<A>;

// @public @deprecated (undocumented)
function concat<A>(first: NonEmptyArray<A>, second: Array<A>): NonEmptyArray<A>;

// @public (undocumented)
function concat_2<A>(second: ReadonlyNonEmptyArray<A>): (first: ReadonlyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public (undocumented)
function concat_2<A>(second: ReadonlyArray<A>): (first: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public @deprecated (undocumented)
function concat_2<A>(first: ReadonlyArray<A>, second: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<A>;

// @public @deprecated (undocumented)
function concat_2<A>(first: ReadonlyNonEmptyArray<A>, second: ReadonlyArray<A>): ReadonlyNonEmptyArray<A>;

// @public (undocumented)
const concat_3: <A>(second: Array<A>) => (first: Array<A>) => Array<A>;

// @public (undocumented)
const concat_4: <A>(second: ReadonlyArray<A>) => (first: ReadonlyArray<A>) => ReadonlyArray<A>;

// @public
const concatAll: <A>(S: Semigroup<A>) => (startWith: A) => (as: ReadonlyArray<A>) => A;

// @public (undocumented)
const concatAll_2: <A>(S: semigroup.Semigroup<A>) => (as: ReadonlyNonEmptyArray<A>) => A;

// @public (undocumented)
const concatAll_3: <A>(S: Semigroup<A>) => (as: NonEmptyArray<A>) => A;

// @public
const concatAll_4: <A>(M: Monoid<A>) => (as: readonly A[]) => A;

// @public
const concatAll_5: <A>(M: Magma<A>) => (startWith: A) => (as: readonly A[]) => A;

// @public (undocumented)
function concatW<B>(second: NonEmptyArray<B>): <A>(first: Array<A>) => NonEmptyArray<A | B>;

// @public (undocumented)
function concatW<B>(second: Array<B>): <A>(first: NonEmptyArray<A>) => NonEmptyArray<A | B>;

// @public (undocumented)
function concatW_2<B>(second: ReadonlyNonEmptyArray<B>): <A>(first: ReadonlyArray<A>) => ReadonlyNonEmptyArray<A | B>;

// @public (undocumented)
function concatW_2<B>(second: ReadonlyArray<B>): <A>(first: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A | B>;

// @public (undocumented)
const concatW_3: <B>(second: B[]) => <A>(first: A[]) => (B | A)[];

// @public (undocumented)
const concatW_4: <B>(second: readonly B[]) => <A>(first: readonly A[]) => readonly (B | A)[];

// @public @deprecated
function cons<A>(head: A): (tail: Array<A>) => NonEmptyArray<A>;

// @public @deprecated (undocumented)
function cons<A>(head: A, tail: Array<A>): NonEmptyArray<A>;

// @public @deprecated
function cons_2<A>(head: A): (tail: ReadonlyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public @deprecated (undocumented)
function cons_2<A>(head: A, tail: ReadonlyArray<A>): ReadonlyNonEmptyArray<A>;

// @public @deprecated
const cons_3: typeof nonEmptyArray.cons;

// @public @deprecated
const cons_4: typeof readonlyNonEmptyArray.cons;

declare namespace console_2 {
    export {
        log,
        warn,
        error,
        info
    }
}
export { console_2 as console }

// @public (undocumented)
type Const<E, A> = E & {
    readonly _A: A;
};

declare namespace const {
    export {
        getShow_6 as getShow,
        getApply,
        getApplicative,
        Const,
        make,
        getEq_6 as getEq,
        getOrd_3 as getOrd,
        getBounded,
        getSemigroup_7 as getSemigroup,
        getMonoid_5 as getMonoid,
        getSemiring,
        getRing,
        getHeytingAlgebra,
        getBooleanAlgebra,
        contramap_3 as contramap,
        map_8 as map,
        bimap_3 as bimap,
        mapLeft_3 as mapLeft,
        URI_9 as URI,
        Functor_8 as Functor,
        flap_7 as flap,
        Contravariant_3 as Contravariant,
        Bifunctor_4 as Bifunctor,
        const_
    }
}
export { const }

// @public @deprecated
const const_: Functor2<URI_9> & Contravariant2<URI_9> & Bifunctor2<URI_9>;

// @public (undocumented)
const constant: <A>(a: A) => Semigroup<A>;

// @public (undocumented)
function constant_2<A>(a: A): LazyArg<A>;

// @public
const constFalse: LazyArg<boolean>;

// @public
const constNull: LazyArg<null>;

// @public
const constTrue: LazyArg<boolean>;

// @public
const constUndefined: LazyArg<undefined>;

// @public
const constVoid: LazyArg<void>;

// @public
const contramap: <A, B>(f: (b: B) => A) => (fa: Ord<A>) => Ord<B>;

// @public
const contramap_2: <A, B>(f: (b: B) => A) => (fa: Eq<A>) => Eq<B>;

// @public (undocumented)
const contramap_3: <A, B>(f: (b: B) => A) => <E>(fa: Const<E, A>) => Const<E, B>;

// @public
function contramap_4<F extends URIS4>(F: Contravariant4<F>): <A, B>(f: (b: B) => A) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function contramap_4<F extends URIS3>(F: Contravariant3<F>): <A, B>(f: (b: B) => A) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function contramap_4<F extends URIS3, E>(F: Contravariant3C<F, E>): <A, B>(f: (b: B) => A) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function contramap_4<F extends URIS2>(F: Contravariant2<F>): <A, B>(f: (b: B) => A) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function contramap_4<F extends URIS2, E>(F: Contravariant2C<F, E>): <A, B>(f: (b: B) => A) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function contramap_4<F extends URIS>(F: Contravariant1<F>): <A, B>(f: (b: B) => A) => (fa: Kind<F, A>) => Kind<F, B>;

// @public (undocumented)
function contramap_4<F>(F: Contravariant_4<F>): <A, B>(f: (b: B) => A) => (fa: HKT<F, A>) => HKT<F, B>;

// @public (undocumented)
const contramap_5: <B, A>(f: (b: B) => A) => (predicate: Predicate<A>) => Predicate<B>;

// @public (undocumented)
const Contravariant: Contravariant1<URI>;

declare namespace contravariant {
    export {
        Contravariant_4 as Contravariant,
        Contravariant1,
        Contravariant2,
        Contravariant2C,
        Contravariant3,
        Contravariant3C,
        Contravariant4
    }
}
export { contravariant }

// @public (undocumented)
interface Contravariant1<F extends URIS> {
    // (undocumented)
    readonly contramap: <A, B>(fa: Kind<F, A>, f: (b: B) => A) => Kind<F, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Contravariant2<F extends URIS2> {
    // (undocumented)
    readonly contramap: <E, A, B>(fa: Kind2<F, E, A>, f: (b: B) => A) => Kind2<F, E, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Contravariant2C<F extends URIS2, E> {
    // (undocumented)
    readonly contramap: <A, B>(fa: Kind2<F, E, A>, f: (b: B) => A) => Kind2<F, E, B>;
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Contravariant3<F extends URIS3> {
    // (undocumented)
    readonly contramap: <R, E, A, B>(fa: Kind3<F, R, E, A>, f: (b: B) => A) => Kind3<F, R, E, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Contravariant3C<F extends URIS3, E> {
    // (undocumented)
    readonly contramap: <R, A, B>(fa: Kind3<F, R, E, A>, f: (b: B) => A) => Kind3<F, R, E, B>;
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Contravariant4<F extends URIS4> {
    // (undocumented)
    readonly contramap: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, f: (b: B) => A) => Kind4<F, S, R, E, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const Contravariant_2: Contravariant1<URI_8>;

// @public (undocumented)
const Contravariant_3: Contravariant2<URI_9>;

// @public (undocumented)
interface Contravariant_4<F> {
    // (undocumented)
    readonly contramap: <A, B>(fa: HKT<F, A>, f: (b: B) => A) => HKT<F, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const Contravariant_5: Contravariant1<URI_16>;

// @public (undocumented)
const copy: <A>(as: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public
const copy_2: <A>(as: A[]) => A[];

// @public
const create: IO<Date>;

declare namespace date {
    export {
        Eq_3 as Eq,
        eqDate_2 as eqDate,
        eqMonth,
        eqYear,
        Ord_3 as Ord,
        create,
        now
    }
}
export { date }

// @public (undocumented)
function decrement(n: number): number;

// @public
function delay(millis: number): <A>(ma: Task<A>) => Task<A>;

// @public
const deleteAt: (i: number) => <A>(as: A[]) => Option_2<A[]>;

// @public
const deleteAt_2: <K>(E: Eq<K>) => (k: K) => <A>(m: Map<K, A>) => Map<K, A>;

// @public
const deleteAt_3: (i: number) => <A>(as: readonly A[]) => Option_2<readonly A[]>;

// @public
const deleteAt_4: <K>(E: Eq<K>) => (k: K) => <A>(m: ReadonlyMap<K, A>) => ReadonlyMap<K, A>;

// @public
function deleteAt_5<K extends string>(k: K): <KS extends string, A>(r: ReadonlyRecord<KS, A>) => ReadonlyRecord<string extends K ? string : Exclude<KS, K>, A>;

// @public
function deleteAt_6<K extends string>(k: K): <KS extends string, A>(r: Record<KS, A>) => Record<string extends K ? string : Exclude<KS, K>, A>;

// @public
function difference<A>(E: Eq<A>): {
    (xs: Array<A>): (ys: Array<A>) => Array<A>;
    (xs: Array<A>, ys: Array<A>): Array<A>;
};

// @public (undocumented)
const difference_2: <K>(E: Eq<K>) => <A>(_second: Map<K, A>) => (first: Map<K, A>) => Map<K, A>;

// @public
function difference_3<A>(E: Eq<A>): {
    (xs: ReadonlyArray<A>): (ys: ReadonlyArray<A>) => ReadonlyArray<A>;
    (xs: ReadonlyArray<A>, ys: ReadonlyArray<A>): ReadonlyArray<A>;
};

// @public (undocumented)
const difference_4: <K>(E: Eq<K>) => <A>(_second: ReadonlyMap<K, A>) => (first: ReadonlyMap<K, A>) => ReadonlyMap<K, A>;

// @public
const difference_5: <A>(second: Readonly<Record<string, A>>) => (first: Readonly<Record<string, A>>) => Readonly<Record<string, A>>;

// @public
function difference_6<A>(E: Eq<A>): {
    (that: ReadonlySet<A>): (me: ReadonlySet<A>) => ReadonlySet<A>;
    (me: ReadonlySet<A>, that: ReadonlySet<A>): ReadonlySet<A>;
};

// @public
const difference_7: <A>(second: Record<string, A>) => (first: Record<string, A>) => Record<string, A>;

// @public
function difference_8<A>(E: Eq<A>): {
    (that: Set<A>): (me: Set<A>) => Set<A>;
    (me: Set<A>, that: Set<A>): Set<A>;
};

// @public (undocumented)
interface DistributiveLattice<A> extends Lattice<A> {
}

declare namespace distributiveLattice {
    export {
        getMinMaxDistributiveLattice,
        DistributiveLattice
    }
}
export { distributiveLattice }

// @public (undocumented)
const Do: ReadonlyNonEmptyArray<{}>;

// Warning: (ae-forgotten-export) The symbol "OptionIterable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do_: <MA extends OptionIterable<any>, A>(yieldFunction: (unwrap: <A>(ma: Option_2<A>) => OptionIterable<A>) => Generator<MA, A>) => Option_2<A>;

// @public (undocumented)
const Do_10: Reader<unknown, {}>;

// @public (undocumented)
const Do_11: ReaderEither<unknown, never, {}>;

// @public (undocumented)
const Do_12: ReaderIO<unknown, {}>;

// @public (undocumented)
const Do_13: Task<{}>;

// @public (undocumented)
const Do_14: ReaderTask<unknown, {}>;

// @public (undocumented)
const Do_15: TaskEither<never, {}>;

// @public (undocumented)
const Do_16: ReaderTaskEither<unknown, never, {}>;

// @public (undocumented)
const Do_17: ReadonlyArray<{}>;

// @public (undocumented)
const Do_18: TaskOption<{}>;

// @public (undocumented)
const Do_19: Tree<{}>;

// @public (undocumented)
const Do_2: NonEmptyArray<{}>;

// @public (undocumented)
const Do_3: Option_2<{}>;

// @public (undocumented)
const Do_4: Either<never, {}>;

// @public (undocumented)
const Do_5: Array<{}>;

// @public (undocumented)
const Do_6: Identity<{}>;

// @public (undocumented)
const Do_7: IO<{}>;

// @public (undocumented)
const Do_8: IOEither<never, {}>;

// @public (undocumented)
const Do_9: IOOption<{}>;

// Warning: (ae-forgotten-export) The symbol "TaskIterable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do__10: <MA extends TaskIterable<any>, A>(yieldFunction: (unwrap: <A>(ma: Task<A>) => TaskIterable<A>) => Generator<MA, A>) => Task<A>;

// Warning: (ae-forgotten-export) The symbol "ReaderTaskIterable" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "_" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do__11: <MA extends ReaderTaskIterable<any, any>, A>(yieldFunction: (unwrap: <R, A>(ma: ReaderTask<R, A>) => ReaderTaskIterable<R, A>) => Generator<MA, A>) => ReaderTask<_.UnionToIntersection<MA extends ReaderTaskIterable<infer R, any> ? R : never>, A>;

// Warning: (ae-forgotten-export) The symbol "TaskEitherIterable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do__12: <MA extends TaskEitherIterable<any, any>, A>(yieldFunction: (unwrap: <E, A>(ma: TaskEither<E, A>) => TaskEitherIterable<E, A>) => Generator<MA, A>) => TaskEither<MA extends TaskEitherIterable<infer E, any> ? E : never, A>;

// Warning: (ae-forgotten-export) The symbol "ReaderTaskEitherIterable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do__13: <MA extends ReaderTaskEitherIterable<any, any, any>, A>(yieldFunction: (unwrap: <R, E, A>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEitherIterable<R, E, A>) => Generator<MA, A>) => ReaderTaskEither<_.UnionToIntersection<MA extends ReaderTaskEitherIterable<infer R, any, any> ? R : never>, MA extends ReaderTaskEitherIterable<any, infer E, any> ? E : never, A>;

// Warning: (ae-forgotten-export) The symbol "StateIterable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do__14: <MA extends StateIterable<any, any>, A>(yieldFunction: (unwrap: <S, A>(ma: State<S, A>) => StateIterable<S, A>) => Generator<MA, A>) => State<_.UnionToIntersection<MA extends StateIterable<infer S, any> ? S : never>, A>;

// Warning: (ae-forgotten-export) The symbol "StateReaderTaskEitherIterable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do__15: <MA extends StateReaderTaskEitherIterable<any, any, any, any>, A>(yieldFunction: (unwrap: <S, R, E, A>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEitherIterable<S, R, E, A>) => Generator<MA, A>) => StateReaderTaskEither<_.UnionToIntersection<MA extends StateReaderTaskEitherIterable<infer S, any, any, any> ? S : never>, _.UnionToIntersection<MA extends StateReaderTaskEitherIterable<any, infer R, any, any> ? R : never>, MA extends StateReaderTaskEitherIterable<any, any, infer E, any> ? E : never, A>;

// Warning: (ae-forgotten-export) The symbol "TaskOptionIterable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do__16: <MA extends TaskOptionIterable<any>, A>(yieldFunction: (unwrap: <A>(ma: TaskOption<A>) => TaskOptionIterable<A>) => Generator<MA, A>) => TaskOption<A>;

// Warning: (ae-forgotten-export) The symbol "DoFunction4" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function do__2<M extends URIS4>(P: Pointed4<M>, M: ChainRec4<M>): DoFunction4<M>;

// Warning: (ae-forgotten-export) The symbol "DoFunction3" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function do__2<M extends URIS3>(P: Pointed3<M>, M: ChainRec3<M>): DoFunction3<M>;

// Warning: (ae-forgotten-export) The symbol "DoFunction3C" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function do__2<M extends URIS3, E>(P: Pointed3C<M, E>, M: ChainRec3C<M, E>): DoFunction3C<M, E>;

// Warning: (ae-forgotten-export) The symbol "DoFunction2" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function do__2<M extends URIS2>(P: Pointed2<M>, M: ChainRec2<M>): DoFunction2<M>;

// Warning: (ae-forgotten-export) The symbol "DoFunction2C" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function do__2<M extends URIS2, E>(P: Pointed2C<M, E>, M: ChainRec2C<M, E>): DoFunction2C<M, E>;

// Warning: (ae-forgotten-export) The symbol "DoFunction1" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function do__2<M extends URIS>(P: Pointed1<M>, M: ChainRec1<M>): DoFunction1<M>;

// Warning: (ae-forgotten-export) The symbol "EitherIterable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do__3: <MA extends EitherIterable<any, any>, A>(yieldFunction: (unwrap: <E, A>(ma: Either<E, A>) => EitherIterable<E, A>) => Generator<MA, A>) => Either<MA extends EitherIterable<infer E, any> ? E : never, A>;

// Warning: (ae-forgotten-export) The symbol "IOIterable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do__4: <MA extends IOIterable<any>, A>(yieldFunction: (unwrap: <A>(ma: IO<A>) => IOIterable<A>) => Generator<MA, A>) => IO<A>;

// Warning: (ae-forgotten-export) The symbol "IOEitherIterable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do__5: <MA extends IOEitherIterable<any, any>, A>(yieldFunction: (unwrap: <E, A>(ma: IOEither<E, A>) => IOEitherIterable<E, A>) => Generator<MA, A>) => IOEither<MA extends IOEitherIterable<infer E, any> ? E : never, A>;

// Warning: (ae-forgotten-export) The symbol "IOOptionIterable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do__6: <MA extends IOOptionIterable<any>, A>(yieldFunction: (unwrap: <A>(ma: IOOption<A>) => IOOptionIterable<A>) => Generator<MA, A>) => IOOption<A>;

// Warning: (ae-forgotten-export) The symbol "ReaderIterable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do__7: <MA extends ReaderIterable<any, any>, A>(yieldFunction: (unwrap: <R, A>(ma: Reader<R, A>) => ReaderIterable<R, A>) => Generator<MA, A>) => Reader<_.UnionToIntersection<MA extends ReaderIterable<infer R, any> ? R : never>, A>;

// Warning: (ae-forgotten-export) The symbol "ReaderEitherIterable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do__8: <MA extends ReaderEitherIterable<any, any, any>, A>(yieldFunction: (unwrap: <R, E, A>(ma: ReaderEither<R, E, A>) => ReaderEitherIterable<R, E, A>) => Generator<MA, A>) => ReaderEither<_.UnionToIntersection<MA extends ReaderEitherIterable<infer R, any, any> ? R : never>, MA extends ReaderEitherIterable<any, infer E, any> ? E : never, A>;

// Warning: (ae-forgotten-export) The symbol "ReaderIOIterable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
const do__9: <MA extends ReaderIOIterable<any, any>, A>(yieldFunction: (unwrap: <R, A>(ma: ReaderIO<R, A>) => ReaderIOIterable<R, A>) => Generator<MA, A>) => ReaderIO<_.UnionToIntersection<MA extends ReaderIOIterable<infer R, any> ? R : never>, A>;

// @public
function drawForest(forest: Forest<string>): string;

// @public
function drawTree(tree: Tree<string>): string;

// @public
const dropLeft: (n: number) => <A>(as: A[]) => A[];

// @public
const dropLeft_2: (n: number) => <A>(as: readonly A[]) => readonly A[];

// @public
function dropLeftWhile<A, B extends A>(refinement: Refinement<A, B>): (as: Array<A>) => Array<B>;

// @public (undocumented)
function dropLeftWhile<A>(predicate: Predicate<A>): <B extends A>(bs: Array<B>) => Array<B>;

// @public (undocumented)
function dropLeftWhile<A>(predicate: Predicate<A>): (as: Array<A>) => Array<A>;

// @public
function dropLeftWhile_2<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => ReadonlyArray<B>;

// @public (undocumented)
function dropLeftWhile_2<A>(predicate: Predicate<A>): <B extends A>(bs: ReadonlyArray<B>) => ReadonlyArray<B>;

// @public (undocumented)
function dropLeftWhile_2<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => ReadonlyArray<A>;

// @public
const dropRight: (n: number) => <A>(as: A[]) => A[];

// @public
const dropRight_2: (n: number) => <A>(as: readonly A[]) => readonly A[];

// @public (undocumented)
const duplicate: <A>(ma: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<ReadonlyNonEmptyArray<A>>;

// @public (undocumented)
const duplicate_10: <A>(wa: Tree<A>) => Tree<Tree<A>>;

// @public (undocumented)
const duplicate_11: <E, A>(wa: [A, E]) => [[A, E], E];

// @public (undocumented)
const duplicate_2: <A>(ma: NonEmptyArray<A>) => NonEmptyArray<NonEmptyArray<A>>;

// @public
const duplicate_3: <A>(wa: Array<A>) => Array<Array<A>>;

// @public (undocumented)
const duplicate_4: <A>(ma: Option_2<A>) => Option_2<Option_2<A>>;

// @public (undocumented)
const duplicate_5: <E, A>(ma: Either<E, A>) => Either<E, Either<E, A>>;

// @public (undocumented)
const duplicate_6: <A>(ma: Identity<A>) => Identity<Identity<A>>;

// @public (undocumented)
const duplicate_7: <A>(wa: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>;

// @public (undocumented)
const duplicate_8: <E, A>(wa: readonly [A, E]) => readonly [readonly [A, E], E];

// @public (undocumented)
const duplicate_9: <E, A>(wa: Store<E, A>) => Store<E, Store<E, A>>;

// @public (undocumented)
type Either<E, A> = Left<E> | Right<A>;

declare namespace either {
    export {
        toError,
        elem_2 as elem,
        parseJSON,
        getValidation,
        Left,
        Right,
        Either,
        left_2 as left,
        right_2 as right,
        flatMap_5 as flatMap,
        URI_6 as URI,
        getShow_5 as getShow,
        getEq_5 as getEq,
        getSemigroup_5 as getSemigroup,
        getCompactable,
        getFilterable,
        getWitherable,
        getApplicativeValidation,
        getAltValidation,
        map_7 as map,
        Functor_7 as Functor,
        as_2 as as,
        asUnit_2 as asUnit,
        of_5 as of,
        Pointed_6 as Pointed,
        apW,
        ap_6 as ap,
        Apply_6 as Apply,
        Applicative_6 as Applicative,
        Chain_6 as Chain,
        Monad_5 as Monad,
        reduce_5 as reduce,
        foldMap_5 as foldMap,
        reduceRight_5 as reduceRight,
        Foldable_5 as Foldable,
        traverse_5 as traverse,
        sequence_5 as sequence,
        Traversable_5 as Traversable,
        bimap_2 as bimap,
        mapLeft_2 as mapLeft,
        Bifunctor_2 as Bifunctor,
        altW_5 as altW,
        alt_6 as alt,
        Alt_6 as Alt,
        extend_6 as extend,
        Extend_3 as Extend,
        ChainRec_3 as ChainRec,
        throwError_2 as throwError,
        MonadThrow_2 as MonadThrow,
        FromEither_2 as FromEither,
        fromPredicate_3 as fromPredicate,
        fromOption_2 as fromOption,
        isLeft,
        isRight,
        matchW_3 as matchW,
        foldW_2 as foldW,
        match_3 as match,
        fold_6 as fold,
        getOrElseW_2 as getOrElseW,
        getOrElse_2 as getOrElse,
        flap_6 as flap,
        apFirst_6 as apFirst,
        apFirstW,
        apSecond_6 as apSecond,
        apSecondW,
        tap_2 as tap,
        flattenW,
        flatten_5 as flatten,
        duplicate_5 as duplicate,
        fromOptionK_2 as fromOptionK,
        chainOptionK,
        chainOptionKW,
        liftNullable,
        liftOption,
        flatMapNullable,
        flatMapOption,
        filterOrElse,
        filterOrElseW,
        swap,
        orElseW,
        orElse_2 as orElse,
        fromNullable_2 as fromNullable,
        tryCatch_2 as tryCatch,
        tryCatchK_2 as tryCatchK,
        fromNullableK_2 as fromNullableK,
        chainNullableK_2 as chainNullableK,
        toUnion,
        exists_2 as exists,
        Do_4 as Do,
        bindTo_4 as bindTo,
        let__4 as let,
        bind_5 as bind,
        bindW,
        apS_5 as apS,
        apSW,
        ApT_2 as ApT,
        do__3 as do,
        traverseReadonlyNonEmptyArrayWithIndex_2 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_2 as traverseReadonlyArrayWithIndex,
        traverseArrayWithIndex_2 as traverseArrayWithIndex,
        traverseArray_2 as traverseArray,
        sequenceArray_2 as sequenceArray,
        chainW,
        chain_5 as chain,
        chainFirst_6 as chainFirst,
        chainFirstW,
        Json,
        JsonRecord,
        JsonArray,
        stringifyJSON,
        either_2 as either,
        getApplySemigroup_3 as getApplySemigroup,
        getApplyMonoid_2 as getApplyMonoid,
        getValidationSemigroup,
        getValidationMonoid
    }
}
export { either }

// @public @deprecated
const either_2: Monad2<URI_6> & Foldable2<URI_6> & Traversable2<URI_6> & Bifunctor2<URI_6> & Alt2<URI_6> & Extend2<URI_6> & chainRec.ChainRec2<URI_6> & MonadThrow2<URI_6>;

// @public @deprecated (undocumented)
interface EitherM<M> extends ApplicativeCompositionHKT2<M, URI_6> {
    // (undocumented)
    readonly alt: <E, A>(fa: EitherT<M, E, A>, that: LazyArg<EitherT<M, E, A>>) => EitherT<M, E, A>;
    // (undocumented)
    readonly bimap: <E, A, N, B>(ma: EitherT<M, E, A>, f: (e: E) => N, g: (a: A) => B) => EitherT<M, N, B>;
    // (undocumented)
    readonly chain: <E, A, B>(ma: EitherT<M, E, A>, f: (a: A) => EitherT<M, E, B>) => EitherT<M, E, B>;
    // (undocumented)
    readonly fold: <E, A, R>(ma: EitherT<M, E, A>, onLeft: (e: E) => HKT<M, R>, onRight: (a: A) => HKT<M, R>) => HKT<M, R>;
    // (undocumented)
    readonly getOrElse: <E, A>(ma: EitherT<M, E, A>, onLeft: (e: E) => HKT<M, A>) => HKT<M, A>;
    // (undocumented)
    readonly left: <E, A>(e: E) => EitherT<M, E, A>;
    // (undocumented)
    readonly leftM: <E, A>(me: HKT<M, E>) => EitherT<M, E, A>;
    // (undocumented)
    readonly mapLeft: <E, A, N>(ma: EitherT<M, E, A>, f: (e: E) => N) => EitherT<M, N, A>;
    // (undocumented)
    readonly orElse: <E, A, N>(ma: EitherT<M, E, A>, onLeft: (e: E) => EitherT<M, N, A>) => EitherT<M, N, A>;
    // (undocumented)
    readonly rightM: <E, A>(ma: HKT<M, A>) => EitherT<M, E, A>;
    // (undocumented)
    readonly swap: <E, A>(ma: EitherT<M, E, A>) => EitherT<M, A, E>;
}

// @public @deprecated (undocumented)
interface EitherM1<M extends URIS> extends ApplicativeComposition12<M, URI_6> {
    // (undocumented)
    readonly alt: <E, A>(fa: EitherT1<M, E, A>, that: LazyArg<EitherT1<M, E, A>>) => EitherT1<M, E, A>;
    // (undocumented)
    readonly bimap: <E, A, N, B>(ma: EitherT1<M, E, A>, f: (e: E) => N, g: (a: A) => B) => EitherT1<M, N, B>;
    // (undocumented)
    readonly chain: <E, A, B>(ma: EitherT1<M, E, A>, f: (a: A) => EitherT1<M, E, B>) => EitherT1<M, E, B>;
    // (undocumented)
    readonly fold: <E, A, R>(ma: EitherT1<M, E, A>, onLeft: (e: E) => Kind<M, R>, onRight: (a: A) => Kind<M, R>) => Kind<M, R>;
    // (undocumented)
    readonly getOrElse: <E, A>(ma: EitherT1<M, E, A>, onLeft: (e: E) => Kind<M, A>) => Kind<M, A>;
    // (undocumented)
    readonly left: <E, A>(e: E) => EitherT1<M, E, A>;
    // (undocumented)
    readonly leftM: <E, A>(me: Kind<M, E>) => EitherT1<M, E, A>;
    // (undocumented)
    readonly mapLeft: <E, A, N>(ma: EitherT1<M, E, A>, f: (e: E) => N) => EitherT1<M, N, A>;
    // (undocumented)
    readonly orElse: <E, A, N>(ma: EitherT1<M, E, A>, onLeft: (e: E) => EitherT1<M, N, A>) => EitherT1<M, N, A>;
    // (undocumented)
    readonly rightM: <E, A>(ma: Kind<M, A>) => EitherT1<M, E, A>;
    // (undocumented)
    readonly swap: <E, A>(ma: EitherT1<M, E, A>) => EitherT1<M, A, E>;
}

// @public @deprecated (undocumented)
interface EitherM2<M extends URIS2> extends ApplicativeComposition22<M, URI_6> {
    // (undocumented)
    readonly alt: <R, E, A>(fa: EitherT2<M, R, E, A>, that: LazyArg<EitherT2<M, R, E, A>>) => EitherT2<M, R, E, A>;
    // (undocumented)
    readonly bimap: <R, E, A, N, B>(ma: EitherT2<M, R, E, A>, f: (e: E) => N, g: (a: A) => B) => EitherT2<M, R, N, B>;
    // (undocumented)
    readonly chain: <R, E, A, B>(ma: EitherT2<M, R, E, A>, f: (a: A) => EitherT2<M, R, E, B>) => EitherT2<M, R, E, B>;
    // (undocumented)
    readonly fold: <R, E, A, B>(ma: EitherT2<M, R, E, A>, onLeft: (e: E) => Kind2<M, R, B>, onRight: (a: A) => Kind2<M, R, B>) => Kind2<M, R, B>;
    // (undocumented)
    readonly getOrElse: <R, E, A>(ma: EitherT2<M, R, E, A>, onLeft: (e: E) => Kind2<M, R, A>) => Kind2<M, R, A>;
    // (undocumented)
    readonly left: <R, E, A>(e: E) => EitherT2<M, R, E, A>;
    // (undocumented)
    readonly leftM: <R, E, A>(me: Kind2<M, R, E>) => EitherT2<M, R, E, A>;
    // (undocumented)
    readonly mapLeft: <R, E, A, N>(ma: EitherT2<M, R, E, A>, f: (e: E) => N) => EitherT2<M, R, N, A>;
    // (undocumented)
    readonly orElse: <R, E, A, F>(ma: EitherT2<M, R, E, A>, onLeft: (e: E) => EitherT2<M, R, F, A>) => EitherT2<M, R, F, A>;
    // (undocumented)
    readonly rightM: <R, E, A>(ma: Kind2<M, R, A>) => EitherT2<M, R, E, A>;
    // (undocumented)
    readonly swap: <R, E, A>(ma: EitherT2<M, R, E, A>) => EitherT2<M, R, A, E>;
}

// @public @deprecated (undocumented)
interface EitherT<M, E, A> extends HKT<M, Either<E, A>> {
}

declare namespace eitherT {
    export {
        right_3 as right,
        left_3 as left,
        rightF,
        leftF,
        fromNullable_3 as fromNullable,
        fromNullableK_3 as fromNullableK,
        chainNullableK_3 as chainNullableK,
        map_9 as map,
        ap_7 as ap,
        chain_7 as chain,
        alt_7 as alt,
        bimap_4 as bimap,
        mapLeft_4 as mapLeft,
        altValidation,
        match_5 as match,
        matchE,
        getOrElse_3 as getOrElse,
        orElse_3 as orElse,
        orElseFirst,
        orLeft,
        swap_2 as swap,
        toUnion_2 as toUnion,
        getEitherM,
        EitherT,
        EitherM,
        EitherT1,
        EitherM1,
        EitherT2,
        EitherM2
    }
}
export { eitherT }

// @public @deprecated (undocumented)
type EitherT1<M extends URIS, E, A> = Kind<M, Either<E, A>>;

// @public @deprecated (undocumented)
type EitherT2<M extends URIS2, R, E, A> = Kind2<M, R, Either<E, A>>;

// @public
const elem: <A>(E: Eq<A>) => {
    (a: A): (as: Array<A>) => boolean;
    (a: A, as: Array<A>): boolean;
};

// @public
const elem_10: <A>(E: Eq<A>) => {
    (a: A): (set: Set<A>) => boolean;
    (a: A, set: Set<A>): boolean;
};

// @public (undocumented)
const elem_11: <A>(E: Eq<A>) => (a: A) => <E>(ma: These<E, A>) => boolean;

// @public (undocumented)
function elem_12<A>(E: Eq<A>): (a: A, fa: Tree<A>) => boolean;

// @public (undocumented)
function elem_2<A>(E: Eq<A>): {
    (a: A): <E>(ma: Either<E, A>) => boolean;
    <E>(a: A, ma: Either<E, A>): boolean;
};

// @public
function elem_3<A>(E: Eq<A>): {
    (a: A): (ma: Option_2<A>) => boolean;
    (a: A, ma: Option_2<A>): boolean;
};

// @public
const elem_4: <A>(E: Eq<A>) => {
    (a: A): <K>(m: Map<K, A>) => boolean;
    <K>(a: A, m: Map<K, A>): boolean;
};

// @public
function elem_5<A>(E: Eq<A>): {
    (a: A): (as: ReadonlyArray<A>) => boolean;
    (a: A, as: ReadonlyArray<A>): boolean;
};

// @public
function elem_6<A>(E: Eq<A>): {
    (a: A): <K>(m: ReadonlyMap<K, A>) => boolean;
    <K>(a: A, m: ReadonlyMap<K, A>): boolean;
};

// @public
function elem_7<A>(E: Eq<A>): {
    (a: A): (fa: ReadonlyRecord<string, A>) => boolean;
    (a: A, fa: ReadonlyRecord<string, A>): boolean;
};

// @public
function elem_8<A>(E: Eq<A>): {
    (a: A): (set: ReadonlySet<A>) => boolean;
    (a: A, set: ReadonlySet<A>): boolean;
};

// @public
const elem_9: <A>(E: Eq<A>) => {
    (a: A): (fa: Record<string, A>) => boolean;
    (a: A, fa: Record<string, A>): boolean;
};

// @public @deprecated
const empty: Array<never>;

// @public @deprecated
const empty_2: Map<never, never>;

// @public
const empty_3: ReadonlyArray<never>;

// @public (undocumented)
const empty_4: ReadonlyMap<never, never>;

// @public (undocumented)
const empty_5: ReadonlyRecord<string, never>;

// @public (undocumented)
const empty_6: ReadonlySet<never>;

// @public @deprecated
const empty_7: Record<string, never>;

// @public (undocumented)
const empty_8: Set<never>;

// @public
const empty_9 = "";

// @public (undocumented)
const endo: <A>(f: Endomorphism<A>) => (M: Magma<A>) => Magma<A>;

// @public (undocumented)
interface Endomorphism<A> {
    // (undocumented)
    (a: A): A;
}

declare namespace endomorphism {
    export {
        Endomorphism,
        URI_10 as URI,
        getSemigroup_8 as getSemigroup,
        getMonoid_6 as getMonoid
    }
}
export { endomorphism }

// @public @deprecated
interface Endomorphism_2<A> {
    // (undocumented)
    (a: A): A;
}

// @public (undocumented)
const endsWith: (searchString: string, position?: number) => (s: string) => boolean;

// @public (undocumented)
interface Eq<A> {
    // (undocumented)
    readonly equals: (x: A, y: A) => boolean;
}

declare namespace eq {
    export {
        Eq,
        fromEquals,
        struct_4 as struct,
        tuple_5 as tuple,
        contramap_2 as contramap,
        URI_8 as URI,
        eqStrict,
        getSemigroup_6 as getSemigroup,
        getMonoid_4 as getMonoid,
        Contravariant_2 as Contravariant,
        getTupleEq,
        getStructEq,
        strictEqual,
        eq_2 as eq,
        eqBoolean,
        eqString,
        eqNumber,
        eqDate
    }
}
export { eq }

// @public (undocumented)
const Eq_2: eq.Eq<boolean>;

// @public @deprecated
const eq_2: Contravariant1<URI_8>;

// @public (undocumented)
const Eq_3: eq.Eq<Date>;

// @public (undocumented)
const Eq_4: eq.Eq<number>;

// @public (undocumented)
const Eq_5: eq.Eq<Ordering>;

// @public (undocumented)
const Eq_6: eq.Eq<string>;

// @public @deprecated
const eqBoolean: Eq<boolean>;

// @public @deprecated
const eqDate: Eq<Date>;

// @public (undocumented)
const eqDate_2: eq.Eq<Date>;

// @public (undocumented)
const eqMonth: eq.Eq<Date>;

// @public @deprecated
const eqNumber: Eq<number>;

// @public @deprecated
const eqOrdering: eq.Eq<Ordering>;

// @public (undocumented)
const eqStrict: Eq<unknown>;

// @public @deprecated
const eqString: Eq<string>;

// @public (undocumented)
const equals: <A>(O: Ord<A>) => (second: A) => (first: A) => boolean;

// @public (undocumented)
const equalsDefault: <A>(compare: (first: A, second: A) => Ordering) => (x: A, y: A) => boolean;

// @public (undocumented)
const eqYear: eq.Eq<Date>;

// @public (undocumented)
const error: <A>(a: A) => IO<void>;

// @public @deprecated
const evalState: <S, A>(ma: State<S, A>, s: S) => A;

// @public @deprecated
const evalState_2: <S, R, E, A>(ma: StateReaderTaskEither<S, R, E, A>, s: S) => ReaderTaskEither<R, E, A>;

// @public
const evaluate: <S>(s: S) => <A>(ma: State<S, A>) => A;

// @public
const evaluate_2: <S>(s: S) => <R, E, A>(ma: StateReaderTaskEither<S, R, E, A>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
function evaluate_3<F extends URIS3>(F: Functor3<F>): <S>(s: S) => <R, E, A>(ma: StateT3<F, S, R, E, A>) => Kind3<F, R, E, A>;

// @public (undocumented)
function evaluate_3<F extends URIS3, E>(F: Functor3C<F, E>): <S>(s: S) => <R, A>(ma: StateT3<F, S, R, E, A>) => Kind3<F, R, E, A>;

// @public (undocumented)
function evaluate_3<F extends URIS2>(F: Functor2<F>): <S>(s: S) => <E, A>(ma: StateT2<F, S, E, A>) => Kind2<F, E, A>;

// @public (undocumented)
function evaluate_3<F extends URIS2, E>(F: Functor2C<F, E>): <S>(s: S) => <A>(ma: StateT2<F, S, E, A>) => Kind2<F, E, A>;

// @public (undocumented)
function evaluate_3<F extends URIS>(F: Functor1<F>): <S>(s: S) => <A>(ma: StateT1<F, S, A>) => Kind<F, A>;

// @public (undocumented)
function evaluate_3<F>(F: Functor<F>): <S>(s: S) => <A>(ma: StateT<F, S, A>) => HKT<F, A>;

// @public (undocumented)
const evaluate_4: <W, A>(fa: Writer<W, A>) => A;

// @public @deprecated
const evalWriter: <W, A>(fa: Writer<W, A>) => A;

// @public
const every: {
    <A, B extends A>(refinement: Refinement<A, B>): Refinement<Array<A>, Array<B>>;
    <A>(predicate: Predicate<A>): Predicate<Array<A>>;
};

// @public
function every_2<A, B extends A>(refinement: Refinement<A, B>): Refinement<ReadonlyArray<A>, ReadonlyArray<B>>;

// @public (undocumented)
function every_2<A>(predicate: Predicate<A>): Predicate<ReadonlyArray<A>>;

// @public
function every_3<A, B extends A>(refinement: Refinement<A, B>): Refinement<ReadonlyRecord<string, A>, ReadonlyRecord<string, B>>;

// @public (undocumented)
function every_3<A>(predicate: Predicate<A>): Predicate<ReadonlyRecord<string, A>>;

// @public (undocumented)
function every_4<A, B extends A>(refinement: Refinement<A, B>): Refinement<ReadonlySet<A>, ReadonlySet<B>>;

// @public (undocumented)
function every_4<A>(predicate: Predicate<A>): Predicate<ReadonlySet<A>>;

// @public
const every_5: {
    <A, B extends A>(refinement: Refinement<A, B>): Refinement<Record<string, A>, Record<string, B>>;
    <A>(predicate: Predicate<A>): Predicate<Record<string, A>>;
};

// @public (undocumented)
const every_6: {
    <A, B extends A>(refinement: Refinement<A, B>): Refinement<Set<A>, Set<B>>;
    <A>(predicate: Predicate<A>): Predicate<Set<A>>;
};

// @public
const evolve: <A, F extends { [K in keyof A]: (a: A[K]) => unknown; }>(transformations: F) => (a: A) => { [K_1 in keyof F]: ReturnType<F[K_1]>; };

// @public @deprecated
const execState: <S, A>(ma: State<S, A>, s: S) => S;

// @public @deprecated
const execState_2: <S, R, E, A>(ma: StateReaderTaskEither<S, R, E, A>, s: S) => ReaderTaskEither<R, E, S>;

// @public
const execute: <S>(s: S) => <A>(ma: State<S, A>) => S;

// @public
const execute_2: <S>(s: S) => <R, E, A>(ma: StateReaderTaskEither<S, R, E, A>) => ReaderTaskEither<R, E, S>;

// @public (undocumented)
function execute_3<F extends URIS3>(F: Functor3<F>): <S>(s: S) => <R, E, A>(ma: StateT3<F, S, R, E, A>) => Kind3<F, R, E, S>;

// @public (undocumented)
function execute_3<F extends URIS3, E>(F: Functor3C<F, E>): <S>(s: S) => <R, A>(ma: StateT3<F, S, R, E, A>) => Kind3<F, R, E, S>;

// @public (undocumented)
function execute_3<F extends URIS2>(F: Functor2<F>): <S>(s: S) => <E, A>(ma: StateT2<F, S, E, A>) => Kind2<F, E, S>;

// @public (undocumented)
function execute_3<F extends URIS2, E>(F: Functor2C<F, E>): <S>(s: S) => <A>(ma: StateT2<F, S, E, A>) => Kind2<F, E, S>;

// @public (undocumented)
function execute_3<F extends URIS>(F: Functor1<F>): <S>(s: S) => <A>(ma: StateT1<F, S, A>) => Kind<F, S>;

// @public (undocumented)
function execute_3<F>(F: Functor<F>): <S>(s: S) => <A>(ma: StateT<F, S, A>) => HKT<F, S>;

// @public (undocumented)
const execute_4: <W, A>(fa: Writer<W, A>) => W;

// @public @deprecated
const execWriter: <W, A>(fa: Writer<W, A>) => W;

// @public
const exists: <A>(predicate: Predicate<A>) => (ma: Option_2<A>) => boolean;

// @public
const exists_2: <A>(predicate: Predicate<A>) => (ma: Either<unknown, A>) => boolean;

// @public
const exists_3: <A>(predicate: Predicate<A>) => (as: Array<A>) => as is nonEmptyArray.NonEmptyArray<A>;

// @public
const exists_4: <A>(predicate: Predicate<A>) => (as: ReadonlyArray<A>) => as is readonlyNonEmptyArray.ReadonlyNonEmptyArray<A>;

// @public (undocumented)
const exists_5: <A>(predicate: Predicate<A>) => (ma: These<unknown, A>) => boolean;

// @public (undocumented)
const exists_6: <A>(predicate: Predicate<A>) => (ma: Tree<A>) => boolean;

// @public
function experiment<F extends URIS3>(F: Functor3<F>): <R, E, S>(f: (s: S) => Kind3<F, R, E, S>) => <A>(wa: Store<S, A>) => Kind3<F, R, E, A>;

// @public (undocumented)
function experiment<F extends URIS3, E>(F: Functor3C<F, E>): <R, S>(f: (s: S) => Kind3<F, R, E, S>) => <A>(wa: Store<S, A>) => Kind3<F, R, E, A>;

// @public (undocumented)
function experiment<F extends URIS2>(F: Functor2<F>): <E, S>(f: (s: S) => Kind2<F, E, S>) => <A>(wa: Store<S, A>) => Kind2<F, E, A>;

// @public (undocumented)
function experiment<F extends URIS2, E>(F: Functor2C<F, E>): <S>(f: (s: S) => Kind2<F, E, S>) => <A>(wa: Store<S, A>) => Kind2<F, E, A>;

// @public (undocumented)
function experiment<F extends URIS>(F: Functor1<F>): <S>(f: (s: S) => Kind<F, S>) => <A>(wa: Store<S, A>) => Kind<F, A>;

// @public (undocumented)
function experiment<F>(F: Functor<F>): <S>(f: (s: S) => HKT<F, S>) => <A>(wa: Store<S, A>) => HKT<F, A>;

// @public (undocumented)
const Extend: Extend1<URI_4>;

declare namespace extend {
    export {
        Extend_4 as Extend,
        Extend1,
        Extend2,
        Extend2C,
        Extend3,
        Extend3C,
        Extend4
    }
}
export { extend }

// @public (undocumented)
interface Extend1<W extends URIS> extends Functor1<W> {
    // (undocumented)
    readonly extend: <A, B>(wa: Kind<W, A>, f: (wa: Kind<W, A>) => B) => Kind<W, B>;
}

// @public (undocumented)
interface Extend2<W extends URIS2> extends Functor2<W> {
    // (undocumented)
    readonly extend: <E, A, B>(wa: Kind2<W, E, A>, f: (wa: Kind2<W, E, A>) => B) => Kind2<W, E, B>;
}

// @public (undocumented)
interface Extend2C<W extends URIS2, E> extends Functor2C<W, E> {
    // (undocumented)
    readonly extend: <A, B>(wa: Kind2<W, E, A>, f: (wa: Kind2<W, E, A>) => B) => Kind2<W, E, B>;
}

// @public (undocumented)
interface Extend3<W extends URIS3> extends Functor3<W> {
    // (undocumented)
    readonly extend: <R, E, A, B>(wa: Kind3<W, R, E, A>, f: (wa: Kind3<W, R, E, A>) => B) => Kind3<W, R, E, B>;
}

// @public (undocumented)
interface Extend3C<W extends URIS3, E> extends Functor3C<W, E> {
    // (undocumented)
    readonly extend: <R, A, B>(wa: Kind3<W, R, E, A>, f: (wa: Kind3<W, R, E, A>) => B) => Kind3<W, R, E, B>;
}

// @public (undocumented)
interface Extend4<W extends URIS4> extends Functor4<W> {
    // (undocumented)
    readonly extend: <S, R, E, A, B>(wa: Kind4<W, S, R, E, A>, f: (wa: Kind4<W, S, R, E, A>) => B) => Kind4<W, S, R, E, B>;
}

// @public (undocumented)
const extend_10: <E, A, B>(f: (wa: readonly [A, E]) => B) => (wa: readonly [A, E]) => readonly [B, E];

// @public (undocumented)
const extend_11: <E, A, B>(f: (wa: Store<E, A>) => B) => (wa: Store<E, A>) => Store<E, B>;

// @public (undocumented)
const extend_12: <A, B>(f: (wa: Tree<A>) => B) => (wa: Tree<A>) => Tree<B>;

// @public (undocumented)
const extend_13: <E, A, B>(f: (wa: [A, E]) => B) => (wa: [A, E]) => [B, E];

// @public (undocumented)
const Extend_2: Extend1<URI_7>;

// @public (undocumented)
const extend_2: <A, B>(f: (as: ReadonlyNonEmptyArray<A>) => B) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>;

// @public (undocumented)
const Extend_3: Extend2<URI_6>;

// @public (undocumented)
const extend_3: <A, B>(f: (as: NonEmptyArray<A>) => B) => (as: NonEmptyArray<A>) => NonEmptyArray<B>;

// @public (undocumented)
interface Extend_4<W> extends Functor<W> {
    // (undocumented)
    readonly extend: <A, B>(wa: HKT<W, A>, f: (wa: HKT<W, A>) => B) => HKT<W, B>;
}

// @public
const extend_4: <A, B>(f: (as: Array<A>) => B) => (as: Array<A>) => Array<B>;

// @public (undocumented)
const Extend_5: Extend1<URI_24>;

// @public (undocumented)
const extend_5: <A, B>(f: (wa: Option_2<A>) => B) => (wa: Option_2<A>) => Option_2<B>;

// @public (undocumented)
const extend_6: <E, A, B>(f: (wa: Either<E, A>) => B) => (wa: Either<E, A>) => Either<E, B>;

// @public (undocumented)
const extend_7: <A, B>(f: (wa: Identity<A>) => B) => (wa: Identity<A>) => Identity<B>;

// @public
function extend_8<F extends URIS4>(F: Extend4<F>): <S, R, E, A, B>(f: (wa: Kind4<F, S, R, E, A>) => B) => (wa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function extend_8<F extends URIS3>(F: Extend3<F>): <R, E, A, B>(f: (wa: Kind3<F, R, E, A>) => B) => (wa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function extend_8<F extends URIS3, E>(F: Extend3C<F, E>): <R, A, B>(f: (wa: Kind3<F, R, E, A>) => B) => (wa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function extend_8<F extends URIS2>(F: Extend2<F>): <E, A, B>(f: (wa: Kind2<F, E, A>) => B) => (wa: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function extend_8<F extends URIS2, E>(F: Extend2C<F, E>): <A, B>(f: (wa: Kind2<F, E, A>) => B) => (wa: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function extend_8<F extends URIS>(F: Extend1<F>): <A, B>(f: (wa: Kind<F, A>) => B) => (wa: Kind<F, A>) => Kind<F, B>;

// @public (undocumented)
function extend_8<F>(F: Extend_4<F>): <A, B>(f: (wa: HKT<F, A>) => B) => (wa: HKT<F, A>) => HKT<F, B>;

// @public (undocumented)
const extend_9: <A, B>(f: (fa: ReadonlyArray<A>) => B) => (wa: ReadonlyArray<A>) => ReadonlyArray<B>;

// @public (undocumented)
const extract: Comonad1<URI_2>['extract'];

// @public (undocumented)
const extract_2: Comonad1<URI_3>['extract'];

// @public (undocumented)
const extract_3: <A>(wa: Identity<A>) => A;

// @public (undocumented)
const extract_4: <E, A>(wa: readonly [A, E]) => A;

// @public (undocumented)
const extract_5: <E, A>(wa: Store<E, A>) => A;

// @public (undocumented)
const extract_6: <A>(wa: Tree<A>) => A;

// @public (undocumented)
const extract_7: <E, A>(wa: [A, E]) => A;

// @public
function fanIn<P extends URIS4>(P: Choice4<P>, C: Category4<P>): <S, R, A, B, C>(pac: Kind4<P, S, R, A, C>, pbc: Kind4<P, S, R, B, C>) => Kind4<P, S, R, Either<A, B>, C>;

// @public (undocumented)
function fanIn<P extends URIS3>(P: Choice3<P>, C: Category3<P>): <R, A, B, C>(pac: Kind3<P, R, A, C>, pbc: Kind3<P, R, B, C>) => Kind3<P, R, Either<A, B>, C>;

// @public (undocumented)
function fanIn<P extends URIS2>(P: Choice2<P>, C: Category2<P>): <A, B, C>(pac: Kind2<P, A, C>, pbc: Kind2<P, B, C>) => Kind2<P, Either<A, B>, C>;

// @public (undocumented)
function fanIn<P>(P: Choice<P>, C: Category<P>): <A, B, C>(pac: HKT2<P, A, C>, pbc: HKT2<P, B, C>) => HKT2<P, Either<A, B>, C>;

// @public @deprecated
function fanin<F extends URIS3>(F: Category3<F> & Choice3<F>): <R, A, B, C>(pac: Kind3<F, R, A, C>, pbc: Kind3<F, R, B, C>) => Kind3<F, R, Either<A, B>, C>;

// @public @deprecated (undocumented)
function fanin<F extends URIS2>(F: Category2<F> & Choice2<F>): <A, B, C>(pac: Kind2<F, A, C>, pbc: Kind2<F, B, C>) => Kind2<F, Either<A, B>, C>;

// @public @deprecated (undocumented)
function fanin<F>(F: Category<F> & Choice<F>): <A, B, C>(pac: HKT2<F, A, C>, pbc: HKT2<F, B, C>) => HKT2<F, Either<A, B>, C>;

// @public
function fanOut<F extends URIS4>(S: Strong4<F>, C: Category4<F>): <S, R, A, B, C>(pab: Kind4<F, S, R, A, B>, pac: Kind4<F, S, R, A, C>) => Kind4<F, S, R, A, [B, C]>;

// @public (undocumented)
function fanOut<F extends URIS3>(S: Strong3<F>, C: Category3<F>): <R, A, B, C>(pab: Kind3<F, R, A, B>, pac: Kind3<F, R, A, C>) => Kind3<F, R, A, [B, C]>;

// @public (undocumented)
function fanOut<F extends URIS2>(S: Strong2<F>, C: Category2<F>): <A, B, C>(pab: Kind2<F, A, B>, pac: Kind2<F, A, C>) => Kind2<F, A, [B, C]>;

// @public (undocumented)
function fanOut<F>(S: Strong_2<F>, C: Category<F>): <A, B, C>(pab: HKT2<F, A, B>, pac: HKT2<F, A, C>) => HKT2<F, A, [B, C]>;

// @public @deprecated
function fanout<F extends URIS4>(F: Category4<F> & Strong4<F>): <S, R, A, B, C>(pab: Kind4<F, S, R, A, B>, pac: Kind4<F, S, R, A, C>) => Kind4<F, S, R, A, [B, C]>;

// @public @deprecated (undocumented)
function fanout<F extends URIS3>(F: Category3<F> & Strong3<F>): <R, A, B, C>(pab: Kind3<F, R, A, B>, pac: Kind3<F, R, A, C>) => Kind3<F, R, A, [B, C]>;

// @public @deprecated (undocumented)
function fanout<F extends URIS2>(F: Category2<F> & Strong2<F>): <A, B, C>(pab: Kind2<F, A, B>, pac: Kind2<F, A, C>) => Kind2<F, A, [B, C]>;

// @public @deprecated (undocumented)
function fanout<F>(F: Category<F> & Strong_2<F>): <A, B, C>(pab: HKT2<F, A, B>, pac: HKT2<F, A, C>) => HKT2<F, A, [B, C]>;

// @public (undocumented)
interface Field<A> extends Ring<A> {
    // (undocumented)
    readonly degree: (a: A) => number;
    // (undocumented)
    readonly div: (x: A, y: A) => A;
    // (undocumented)
    readonly mod: (x: A, y: A) => A;
}

declare namespace field {
    export {
        gcd,
        lcm,
        Field,
        fieldNumber
    }
}
export { field }

// @public (undocumented)
const Field_2: field.Field<number>;

// @public @deprecated
const fieldNumber: Field<number>;

// @public (undocumented)
interface Filter<F> {
    // (undocumented)
    <A, B extends A>(fa: HKT<F, A>, refinement: Refinement<A, B>): HKT<F, B>;
    // (undocumented)
    <A>(fa: HKT<F, A>, predicate: Predicate<A>): HKT<F, A>;
}

// @public @deprecated
function filter<A, B extends A>(refinement: Refinement<A, B>): (as: NonEmptyArray<A>) => Option_2<NonEmptyArray<B>>;

// @public (undocumented)
function filter<A>(predicate: Predicate<A>): <B extends A>(bs: NonEmptyArray<B>) => Option_2<NonEmptyArray<B>>;

// @public (undocumented)
function filter<A>(predicate: Predicate<A>): (as: NonEmptyArray<A>) => Option_2<NonEmptyArray<A>>;

// @public (undocumented)
interface Filter1<F extends URIS> {
    // (undocumented)
    <A, B extends A>(fa: Kind<F, A>, refinement: Refinement<A, B>): Kind<F, B>;
    // (undocumented)
    <A>(fa: Kind<F, A>, predicate: Predicate<A>): Kind<F, A>;
}

// @public (undocumented)
interface Filter2<F extends URIS2> {
    // (undocumented)
    <E, A, B extends A>(fa: Kind2<F, E, A>, refinement: Refinement<A, B>): Kind2<F, E, B>;
    // (undocumented)
    <E, A>(fa: Kind2<F, E, A>, predicate: Predicate<A>): Kind2<F, E, A>;
}

// @public (undocumented)
interface Filter2C<F extends URIS2, E> {
    // (undocumented)
    <A, B extends A>(fa: Kind2<F, E, A>, refinement: Refinement<A, B>): Kind2<F, E, B>;
    // (undocumented)
    <A>(fa: Kind2<F, E, A>, predicate: Predicate<A>): Kind2<F, E, A>;
}

// @public (undocumented)
interface Filter3<F extends URIS3> {
    // (undocumented)
    <R, E, A, B extends A>(fa: Kind3<F, R, E, A>, refinement: Refinement<A, B>): Kind3<F, R, E, B>;
    // (undocumented)
    <R, E, A>(fa: Kind3<F, R, E, A>, predicate: Predicate<A>): Kind3<F, R, E, A>;
}

// @public (undocumented)
interface Filter3C<F extends URIS3, E> {
    // (undocumented)
    <R, A, B extends A>(fa: Kind3<F, R, E, A>, refinement: Refinement<A, B>): Kind3<F, R, E, B>;
    // (undocumented)
    <R, A>(fa: Kind3<F, R, E, A>, predicate: Predicate<A>): Kind3<F, R, E, A>;
}

// @public (undocumented)
interface Filter4<F extends URIS4> {
    // (undocumented)
    <S, R, E, A, B extends A>(fa: Kind4<F, S, R, E, A>, refinement: Refinement<A, B>): Kind4<F, S, R, E, B>;
    // (undocumented)
    <S, R, E, A>(fa: Kind4<F, S, R, E, A>, predicate: Predicate<A>): Kind4<F, S, R, E, A>;
}

// @public (undocumented)
const filter_10: {
    <A, B extends A>(refinement: Refinement<A, B>): <K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B>;
    <A>(predicate: Predicate<A>): <K, B extends A>(fb: ReadonlyMap<K, B>) => ReadonlyMap<K, B>;
    <A>(predicate: Predicate<A>): <K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, A>;
};

// @public
const filter_11: {
    <A, B extends A>(refinement: Refinement<A, B>): (fa: ReadonlyRecord<string, A>) => ReadonlyRecord<string, B>;
    <A>(predicate: Predicate<A>): <B extends A>(fb: ReadonlyRecord<string, B>) => ReadonlyRecord<string, B>;
    <A>(predicate: Predicate<A>): (fa: ReadonlyRecord<string, A>) => ReadonlyRecord<string, A>;
};

// @public (undocumented)
function filter_12<A, B extends A>(refinement: Refinement<A, B>): (set: ReadonlySet<A>) => ReadonlySet<B>;

// @public (undocumented)
function filter_12<A>(predicate: Predicate<A>): <B extends A>(set: ReadonlySet<B>) => ReadonlySet<B>;

// @public (undocumented)
function filter_12<A>(predicate: Predicate<A>): (set: ReadonlySet<A>) => ReadonlySet<A>;

// @public
const filter_13: {
    <A, B extends A>(refinement: Refinement<A, B>): (fa: Record<string, A>) => Record<string, B>;
    <A>(predicate: Predicate<A>): <B extends A>(fb: Record<string, B>) => Record<string, B>;
    <A>(predicate: Predicate<A>): (fa: Record<string, A>) => Record<string, A>;
};

// @public (undocumented)
function filter_14<A, B extends A>(refinement: Refinement<A, B>): (set: Set<A>) => Set<B>;

// @public (undocumented)
function filter_14<A>(predicate: Predicate<A>): <B extends A>(set: Set<B>) => Set<B>;

// @public (undocumented)
function filter_14<A>(predicate: Predicate<A>): (set: Set<A>) => Set<A>;

// @public (undocumented)
const filter_15: {
    <A, B extends A>(refinement: Refinement<A, B>): (fb: TaskOption<A>) => TaskOption<B>;
    <A>(predicate: Predicate<A>): <B extends A>(fb: TaskOption<B>) => TaskOption<B>;
    <A>(predicate: Predicate<A>): (fa: TaskOption<A>) => TaskOption<A>;
};

// @public @deprecated
function filter_2<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyNonEmptyArray<A>) => Option_2<ReadonlyNonEmptyArray<B>>;

// @public (undocumented)
function filter_2<A>(predicate: Predicate<A>): <B extends A>(bs: ReadonlyNonEmptyArray<B>) => Option_2<ReadonlyNonEmptyArray<B>>;

// @public (undocumented)
function filter_2<A>(predicate: Predicate<A>): (as: ReadonlyNonEmptyArray<A>) => Option_2<ReadonlyNonEmptyArray<A>>;

// @public
const filter_3: {
    <A, B extends A>(refinement: Refinement<A, B>): (as: Array<A>) => Array<B>;
    <A>(predicate: Predicate<A>): <B extends A>(bs: Array<B>) => Array<B>;
    <A>(predicate: Predicate<A>): (as: Array<A>) => Array<A>;
};

// @public (undocumented)
const filter_4: {
    <A, B extends A>(refinement: Refinement<A, B>): (fa: Option_2<A>) => Option_2<B>;
    <A>(predicate: Predicate<A>): <B extends A>(fb: Option_2<B>) => Option_2<B>;
    <A>(predicate: Predicate<A>): (fa: Option_2<A>) => Option_2<A>;
};

// @public
function filter_5<F extends URIS2, G extends URIS2, E>(F: Functor2<F>, G: Filterable2C<G, E>): {
    <A, B extends A>(refinement: Refinement<A, B>): <R>(fga: Kind2<F, R, Kind2<G, E, A>>) => Kind2<F, R, Kind2<G, E, B>>;
    <A>(predicate: Predicate<A>): <R, B extends A>(fgb: Kind2<F, R, Kind2<G, E, B>>) => Kind2<F, R, Kind2<G, E, B>>;
    <A>(predicate: Predicate<A>): <R>(fga: Kind2<F, R, Kind2<G, E, A>>) => Kind2<F, R, Kind2<G, E, A>>;
};

// @public (undocumented)
function filter_5<F extends URIS, G extends URIS2, E>(F: Functor1<F>, G: Filterable2C<G, E>): {
    <A, B extends A>(refinement: Refinement<A, B>): (fga: Kind<F, Kind2<G, E, A>>) => Kind<F, Kind2<G, E, B>>;
    <A>(predicate: Predicate<A>): <B extends A>(fgb: Kind<F, Kind2<G, E, B>>) => Kind<F, Kind2<G, E, B>>;
    <A>(predicate: Predicate<A>): (fga: Kind<F, Kind2<G, E, A>>) => Kind<F, Kind2<G, E, A>>;
};

// @public (undocumented)
function filter_5<F extends URIS, G extends URIS>(F: Functor1<F>, G: Filterable1<G>): {
    <A, B extends A>(refinement: Refinement<A, B>): (fga: Kind<F, Kind<G, A>>) => Kind<F, Kind<G, B>>;
    <A>(predicate: Predicate<A>): <B extends A>(fgb: Kind<F, Kind<G, B>>) => Kind<F, Kind<G, B>>;
    <A>(predicate: Predicate<A>): (fga: Kind<F, Kind<G, A>>) => Kind<F, Kind<G, A>>;
};

// @public (undocumented)
function filter_5<F, G>(F: Functor<F>, G: Filterable_3<G>): {
    <A, B extends A>(refinement: Refinement<A, B>): (fga: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, B>>;
    <A>(predicate: Predicate<A>): <B extends A>(fgb: HKT<F, HKT<G, B>>) => HKT<F, HKT<G, B>>;
    <A>(predicate: Predicate<A>): (fga: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, A>>;
};

// @public (undocumented)
const filter_6: {
    <A, B extends A>(refinement: Refinement<A, B>): (fb: IOOption<A>) => IOOption<B>;
    <A>(predicate: Predicate<A>): <B extends A>(fb: IOOption<B>) => IOOption<B>;
    <A>(predicate: Predicate<A>): (fa: IOOption<A>) => IOOption<A>;
};

// @public (undocumented)
const filter_7: {
    <A, B extends A>(refinement: Refinement<A, B>): <K>(fa: Map<K, A>) => Map<K, B>;
    <A>(predicate: Predicate<A>): <K, B extends A>(fb: Map<K, B>) => Map<K, B>;
    <A>(predicate: Predicate<A>): <K>(fa: Map<K, A>) => Map<K, A>;
};

// @public
function filter_8<F extends URIS4>(F: Filterable4<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;
    <A>(predicate: Predicate<A>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>;
};

// @public (undocumented)
function filter_8<F extends URIS3>(F: Filterable3<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
    <A>(predicate: Predicate<A>): <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
};

// @public (undocumented)
function filter_8<F extends URIS3, E>(F: Filterable3C<F, E>): {
    <A, B extends A>(refinement: Refinement<A, B>): <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
    <A>(predicate: Predicate<A>): <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
};

// @public (undocumented)
function filter_8<F extends URIS2>(F: Filterable2<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;
    <A>(predicate: Predicate<A>): <E>(fa: Kind2<F, E, A>) => Kind2<F, E, A>;
};

// @public (undocumented)
function filter_8<F extends URIS2, E>(F: Filterable2C<F, E>): {
    <A, B extends A>(refinement: Refinement<A, B>): (fa: Kind2<F, E, A>) => Kind2<F, E, B>;
    <A>(predicate: Predicate<A>): (fa: Kind2<F, E, A>) => Kind2<F, E, A>;
};

// @public (undocumented)
function filter_8<F extends URIS>(F: Filterable1<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): (fa: Kind<F, A>) => Kind<F, B>;
    <A>(predicate: Predicate<A>): (fa: Kind<F, A>) => Kind<F, A>;
};

// @public (undocumented)
function filter_8<F>(F: Filterable_3<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): (fa: HKT<F, A>) => HKT<F, B>;
    <A>(predicate: Predicate<A>): (fa: HKT<F, A>) => HKT<F, A>;
};

// @public (undocumented)
const filter_9: {
    <A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => ReadonlyArray<B>;
    <A>(predicate: Predicate<A>): <B extends A>(bs: ReadonlyArray<B>) => ReadonlyArray<B>;
    <A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => ReadonlyArray<A>;
};

// @public (undocumented)
const Filterable: Filterable1<URI_4>;

declare namespace filterable {
    export {
        filter_5 as filter,
        filterMap_3 as filterMap,
        partition_3 as partition,
        partitionMap_3 as partitionMap,
        getFilterableComposition,
        Filter,
        Partition,
        Filterable_3 as Filterable,
        Filter1,
        Partition1,
        Filterable1,
        Filter2,
        Partition2,
        Filterable2,
        Filter2C,
        Partition2C,
        Filterable2C,
        Filter3,
        Partition3,
        Filterable3,
        Filter3C,
        Partition3C,
        Filterable3C,
        Filter4,
        Partition4,
        Filterable4,
        FilterableComposition,
        FilterableComposition11,
        FilterableComposition12,
        FilterableComposition12C,
        FilterableComposition21,
        FilterableComposition2C1,
        FilterableComposition22,
        FilterableComposition22C,
        FilterableComposition23C
    }
}
export { filterable }

// @public (undocumented)
interface Filterable1<F extends URIS> extends Functor1<F>, Compactable1<F> {
    // (undocumented)
    readonly filter: Filter1<F>;
    // (undocumented)
    readonly filterMap: <A, B>(fa: Kind<F, A>, f: (a: A) => Option_2<B>) => Kind<F, B>;
    // (undocumented)
    readonly partition: Partition1<F>;
    // (undocumented)
    readonly partitionMap: <A, B, C>(fa: Kind<F, A>, f: (a: A) => Either<B, C>) => Separated<Kind<F, B>, Kind<F, C>>;
}

// @public (undocumented)
interface Filterable2<F extends URIS2> extends Functor2<F>, Compactable2<F> {
    // (undocumented)
    readonly filter: Filter2<F>;
    // (undocumented)
    readonly filterMap: <E, A, B>(fa: Kind2<F, E, A>, f: (a: A) => Option_2<B>) => Kind2<F, E, B>;
    // (undocumented)
    readonly partition: Partition2<F>;
    // (undocumented)
    readonly partitionMap: <E, A, B, C>(fa: Kind2<F, E, A>, f: (a: A) => Either<B, C>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>;
}

// @public (undocumented)
interface Filterable2C<F extends URIS2, E> extends Functor2C<F, E>, Compactable2C<F, E> {
    // (undocumented)
    readonly filter: Filter2C<F, E>;
    // (undocumented)
    readonly filterMap: <A, B>(fa: Kind2<F, E, A>, f: (a: A) => Option_2<B>) => Kind2<F, E, B>;
    // (undocumented)
    readonly partition: Partition2C<F, E>;
    // (undocumented)
    readonly partitionMap: <A, B, C>(fa: Kind2<F, E, A>, f: (a: A) => Either<B, C>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>;
}

// @public (undocumented)
interface Filterable3<F extends URIS3> extends Functor3<F>, Compactable3<F> {
    // (undocumented)
    readonly filter: Filter3<F>;
    // (undocumented)
    readonly filterMap: <R, E, A, B>(fa: Kind3<F, R, E, A>, f: (a: A) => Option_2<B>) => Kind3<F, R, E, B>;
    // (undocumented)
    readonly partition: Partition3<F>;
    // (undocumented)
    readonly partitionMap: <R, E, A, B, C>(fa: Kind3<F, R, E, A>, f: (a: A) => Either<B, C>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>;
}

// @public (undocumented)
interface Filterable3C<F extends URIS3, E> extends Functor3C<F, E>, Compactable3C<F, E> {
    // (undocumented)
    readonly filter: Filter3C<F, E>;
    // (undocumented)
    readonly filterMap: <R, A, B>(fa: Kind3<F, R, E, A>, f: (a: A) => Option_2<B>) => Kind3<F, R, E, B>;
    // (undocumented)
    readonly partition: Partition3C<F, E>;
    // (undocumented)
    readonly partitionMap: <R, A, B, C>(fa: Kind3<F, R, E, A>, f: (a: A) => Either<B, C>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>;
}

// @public (undocumented)
interface Filterable4<F extends URIS4> extends Functor4<F>, Compactable4<F> {
    // (undocumented)
    readonly filter: Filter4<F>;
    // (undocumented)
    readonly filterMap: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, f: (a: A) => Option_2<B>) => Kind4<F, S, R, E, B>;
    // (undocumented)
    readonly partition: Partition4<F>;
    // (undocumented)
    readonly partitionMap: <S, R, E, A, B, C>(fa: Kind4<F, S, R, E, A>, f: (a: A) => Either<B, C>) => Separated<Kind4<F, S, R, E, B>, Kind4<F, S, R, E, C>>;
}

// @public (undocumented)
const Filterable_10: Filterable1<URI_33>;

// @public (undocumented)
const Filterable_2: Filterable1<URI_7>;

// @public (undocumented)
interface Filterable_3<F> extends Functor<F>, Compactable_3<F> {
    readonly filter: Filter<F>;
    readonly filterMap: <A, B>(fa: HKT<F, A>, f: (a: A) => Option_2<B>) => HKT<F, B>;
    readonly partition: Partition<F>;
    readonly partitionMap: <A, B, C>(fa: HKT<F, A>, f: (a: A) => Either<B, C>) => Separated<HKT<F, B>, HKT<F, C>>;
}

// @public (undocumented)
const Filterable_4: Filterable1<URI_14>;

// @public (undocumented)
const Filterable_5: Filterable2<URI_15>;

// @public (undocumented)
const Filterable_6: Filterable1<URI_24>;

// @public (undocumented)
const Filterable_7: Filterable2<URI_25>;

// @public (undocumented)
const Filterable_8: Filterable1<URI_26>;

// @public (undocumented)
const Filterable_9: Filterable1<URI_29>;

// @public @deprecated (undocumented)
interface FilterableComposition<F, G> extends FunctorComposition<F, G>, CompactableComposition<F, G> {
    // (undocumented)
    readonly filter: <A>(fa: HKT<F, HKT<G, A>>, predicate: Predicate<A>) => HKT<F, HKT<G, A>>;
    // (undocumented)
    readonly filterMap: <A, B>(fa: HKT<F, HKT<G, A>>, f: (a: A) => Option_2<B>) => HKT<F, HKT<G, B>>;
    // (undocumented)
    readonly partition: <A>(fa: HKT<F, HKT<G, A>>, predicate: Predicate<A>) => Separated<HKT<F, HKT<G, A>>, HKT<F, HKT<G, A>>>;
    // (undocumented)
    readonly partitionMap: <A, B, C>(fa: HKT<F, HKT<G, A>>, f: (a: A) => Either<B, C>) => Separated<HKT<F, HKT<G, B>>, HKT<F, HKT<G, C>>>;
}

// @public @deprecated (undocumented)
interface FilterableComposition11<F extends URIS, G extends URIS> extends FunctorComposition11<F, G>, CompactableComposition11<F, G> {
    // (undocumented)
    readonly filter: <A>(fa: Kind<F, Kind<G, A>>, predicate: Predicate<A>) => Kind<F, Kind<G, A>>;
    // (undocumented)
    readonly filterMap: <A, B>(fa: Kind<F, Kind<G, A>>, f: (a: A) => Option_2<B>) => Kind<F, Kind<G, B>>;
    // (undocumented)
    readonly partition: <A>(fa: Kind<F, Kind<G, A>>, predicate: Predicate<A>) => Separated<Kind<F, Kind<G, A>>, Kind<F, Kind<G, A>>>;
    // (undocumented)
    readonly partitionMap: <A, B, C>(fa: Kind<F, Kind<G, A>>, f: (a: A) => Either<B, C>) => Separated<Kind<F, Kind<G, B>>, Kind<F, Kind<G, C>>>;
}

// @public @deprecated (undocumented)
interface FilterableComposition12<F extends URIS, G extends URIS2> extends FunctorComposition12<F, G>, CompactableComposition12<F, G> {
    // (undocumented)
    readonly filter: <E, A>(fa: Kind<F, Kind2<G, E, A>>, predicate: Predicate<A>) => Kind<F, Kind2<G, E, A>>;
    // (undocumented)
    readonly filterMap: <E, A, B>(fa: Kind<F, Kind2<G, E, A>>, f: (a: A) => Option_2<B>) => Kind<F, Kind2<G, E, B>>;
    // (undocumented)
    readonly partition: <E, A>(fa: Kind<F, Kind2<G, E, A>>, predicate: Predicate<A>) => Separated<Kind<F, Kind2<G, E, A>>, Kind<F, Kind2<G, E, A>>>;
    // (undocumented)
    readonly partitionMap: <E, A, B, C>(fa: Kind<F, Kind2<G, E, A>>, f: (a: A) => Either<B, C>) => Separated<Kind<F, Kind2<G, E, B>>, Kind<F, Kind2<G, E, C>>>;
}

// @public @deprecated (undocumented)
interface FilterableComposition12C<F extends URIS, G extends URIS2, E> extends FunctorComposition12C<F, G, E>, CompactableComposition12C<F, G, E> {
    // (undocumented)
    readonly filter: <A>(fa: Kind<F, Kind2<G, E, A>>, predicate: Predicate<A>) => Kind<F, Kind2<G, E, A>>;
    // (undocumented)
    readonly filterMap: <A, B>(fa: Kind<F, Kind2<G, E, A>>, f: (a: A) => Option_2<B>) => Kind<F, Kind2<G, E, B>>;
    // (undocumented)
    readonly partition: <A>(fa: Kind<F, Kind2<G, E, A>>, predicate: Predicate<A>) => Separated<Kind<F, Kind2<G, E, A>>, Kind<F, Kind2<G, E, A>>>;
    // (undocumented)
    readonly partitionMap: <A, B, C>(fa: Kind<F, Kind2<G, E, A>>, f: (a: A) => Either<B, C>) => Separated<Kind<F, Kind2<G, E, B>>, Kind<F, Kind2<G, E, C>>>;
}

// @public @deprecated (undocumented)
interface FilterableComposition21<F extends URIS2, G extends URIS> extends FunctorComposition21<F, G>, CompactableComposition21<F, G> {
    // (undocumented)
    readonly filter: <E, A>(fa: Kind2<F, E, Kind<G, A>>, predicate: Predicate<A>) => Kind2<F, E, Kind<G, A>>;
    // (undocumented)
    readonly filterMap: <E, A, B>(fa: Kind2<F, E, Kind<G, A>>, f: (a: A) => Option_2<B>) => Kind2<F, E, Kind<G, B>>;
    // (undocumented)
    readonly partition: <E, A>(fa: Kind2<F, E, Kind<G, A>>, predicate: Predicate<A>) => Separated<Kind2<F, E, Kind<G, A>>, Kind2<F, E, Kind<G, A>>>;
    // (undocumented)
    readonly partitionMap: <E, A, B, C>(fa: Kind2<F, E, Kind<G, A>>, f: (a: A) => Either<B, C>) => Separated<Kind2<F, E, Kind<G, B>>, Kind2<F, E, Kind<G, C>>>;
}

// @public @deprecated (undocumented)
interface FilterableComposition22<F extends URIS2, G extends URIS2> extends FunctorComposition22<F, G>, CompactableComposition22<F, G> {
    // (undocumented)
    readonly filter: <FE, GE, A>(fa: Kind2<F, FE, Kind2<G, GE, A>>, predicate: Predicate<A>) => Kind2<F, FE, Kind2<G, GE, A>>;
    // (undocumented)
    readonly filterMap: <FE, GE, A, B>(fa: Kind2<F, FE, Kind2<G, GE, A>>, f: (a: A) => Option_2<B>) => Kind2<F, FE, Kind2<G, GE, B>>;
    // (undocumented)
    readonly partition: <FE, GE, A>(fa: Kind2<F, FE, Kind2<G, GE, A>>, predicate: Predicate<A>) => Separated<Kind2<F, FE, Kind2<G, GE, A>>, Kind2<F, FE, Kind2<G, GE, A>>>;
    // (undocumented)
    readonly partitionMap: <FE, GE, A, B, C>(fa: Kind2<F, FE, Kind2<G, GE, A>>, f: (a: A) => Either<B, C>) => Separated<Kind2<F, FE, Kind2<G, GE, B>>, Kind2<F, FE, Kind2<G, GE, C>>>;
}

// @public @deprecated (undocumented)
interface FilterableComposition22C<F extends URIS2, G extends URIS2, E> extends FunctorComposition22<F, G>, CompactableComposition22<F, G> {
    // (undocumented)
    readonly filter: <FE, A>(fa: Kind2<F, FE, Kind2<G, E, A>>, predicate: Predicate<A>) => Kind2<F, FE, Kind2<G, E, A>>;
    // (undocumented)
    readonly filterMap: <FE, A, B>(fa: Kind2<F, FE, Kind2<G, E, A>>, f: (a: A) => Option_2<B>) => Kind2<F, FE, Kind2<G, E, B>>;
    // (undocumented)
    readonly partition: <FE, A>(fa: Kind2<F, FE, Kind2<G, E, A>>, predicate: Predicate<A>) => Separated<Kind2<F, FE, Kind2<G, E, A>>, Kind2<F, FE, Kind2<G, E, A>>>;
    // (undocumented)
    readonly partitionMap: <FE, A, B, C>(fa: Kind2<F, FE, Kind2<G, E, A>>, f: (a: A) => Either<B, C>) => Separated<Kind2<F, FE, Kind2<G, E, B>>, Kind2<F, FE, Kind2<G, E, C>>>;
}

// @public @deprecated (undocumented)
interface FilterableComposition23C<F extends URIS2, G extends URIS3, E> extends FunctorComposition23<F, G>, CompactableComposition23<F, G> {
    // (undocumented)
    readonly filter: <R, FE, A>(fa: Kind2<F, FE, Kind3<G, R, E, A>>, predicate: Predicate<A>) => Kind2<F, FE, Kind3<G, R, E, A>>;
    // (undocumented)
    readonly filterMap: <R, FE, A, B>(fa: Kind2<F, FE, Kind3<G, R, E, A>>, f: (a: A) => Option_2<B>) => Kind2<F, FE, Kind3<G, R, E, B>>;
    // (undocumented)
    readonly partition: <R, FE, A>(fa: Kind2<F, FE, Kind3<G, R, E, A>>, predicate: Predicate<A>) => Separated<Kind2<F, FE, Kind3<G, R, E, A>>, Kind2<F, FE, Kind3<G, R, E, A>>>;
    // (undocumented)
    readonly partitionMap: <R, FE, A, B, C>(fa: Kind2<F, FE, Kind3<G, R, E, A>>, f: (a: A) => Either<B, C>) => Separated<Kind2<F, FE, Kind3<G, R, E, B>>, Kind2<F, FE, Kind3<G, R, E, C>>>;
}

// @public @deprecated (undocumented)
interface FilterableComposition2C1<F extends URIS2, G extends URIS, E> extends FunctorComposition21<F, G>, CompactableComposition21<F, G> {
    // (undocumented)
    readonly filter: <A>(fa: Kind2<F, E, Kind<G, A>>, predicate: Predicate<A>) => Kind2<F, E, Kind<G, A>>;
    // (undocumented)
    readonly filterMap: <A, B>(fa: Kind2<F, E, Kind<G, A>>, f: (a: A) => Option_2<B>) => Kind2<F, E, Kind<G, B>>;
    // (undocumented)
    readonly partition: <A>(fa: Kind2<F, E, Kind<G, A>>, predicate: Predicate<A>) => Separated<Kind2<F, E, Kind<G, A>>, Kind2<F, E, Kind<G, A>>>;
    // (undocumented)
    readonly partitionMap: <A, B, C>(fa: Kind2<F, E, Kind<G, A>>, f: (a: A) => Either<B, C>) => Separated<Kind2<F, E, Kind<G, B>>, Kind2<F, E, Kind<G, C>>>;
}

// @public (undocumented)
const FilterableWithIndex: FilterableWithIndex1<URI_4, number>;

declare namespace filterableWithIndex {
    export {
        RefinementWithIndex,
        PredicateWithIndex,
        FilterWithIndex,
        PartitionWithIndex,
        FilterableWithIndex_2 as FilterableWithIndex,
        FilterWithIndex1,
        PartitionWithIndex1,
        FilterableWithIndex1,
        FilterWithIndex2,
        PartitionWithIndex2,
        FilterableWithIndex2,
        FilterWithIndex2C,
        PartitionWithIndex2C,
        FilterableWithIndex2C,
        FilterWithIndex3,
        FilterWithIndex3C,
        FilterableWithIndex3C,
        PartitionWithIndex3,
        PartitionWithIndex3C,
        FilterableWithIndex3,
        FilterWithIndex4,
        PartitionWithIndex4,
        FilterableWithIndex4
    }
}
export { filterableWithIndex }

// @public (undocumented)
interface FilterableWithIndex1<F extends URIS, I> extends FunctorWithIndex1<F, I>, Filterable1<F> {
    // (undocumented)
    readonly filterMapWithIndex: <A, B>(fa: Kind<F, A>, f: (i: I, a: A) => Option_2<B>) => Kind<F, B>;
    // (undocumented)
    readonly filterWithIndex: FilterWithIndex1<F, I>;
    // (undocumented)
    readonly partitionMapWithIndex: <A, B, C>(fa: Kind<F, A>, f: (i: I, a: A) => Either<B, C>) => Separated<Kind<F, B>, Kind<F, C>>;
    // (undocumented)
    readonly partitionWithIndex: PartitionWithIndex1<F, I>;
}

// @public (undocumented)
interface FilterableWithIndex2<F extends URIS2, I> extends FunctorWithIndex2<F, I>, Filterable2<F> {
    // (undocumented)
    readonly filterMapWithIndex: <E, A, B>(fa: Kind2<F, E, A>, f: (i: I, a: A) => Option_2<B>) => Kind2<F, E, B>;
    // (undocumented)
    readonly filterWithIndex: FilterWithIndex2<F, I>;
    // (undocumented)
    readonly partitionMapWithIndex: <E, A, B, C>(fa: Kind2<F, E, A>, f: (i: I, a: A) => Either<B, C>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>;
    // (undocumented)
    readonly partitionWithIndex: PartitionWithIndex2<F, I>;
}

// @public (undocumented)
interface FilterableWithIndex2C<F extends URIS2, I, E> extends FunctorWithIndex2C<F, I, E>, Filterable2C<F, E> {
    // (undocumented)
    readonly filterMapWithIndex: <A, B>(fa: Kind2<F, E, A>, f: (i: I, a: A) => Option_2<B>) => Kind2<F, E, B>;
    // (undocumented)
    readonly filterWithIndex: FilterWithIndex2C<F, I, E>;
    // (undocumented)
    readonly partitionMapWithIndex: <A, B, C>(fa: Kind2<F, E, A>, f: (i: I, a: A) => Either<B, C>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>;
    // (undocumented)
    readonly partitionWithIndex: PartitionWithIndex2C<F, I, E>;
}

// @public (undocumented)
interface FilterableWithIndex3<F extends URIS3, I> extends FunctorWithIndex3<F, I>, Filterable3<F> {
    // (undocumented)
    readonly filterMapWithIndex: <R, E, A, B>(fa: Kind3<F, R, E, A>, f: (i: I, a: A) => Option_2<B>) => Kind3<F, R, E, B>;
    // (undocumented)
    readonly filterWithIndex: FilterWithIndex3<F, I>;
    // (undocumented)
    readonly partitionMapWithIndex: <R, E, A, B, C>(fa: Kind3<F, R, E, A>, f: (i: I, a: A) => Either<B, C>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>;
    // (undocumented)
    readonly partitionWithIndex: PartitionWithIndex3<F, I>;
}

// @public (undocumented)
interface FilterableWithIndex3C<F extends URIS3, I, E> extends FunctorWithIndex3C<F, I, E>, Filterable3C<F, E> {
    // (undocumented)
    readonly filterMapWithIndex: <R, A, B>(fa: Kind3<F, R, E, A>, f: (i: I, a: A) => Option_2<B>) => Kind3<F, R, E, B>;
    // (undocumented)
    readonly filterWithIndex: FilterWithIndex3C<F, I, E>;
    // (undocumented)
    readonly partitionMapWithIndex: <R, A, B, C>(fa: Kind3<F, R, E, A>, f: (i: I, a: A) => Either<B, C>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>;
    // (undocumented)
    readonly partitionWithIndex: PartitionWithIndex3C<F, I, E>;
}

// @public (undocumented)
interface FilterableWithIndex4<F extends URIS4, I> extends FunctorWithIndex4<F, I>, Filterable4<F> {
    // (undocumented)
    readonly filterMapWithIndex: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, f: (i: I, a: A) => Option_2<B>) => Kind4<F, S, R, E, B>;
    // (undocumented)
    readonly filterWithIndex: FilterWithIndex4<F, I>;
    // (undocumented)
    readonly partitionMapWithIndex: <S, R, E, A, B, C>(fa: Kind4<F, S, R, E, A>, f: (i: I, a: A) => Either<B, C>) => Separated<Kind4<F, S, R, E, B>, Kind4<F, S, R, E, C>>;
    // (undocumented)
    readonly partitionWithIndex: PartitionWithIndex4<F, I>;
}

// @public (undocumented)
interface FilterableWithIndex_2<F, I> extends FunctorWithIndex_4<F, I>, Filterable_3<F> {
    // (undocumented)
    readonly filterMapWithIndex: <A, B>(fa: HKT<F, A>, f: (i: I, a: A) => Option_2<B>) => HKT<F, B>;
    // (undocumented)
    readonly filterWithIndex: FilterWithIndex<F, I>;
    // (undocumented)
    readonly partitionMapWithIndex: <A, B, C>(fa: HKT<F, A>, f: (i: I, a: A) => Either<B, C>) => Separated<HKT<F, B>, HKT<F, C>>;
    // (undocumented)
    readonly partitionWithIndex: PartitionWithIndex<F, I>;
}

// @public (undocumented)
const FilterableWithIndex_3: FilterableWithIndex1<URI_24, number>;

// @public (undocumented)
const FilterableWithIndex_4: FilterableWithIndex1<URI_26, string>;

// @public (undocumented)
const FilterableWithIndex_5: FilterableWithIndex1<URI_29, string>;

// @public
const filterE: FilterE1<"Array">;

// @public (undocumented)
interface FilterE1<G extends URIS> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, E>(predicate: (a: A) => Kind3<F, R, E, boolean>) => (ga: Kind<G, A>) => Kind3<F, R, E, Kind<G, A>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R>(predicate: (a: A) => Kind3<F, R, E, boolean>) => (ga: Kind<G, A>) => Kind3<F, R, E, Kind<G, A>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, E>(predicate: (a: A) => Kind2<F, E, boolean>) => (ga: Kind<G, A>) => Kind2<F, E, Kind<G, A>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A>(predicate: (a: A) => Kind2<F, E, boolean>) => (ga: Kind<G, A>) => Kind2<F, E, Kind<G, A>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A>(predicate: (a: A) => Kind<F, boolean>) => (ga: Kind<G, A>) => Kind<F, Kind<G, A>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A>(predicate: (a: A) => HKT<F, boolean>) => (ga: Kind<G, A>) => HKT<F, Kind<G, A>>;
}

// @public
const filterE_2: FilterE1<"ReadonlyArray">;

// @public
function filterE_3<G extends URIS>(W: Witherable1<G>): FilterE1<G>;

// @public (undocumented)
function filterE_3<G>(W: Witherable_6<G>): <F>(F: Applicative<F>) => <A>(predicate: (a: A) => HKT<F, boolean>) => (ga: HKT<G, A>) => HKT<F, HKT<G, A>>;

// @public (undocumented)
const filterFirst: <A>(predicate: Predicate<A>) => (M: Magma<A>) => Magma<A>;

// @public
const filterMap: <A, B>(f: (a: A) => Option_2<B>) => (fa: Array<A>) => Array<B>;

// @public (undocumented)
function filterMap_10<B>(E: Eq<B>): <A>(f: (a: A) => Option_2<B>) => (fa: ReadonlySet<A>) => ReadonlySet<B>;

// @public
const filterMap_11: <A, B>(f: (a: A) => Option_2<B>) => (fa: Record<string, A>) => Record<string, B>;

// @public (undocumented)
function filterMap_12<B>(E: Eq<B>): <A>(f: (a: A) => Option_2<B>) => (fa: Set<A>) => Set<B>;

// @public (undocumented)
const filterMap_13: <A, B>(f: (a: A) => Option_2<B>) => (fga: TaskOption<A>) => TaskOption<B>;

// @public (undocumented)
const filterMap_2: <A, B>(f: (a: A) => Option_2<B>) => (fa: Option_2<A>) => Option_2<B>;

// @public
function filterMap_3<F extends URIS2, G extends URIS2, E>(F: Functor2<F>, G: Filterable2C<G, E>): <A, B>(f: (a: A) => Option_2<B>) => <FE>(fga: Kind2<F, FE, Kind2<G, E, A>>) => Kind2<F, FE, Kind2<G, E, B>>;

// @public (undocumented)
function filterMap_3<F extends URIS, G extends URIS2, E>(F: Functor1<F>, G: Filterable2C<G, E>): <A, B>(f: (a: A) => Option_2<B>) => (fga: Kind<F, Kind2<G, E, A>>) => Kind<F, Kind2<G, E, B>>;

// @public (undocumented)
function filterMap_3<F extends URIS, G extends URIS>(F: Functor1<F>, G: Filterable1<G>): <A, B>(f: (a: A) => Option_2<B>) => (fga: Kind<F, Kind<G, A>>) => Kind<F, Kind<G, B>>;

// @public (undocumented)
function filterMap_3<F, G>(F: Functor<F>, G: Filterable_3<G>): <A, B>(f: (a: A) => Option_2<B>) => (fga: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, B>>;

// @public (undocumented)
const filterMap_4: <A, B>(f: (a: A) => Option_2<B>) => (fga: IOOption<A>) => IOOption<B>;

// @public (undocumented)
const filterMap_5: <A, B>(f: (a: A) => Option_2<B>) => <K>(fa: Map<K, A>) => Map<K, B>;

// @public
function filterMap_6<F extends URIS4>(F: Filterable4<F>): <A, B>(f: (a: A) => Option_2<B>) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function filterMap_6<F extends URIS3>(F: Filterable3<F>): <A, B>(f: (a: A) => Option_2<B>) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function filterMap_6<F extends URIS3, E>(F: Filterable3C<F, E>): <A, B>(f: (a: A) => Option_2<B>) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function filterMap_6<F extends URIS2>(F: Filterable2<F>): <A, B>(f: (a: A) => Option_2<B>) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function filterMap_6<F extends URIS2, E>(F: Filterable2C<F, E>): <A, B>(f: (a: A) => Option_2<B>) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function filterMap_6<F extends URIS>(F: Filterable1<F>): <A, B>(f: (a: A) => Option_2<B>) => (fa: Kind<F, A>) => Kind<F, B>;

// @public (undocumented)
function filterMap_6<F>(F: Filterable_3<F>): <A, B>(f: (a: A) => Option_2<B>) => (fa: HKT<F, A>) => HKT<F, B>;

// @public (undocumented)
const filterMap_7: <A, B>(f: (a: A) => Option_2<B>) => (fa: ReadonlyArray<A>) => ReadonlyArray<B>;

// @public (undocumented)
const filterMap_8: <A, B>(f: (a: A) => Option_2<B>) => <K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B>;

// @public
const filterMap_9: <A, B>(f: (a: A) => Option_2<B>) => (fa: ReadonlyRecord<string, A>) => ReadonlyRecord<string, B>;

// @public
const filterMapWithIndex: <A, B>(f: (i: number, a: A) => Option_2<B>) => (fa: A[]) => B[];

// @public (undocumented)
const filterMapWithIndex_2: <K, A, B>(f: (k: K, a: A) => option.Option<B>) => (fa: Map<K, A>) => Map<K, B>;

// @public
function filterMapWithIndex_3<F extends URIS4, I>(F: FilterableWithIndex4<F, I>): <A, B>(f: (i: I, a: A) => Option_2<B>) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function filterMapWithIndex_3<F extends URIS3, I>(F: FilterableWithIndex3<F, I>): <A, B>(f: (i: I, a: A) => Option_2<B>) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function filterMapWithIndex_3<F extends URIS3, I, E>(F: FilterableWithIndex3C<F, I, E>): <A, B>(f: (i: I, a: A) => Option_2<B>) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function filterMapWithIndex_3<F extends URIS2, I>(F: FilterableWithIndex2<F, I>): <A, B>(f: (i: I, a: A) => Option_2<B>) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function filterMapWithIndex_3<F extends URIS2, I, E>(F: FilterableWithIndex2C<F, I, E>): <A, B>(f: (i: I, a: A) => Option_2<B>) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function filterMapWithIndex_3<F extends URIS, I>(F: FilterableWithIndex1<F, I>): <A, B>(f: (i: I, a: A) => Option_2<B>) => (fa: Kind<F, A>) => Kind<F, B>;

// @public (undocumented)
function filterMapWithIndex_3<F, I>(F: FilterableWithIndex_2<F, I>): <A, B>(f: (i: I, a: A) => Option_2<B>) => (fa: HKT<F, A>) => HKT<F, B>;

// @public (undocumented)
const filterMapWithIndex_4: <A, B>(f: (i: number, a: A) => Option_2<B>) => (fa: readonly A[]) => readonly B[];

// @public (undocumented)
const filterMapWithIndex_5: <K, A, B>(f: (k: K, a: A) => option.Option<B>) => (fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B>;

// @public
function filterMapWithIndex_6<K extends string, A, B>(f: (key: K, a: A) => Option_2<B>): (fa: ReadonlyRecord<K, A>) => ReadonlyRecord<string, B>;

// @public
const filterMapWithIndex_7: <K extends string, A, B>(f: (key: K, a: A) => Option_2<B>) => (fa: Record<K, A>) => Record<string, B>;

// @public (undocumented)
const filterOrElse: {
    <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (self: Either<E, A>) => Either<E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(self: Either<E, B>) => Either<E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (self: Either<E, A>) => Either<E, A>;
};

// @public (undocumented)
function filterOrElse_2<M extends URIS4>(F: FromEither4<M>, M: Chain4<M>): {
    <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R, B extends A>(mb: Kind4<M, S, R, E, B>) => Kind4<M, S, R, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>;
};

// @public (undocumented)
function filterOrElse_2<M extends URIS3>(F: FromEither3<M>, M: Chain3<M>): {
    <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <R, B extends A>(mb: Kind3<M, R, E, B>) => Kind3<M, R, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>;
};

// @public (undocumented)
function filterOrElse_2<M extends URIS3, E>(F: FromEither3C<M, E>, M: Chain3C<M, E>): {
    <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>;
    <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R, B extends A>(mb: Kind3<M, R, E, B>) => Kind3<M, R, E, B>;
    <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>;
};

// @public (undocumented)
function filterOrElse_2<M extends URIS2>(F: FromEither2<M>, M: Chain2<M>): {
    <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (self: Kind2<M, E, A>) => Kind2<M, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(self: Kind2<M, E, B>) => Kind2<M, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (self: Kind2<M, E, A>) => Kind2<M, E, A>;
};

// @public (undocumented)
function filterOrElse_2<M extends URIS2, E>(F: FromEither2C<M, E>, M: Chain2C<M, E>): {
    <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: Kind2<M, E, A>) => Kind2<M, E, B>;
    <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(mb: Kind2<M, E, B>) => Kind2<M, E, B>;
    <A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Kind2<M, E, A>) => Kind2<M, E, A>;
};

// @public (undocumented)
function filterOrElse_2<M extends URIS2>(F: FromEither_4<M>, M: Chain_5<M>): {
    <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: HKT2<M, E, A>) => HKT2<M, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(mb: HKT2<M, E, B>) => HKT2<M, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: HKT2<M, E, A>) => HKT2<M, E, A>;
};

// @public (undocumented)
const filterOrElse_3: {
    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: IOEither<E, A>) => IOEither<E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(mb: IOEither<E, B>) => IOEither<E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: IOEither<E, A>) => IOEither<E, A>;
};

// @public (undocumented)
const filterOrElse_4: {
    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(ma: ReaderEither<R, E, A>) => ReaderEither<R, E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R, B extends A>(mb: ReaderEither<R, E, B>) => ReaderEither<R, E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(ma: ReaderEither<R, E, A>) => ReaderEither<R, E, A>;
};

// @public (undocumented)
const filterOrElse_5: {
    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: TaskEither<E, A>) => TaskEither<E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(mb: TaskEither<E, B>) => TaskEither<E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: TaskEither<E, A>) => TaskEither<E, A>;
};

// @public (undocumented)
const filterOrElse_6: {
    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R, B extends A>(mb: ReaderTaskEither<R, E, B>) => ReaderTaskEither<R, E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;
};

// @public (undocumented)
const filterOrElse_7: {
    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R, B extends A>(mb: StateReaderTaskEither<S, R, E, B>) => StateReaderTaskEither<S, R, E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>;
};

// @public
const filterOrElseW: {
    <A, B extends A, E2>(refinement: Refinement<A, B>, onFalse: (a: A) => E2): <E1>(ma: Either<E1, A>) => Either<E1 | E2, B>;
    <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <E1, B extends A>(mb: Either<E1, B>) => Either<E1 | E2, B>;
    <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <E1>(ma: Either<E1, A>) => Either<E1 | E2, A>;
};

// @public
const filterOrElseW_2: {
    <A, B extends A, E2>(refinement: Refinement<A, B>, onFalse: (a: A) => E2): <E1>(ma: IOEither<E1, A>) => IOEither<E1 | E2, B>;
    <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <E1, B extends A>(mb: IOEither<E1, B>) => IOEither<E1 | E2, B>;
    <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <E1>(ma: IOEither<E1, A>) => IOEither<E1 | E2, A>;
};

// @public
const filterOrElseW_3: {
    <A, B extends A, E2>(refinement: Refinement<A, B>, onFalse: (a: A) => E2): <R, E1>(ma: ReaderEither<R, E1, A>) => ReaderEither<R, E1 | E2, B>;
    <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <R, E1, B extends A>(mb: ReaderEither<R, E1, B>) => ReaderEither<R, E1 | E2, B>;
    <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <R, E1>(ma: ReaderEither<R, E1, A>) => ReaderEither<R, E1 | E2, A>;
};

// @public
const filterOrElseW_4: {
    <A, B extends A, E2>(refinement: Refinement<A, B>, onFalse: (a: A) => E2): <E1>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, B>;
    <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <E1, B extends A>(mb: TaskEither<E1, B>) => TaskEither<E1 | E2, B>;
    <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <E1>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, A>;
};

// @public
const filterOrElseW_5: {
    <A, B extends A, E2>(refinement: Refinement<A, B>, onFalse: (a: A) => E2): <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, B>;
    <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <R, E1, B extends A>(mb: ReaderTaskEither<R, E1, B>) => ReaderTaskEither<R, E1 | E2, B>;
    <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, A>;
};

// @public
const filterOrElseW_6: {
    <A, B extends A, E2>(refinement: Refinement<A, B>, onFalse: (a: A) => E2): <S, R, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, B>;
    <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <S, R, E1, B extends A>(mb: StateReaderTaskEither<S, R, E1, B>) => StateReaderTaskEither<S, R, E1 | E2, B>;
    <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <S, R, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, A>;
};

// @public (undocumented)
const filterSecond: <A>(predicate: Predicate<A>) => (M: Magma<A>) => Magma<A>;

// @public (undocumented)
interface FilterWithIndex<F, I> {
    // (undocumented)
    <A, B extends A>(fa: HKT<F, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): HKT<F, B>;
    // (undocumented)
    <A>(fa: HKT<F, A>, predicateWithIndex: PredicateWithIndex<I, A>): HKT<F, A>;
}

// @public @deprecated
const filterWithIndex: <A>(predicate: (i: number, a: A) => boolean) => (as: ReadonlyNonEmptyArray<A>) => Option_2<ReadonlyNonEmptyArray<A>>;

// @public (undocumented)
interface FilterWithIndex1<F extends URIS, I> {
    // (undocumented)
    <A, B extends A>(fa: Kind<F, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Kind<F, B>;
    // (undocumented)
    <A>(fa: Kind<F, A>, predicateWithIndex: PredicateWithIndex<I, A>): Kind<F, A>;
}

// @public (undocumented)
interface FilterWithIndex2<F extends URIS2, I> {
    // (undocumented)
    <E, A, B extends A>(fa: Kind2<F, E, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Kind2<F, E, B>;
    // (undocumented)
    <E, A>(fa: Kind2<F, E, A>, predicateWithIndex: PredicateWithIndex<I, A>): Kind2<F, E, A>;
}

// @public (undocumented)
interface FilterWithIndex2C<F extends URIS2, I, E> {
    // (undocumented)
    <A, B extends A>(fa: Kind2<F, E, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Kind2<F, E, B>;
    // (undocumented)
    <A>(fa: Kind2<F, E, A>, predicateWithIndex: PredicateWithIndex<I, A>): Kind2<F, E, A>;
}

// @public (undocumented)
interface FilterWithIndex3<F extends URIS3, I> {
    // (undocumented)
    <R, E, A, B extends A>(fa: Kind3<F, R, E, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Kind3<F, R, E, B>;
    // (undocumented)
    <R, E, A>(fa: Kind3<F, R, E, A>, predicateWithIndex: PredicateWithIndex<I, A>): Kind3<F, R, E, A>;
}

// @public (undocumented)
interface FilterWithIndex3C<F extends URIS3, I, E> {
    // (undocumented)
    <R, A, B extends A>(fa: Kind3<F, R, E, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Kind3<F, R, E, B>;
    // (undocumented)
    <R, A>(fa: Kind3<F, R, E, A>, predicateWithIndex: PredicateWithIndex<I, A>): Kind3<F, R, E, A>;
}

// @public (undocumented)
interface FilterWithIndex4<F extends URIS4, I> {
    // (undocumented)
    <S, R, E, A, B extends A>(fa: Kind4<F, S, R, E, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Kind4<F, S, R, E, B>;
    // (undocumented)
    <S, R, E, A>(fa: Kind4<F, S, R, E, A>, predicateWithIndex: PredicateWithIndex<I, A>): Kind4<F, S, R, E, A>;
}

// @public @deprecated
const filterWithIndex_2: <A>(predicate: (i: number, a: A) => boolean) => (as: NonEmptyArray<A>) => Option_2<NonEmptyArray<A>>;

// @public
const filterWithIndex_3: {
    <A, B extends A>(refinementWithIndex: RefinementWithIndex<number, A, B>): (as: Array<A>) => Array<B>;
    <A>(predicateWithIndex: PredicateWithIndex<number, A>): <B extends A>(bs: Array<B>) => Array<B>;
    <A>(predicateWithIndex: PredicateWithIndex<number, A>): (as: Array<A>) => Array<A>;
};

// @public (undocumented)
function filterWithIndex_4<K, A, B extends A>(p: (k: K, a: A) => a is B): (m: Map<K, A>) => Map<K, B>;

// @public (undocumented)
function filterWithIndex_4<K, A>(p: (k: K, a: A) => boolean): <B extends A>(m: Map<K, B>) => Map<K, B>;

// @public (undocumented)
function filterWithIndex_4<K, A>(p: (k: K, a: A) => boolean): (m: Map<K, A>) => Map<K, A>;

// @public
function filterWithIndex_5<F extends URIS4, I>(F: FilterableWithIndex4<F, I>): {
    <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;
    <A>(predicate: PredicateWithIndex<I, A>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>;
};

// @public (undocumented)
function filterWithIndex_5<F extends URIS3, I>(F: FilterableWithIndex3<F, I>): {
    <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
    <A>(predicate: PredicateWithIndex<I, A>): <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
};

// @public (undocumented)
function filterWithIndex_5<F extends URIS3, I, E>(F: FilterableWithIndex3C<F, I, E>): {
    <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
    <A>(predicate: PredicateWithIndex<I, A>): <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
};

// @public (undocumented)
function filterWithIndex_5<F extends URIS2, I>(F: FilterableWithIndex2<F, I>): {
    <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;
    <A>(predicate: PredicateWithIndex<I, A>): <E>(fa: Kind2<F, E, A>) => Kind2<F, E, A>;
};

// @public (undocumented)
function filterWithIndex_5<F extends URIS2, E, I>(F: FilterableWithIndex2C<F, I, E>): {
    <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): (fa: Kind2<F, E, A>) => Kind2<F, E, B>;
    <A>(predicate: PredicateWithIndex<I, A>): (fa: Kind2<F, E, A>) => Kind2<F, E, A>;
};

// @public (undocumented)
function filterWithIndex_5<F extends URIS, I>(F: FilterableWithIndex1<F, I>): {
    <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): (fa: Kind<F, A>) => Kind<F, B>;
    <A>(predicate: PredicateWithIndex<I, A>): (fa: Kind<F, A>) => Kind<F, A>;
};

// @public (undocumented)
function filterWithIndex_5<F, I>(F: FilterableWithIndex_2<F, I>): {
    <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): (fa: HKT<F, A>) => HKT<F, B>;
    <A>(predicate: PredicateWithIndex<I, A>): (fa: HKT<F, A>) => HKT<F, A>;
};

// @public (undocumented)
const filterWithIndex_6: {
    <A, B extends A>(refinementWithIndex: RefinementWithIndex<number, A, B>): (as: ReadonlyArray<A>) => ReadonlyArray<B>;
    <A>(predicateWithIndex: PredicateWithIndex<number, A>): <B extends A>(bs: ReadonlyArray<B>) => ReadonlyArray<B>;
    <A>(predicateWithIndex: PredicateWithIndex<number, A>): (as: ReadonlyArray<A>) => ReadonlyArray<A>;
};

// @public (undocumented)
function filterWithIndex_7<K, A, B extends A>(predicateWithIndex: (k: K, a: A) => a is B): (m: ReadonlyMap<K, A>) => ReadonlyMap<K, B>;

// @public (undocumented)
function filterWithIndex_7<K, A>(predicateWithIndex: (k: K, a: A) => boolean): <B extends A>(m: ReadonlyMap<K, B>) => ReadonlyMap<K, B>;

// @public (undocumented)
function filterWithIndex_7<K, A>(predicateWithIndex: (k: K, a: A) => boolean): (m: ReadonlyMap<K, A>) => ReadonlyMap<K, A>;

// @public
function filterWithIndex_8<K extends string, A, B extends A>(refinementWithIndex: RefinementWithIndex<K, A, B>): (fa: ReadonlyRecord<K, A>) => ReadonlyRecord<string, B>;

// @public (undocumented)
function filterWithIndex_8<K extends string, A>(predicateWithIndex: PredicateWithIndex<K, A>): <B extends A>(fb: ReadonlyRecord<K, B>) => ReadonlyRecord<string, B>;

// @public (undocumented)
function filterWithIndex_8<K extends string, A>(predicateWithIndex: PredicateWithIndex<K, A>): (fa: ReadonlyRecord<K, A>) => ReadonlyRecord<string, A>;

// @public
function filterWithIndex_9<K extends string, A, B extends A>(refinementWithIndex: RefinementWithIndex<K, A, B>): (fa: Record<K, A>) => Record<string, B>;

// @public (undocumented)
function filterWithIndex_9<K extends string, A>(predicateWithIndex: PredicateWithIndex<K, A>): <B extends A>(fb: Record<K, B>) => Record<string, B>;

// @public (undocumented)
function filterWithIndex_9<K extends string, A>(predicateWithIndex: PredicateWithIndex<K, A>): (fa: Record<K, A>) => Record<string, A>;

// @public
function findFirst<A, B extends A>(refinement: Refinement<A, B>): (as: Array<A>) => Option_2<B>;

// @public (undocumented)
function findFirst<A>(predicate: Predicate<A>): <B extends A>(bs: Array<B>) => Option_2<B>;

// @public (undocumented)
function findFirst<A>(predicate: Predicate<A>): (as: Array<A>) => Option_2<A>;

// @public
function findFirst_2<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => Option_2<B>;

// @public (undocumented)
function findFirst_2<A>(predicate: Predicate<A>): <B extends A>(bs: ReadonlyArray<B>) => Option_2<B>;

// @public (undocumented)
function findFirst_2<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Option_2<A>;

// @public
const findFirstMap: <A, B>(f: (a: A) => Option_2<B>) => (as: Array<A>) => Option_2<B>;

// @public
const findFirstMap_2: <A, B>(f: (a: A) => Option_2<B>) => (as: readonly A[]) => Option_2<B>;

// @public
const findIndex: <A>(predicate: Predicate<A>) => (as: Array<A>) => Option_2<number>;

// @public
const findIndex_2: <A>(predicate: Predicate<A>) => (as: readonly A[]) => Option_2<number>;

// @public
function findLast<A, B extends A>(refinement: Refinement<A, B>): (as: Array<A>) => Option_2<B>;

// @public (undocumented)
function findLast<A>(predicate: Predicate<A>): <B extends A>(bs: Array<B>) => Option_2<B>;

// @public (undocumented)
function findLast<A>(predicate: Predicate<A>): (as: Array<A>) => Option_2<A>;

// @public
function findLast_2<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => Option_2<B>;

// @public (undocumented)
function findLast_2<A>(predicate: Predicate<A>): <B extends A>(bs: ReadonlyArray<B>) => Option_2<B>;

// @public (undocumented)
function findLast_2<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Option_2<A>;

// @public
const findLastIndex: <A>(predicate: Predicate<A>) => (as: Array<A>) => Option_2<number>;

// @public
const findLastIndex_2: <A>(predicate: Predicate<A>) => (as: readonly A[]) => Option_2<number>;

// @public
const findLastMap: <A, B>(f: (a: A) => Option_2<B>) => (as: Array<A>) => Option_2<B>;

// @public
const findLastMap_2: <A, B>(f: (a: A) => Option_2<B>) => (as: readonly A[]) => Option_2<B>;

// @public
const first: <A = never>() => Semigroup<A>;

// @public (undocumented)
const first_2: Strong2<URI_17>['first'];

// @public (undocumented)
const flap: <A>(a: A) => <B>(fab: ReadonlyNonEmptyArray<(a: A) => B>) => ReadonlyNonEmptyArray<B>;

// @public (undocumented)
const flap_10: <A>(a: A) => <B>(fab: IO<(a: A) => B>) => IO<B>;

// @public (undocumented)
const flap_11: <A>(a: A) => <E, B>(fab: IOEither<E, (a: A) => B>) => IOEither<E, B>;

// @public (undocumented)
const flap_12: <A>(a: A) => <B>(fab: IOOption<(a: A) => B>) => IOOption<B>;

// @public (undocumented)
const flap_13: <A>(a: A) => <E, B>(fab: Map<E, (a: A) => B>) => Map<E, B>;

// @public (undocumented)
const flap_14: <A>(a: A) => <E, B>(fab: Reader<E, (a: A) => B>) => Reader<E, B>;

// @public (undocumented)
const flap_15: <A>(a: A) => <R, E, B>(fab: ReaderEither<R, E, (a: A) => B>) => ReaderEither<R, E, B>;

// @public (undocumented)
const flap_16: <A>(a: A) => <E, B>(fab: ReaderIO<E, (a: A) => B>) => ReaderIO<E, B>;

// @public (undocumented)
const flap_17: <A>(a: A) => <E, B>(fab: ReaderTask<E, (a: A) => B>) => ReaderTask<E, B>;

// @public (undocumented)
const flap_18: <A>(a: A) => <B>(fab: Task<(a: A) => B>) => Task<B>;

// @public (undocumented)
const flap_19: <A>(a: A) => <E, B>(fab: TaskEither<E, (a: A) => B>) => TaskEither<E, B>;

// @public (undocumented)
const flap_2: <A>(a: A) => <B>(fab: NonEmptyArray<(a: A) => B>) => NonEmptyArray<B>;

// @public (undocumented)
const flap_20: <A>(a: A) => <R, E, B>(fab: ReaderTaskEither<R, E, (a: A) => B>) => ReaderTaskEither<R, E, B>;

// @public (undocumented)
const flap_21: <A>(a: A) => <B>(fab: readonly ((a: A) => B)[]) => readonly B[];

// @public (undocumented)
const flap_22: <A>(a: A) => <E, B>(fab: ReadonlyMap<E, (a: A) => B>) => ReadonlyMap<E, B>;

// @public
const flap_23: <A>(a: A) => <B>(fab: Readonly<Record<string, (a: A) => B>>) => Readonly<Record<string, B>>;

// @public (undocumented)
const flap_24: <A>(a: A) => <E, B>(fab: readonly [(a: A) => B, E]) => readonly [B, E];

// @public
const flap_25: <A>(a: A) => <B>(fab: Record<string, (a: A) => B>) => Record<string, B>;

// @public (undocumented)
const flap_26: <A>(a: A) => <E, B>(fab: State<E, (a: A) => B>) => State<E, B>;

// @public (undocumented)
const flap_27: <A>(a: A) => <S, R, E, B>(fab: StateReaderTaskEither<S, R, E, (a: A) => B>) => StateReaderTaskEither<S, R, E, B>;

// @public (undocumented)
const flap_28: <A>(a: A) => <E, B>(fab: Store<E, (a: A) => B>) => Store<E, B>;

// @public (undocumented)
const flap_29: <A>(a: A) => <B>(fab: TaskOption<(a: A) => B>) => TaskOption<B>;

// @public
const flap_3: <A>(a: A) => <B>(fab: ((a: A) => B)[]) => B[];

// @public (undocumented)
const flap_30: <A>(a: A) => <E, B>(fab: TaskThese<E, (a: A) => B>) => TaskThese<E, B>;

// @public (undocumented)
const flap_31: <A>(a: A) => <E, B>(fab: These<E, (a: A) => B>) => These<E, B>;

// @public (undocumented)
const flap_32: <A>(a: A) => <E, B>(fab: Traced<E, (a: A) => B>) => Traced<E, B>;

// @public (undocumented)
const flap_33: <A>(a: A) => <B>(fab: Tree<(a: A) => B>) => Tree<B>;

// @public (undocumented)
const flap_34: <A>(a: A) => <E, B>(fab: [(a: A) => B, E]) => [B, E];

// @public (undocumented)
const flap_35: <A>(a: A) => <E, B>(fab: Writer<E, (a: A) => B>) => Writer<E, B>;

// @public (undocumented)
const flap_4: <A>(a: A) => <E, B>(fab: Separated<E, (a: A) => B>) => Separated<E, B>;

// @public (undocumented)
const flap_5: <A>(a: A) => <B>(fab: Option_2<(a: A) => B>) => Option_2<B>;

// @public (undocumented)
const flap_6: <A>(a: A) => <E, B>(fab: Either<E, (a: A) => B>) => Either<E, B>;

// @public (undocumented)
const flap_7: <A>(a: A) => <E, B>(fab: Const<E, (a: A) => B>) => Const<E, B>;

// @public (undocumented)
function flap_8<F extends URIS4>(F: Functor4<F>): <A>(a: A) => <S, R, E, B>(fab: Kind4<F, S, R, E, (a: A) => B>) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function flap_8<F extends URIS3>(F: Functor3<F>): <A>(a: A) => <R, E, B>(fab: Kind3<F, R, E, (a: A) => B>) => Kind3<F, R, E, B>;

// @public (undocumented)
function flap_8<F extends URIS2>(F: Functor2<F>): <A>(a: A) => <E, B>(fab: Kind2<F, E, (a: A) => B>) => Kind2<F, E, B>;

// @public (undocumented)
function flap_8<F extends URIS>(F: Functor1<F>): <A>(a: A) => <B>(fab: Kind<F, (a: A) => B>) => Kind<F, B>;

// @public (undocumented)
function flap_8<F>(F: Functor<F>): <A>(a: A) => <B>(fab: HKT<F, (a: A) => B>) => HKT<F, B>;

// @public (undocumented)
const flap_9: <A>(a: A) => <B>(fab: (a: A) => B) => B;

// @public (undocumented)
const flatMap: {
    <A, B>(f: (a: A, i: number) => ReadonlyNonEmptyArray<B>): (ma: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>;
    <A, B>(ma: ReadonlyNonEmptyArray<A>, f: (a: A, i: number) => ReadonlyNonEmptyArray<B>): ReadonlyNonEmptyArray<B>;
};

// @public (undocumented)
const flatMap_10: {
    <A, R2, B>(f: (a: A) => Reader<R2, B>): <R1>(ma: Reader<R1, A>) => Reader<R1 & R2, B>;
    <R1, A, R2, B>(ma: Reader<R1, A>, f: (a: A) => Reader<R2, B>): Reader<R1 & R2, B>;
};

// @public (undocumented)
const flatMap_11: {
    <A, R2, E2, B>(f: (a: A) => ReaderEither<R2, E2, B>): <R1, E1>(ma: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E1 | E2, B>;
    <R1, E1, A, R2, E2, B>(ma: ReaderEither<R1, E1, A>, f: (a: A) => ReaderEither<R2, E2, B>): ReaderEither<R1 & R2, E1 | E2, B>;
};

// @public (undocumented)
const flatMap_12: {
    <A, R2, B>(f: (a: A) => ReaderIO<R2, B>): <R1>(ma: ReaderIO<R1, A>) => ReaderIO<R1 & R2, B>;
    <R1, A, R2, B>(ma: ReaderIO<R1, A>, f: (a: A) => ReaderIO<R2, B>): ReaderIO<R1 & R2, B>;
};

// @public (undocumented)
const flatMap_13: {
    <A, R2, B>(f: (a: A) => ReaderTask<R2, B>): <R1>(ma: ReaderTask<R1, A>) => ReaderTask<R1 & R2, B>;
    <R1, A, R2, B>(ma: ReaderTask<R1, A>, f: (a: A) => ReaderTask<R2, B>): ReaderTask<R1 & R2, B>;
};

// @public (undocumented)
const flatMap_14: {
    <A, B>(f: (a: A) => Task<B>): (ma: Task<A>) => Task<B>;
    <A, B>(ma: Task<A>, f: (a: A) => Task<B>): Task<B>;
};

// @public (undocumented)
const flatMap_15: {
    <A, E2, B>(f: (a: A) => TaskEither<E2, B>): <E1>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, B>;
    <E1, A, E2, B>(ma: TaskEither<E1, A>, f: (a: A) => TaskEither<E2, B>): TaskEither<E1 | E2, B>;
};

// @public (undocumented)
const flatMap_16: {
    <A, R2, E2, B>(f: (a: A) => ReaderTaskEither<R2, E2, B>): <R1, E1>(ma: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, B>;
    <R1, E1, A, R2, E2, B>(ma: ReaderTaskEither<R1, E1, A>, f: (a: A) => ReaderTaskEither<R2, E2, B>): ReaderTaskEither<R1 & R2, E1 | E2, B>;
};

// @public
const flatMap_17: {
    <A, B>(f: (a: A, i: number) => ReadonlyArray<B>): (ma: ReadonlyArray<A>) => ReadonlyArray<B>;
    <A, B>(ma: ReadonlyArray<A>, f: (a: A, i: number) => ReadonlyArray<B>): ReadonlyArray<B>;
};

// @public (undocumented)
const flatMap_18: {
    <A, S, B>(f: (a: A) => State<S, B>): (ma: State<S, A>) => State<S, B>;
    <S, A, B>(ma: State<S, A>, f: (a: A) => State<S, B>): State<S, B>;
};

// @public (undocumented)
const flatMap_19: {
    <A, S, R2, E2, B>(f: (a: A) => StateReaderTaskEither<S, R2, E2, B>): <R1, E1>(ma: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E1 | E2, B>;
    <S, R1, E1, A, R2, E2, B>(ma: StateReaderTaskEither<S, R1, E1, A>, f: (a: A) => StateReaderTaskEither<S, R2, E2, B>): StateReaderTaskEither<S, R1 & R2, E1 | E2, B>;
};

// @public (undocumented)
const flatMap_2: {
    <A, B>(f: (a: A, i: number) => NonEmptyArray<B>): (ma: NonEmptyArray<A>) => NonEmptyArray<B>;
    <A, B>(ma: NonEmptyArray<A>, f: (a: A, i: number) => NonEmptyArray<B>): NonEmptyArray<B>;
};

// @public (undocumented)
const flatMap_20: {
    <A, B>(f: (a: A) => TaskOption<B>): (ma: TaskOption<A>) => TaskOption<B>;
    <A, B>(ma: TaskOption<A>, f: (a: A) => TaskOption<B>): TaskOption<B>;
};

// @public (undocumented)
const flatMap_21: {
    <A, B>(f: (a: A) => Tree<B>): (ma: Tree<A>) => Tree<B>;
    <A, B>(ma: Tree<A>, f: (a: A) => Tree<B>): Tree<B>;
};

// @public
const flatMap_3: {
    <A, B>(f: (a: A, i: number) => Array<B>): (ma: Array<A>) => Array<B>;
    <A, B>(ma: Array<A>, f: (a: A, i: number) => Array<B>): Array<B>;
};

// @public (undocumented)
const flatMap_4: {
    <A, B>(f: (a: A) => Option_2<B>): (ma: Option_2<A>) => Option_2<B>;
    <A, B>(ma: Option_2<A>, f: (a: A) => Option_2<B>): Option_2<B>;
};

// @public (undocumented)
const flatMap_5: {
    <A, E2, B>(f: (a: A) => Either<E2, B>): <E1>(ma: Either<E1, A>) => Either<E1 | E2, B>;
    <E1, A, E2, B>(ma: Either<E1, A>, f: (a: A) => Either<E2, B>): Either<E1 | E2, B>;
};

// @public (undocumented)
const flatMap_6: {
    <A, B>(f: (a: A) => Identity<B>): (ma: Identity<A>) => Identity<B>;
    <A, B>(ma: Identity<A>, f: (a: A) => Identity<B>): Identity<B>;
};

// @public (undocumented)
const flatMap_7: {
    <A, B>(f: (a: A) => IO<B>): (ma: IO<A>) => IO<B>;
    <A, B>(ma: IO<A>, f: (a: A) => IO<B>): IO<B>;
};

// @public (undocumented)
const flatMap_8: {
    <A, E2, B>(f: (a: A) => IOEither<E2, B>): <E1>(ma: IOEither<E1, A>) => IOEither<E1 | E2, B>;
    <E1, A, E2, B>(ma: IOEither<E1, A>, f: (a: A) => IOEither<E2, B>): IOEither<E1 | E2, B>;
};

// @public (undocumented)
const flatMap_9: {
    <A, B>(f: (a: A) => IOOption<B>): (ma: IOOption<A>) => IOOption<B>;
    <A, B>(ma: IOOption<A>, f: (a: A) => IOOption<B>): IOOption<B>;
};

// @public (undocumented)
const flatMapEither: {
    <A, E2, B>(f: (a: A) => either.Either<E2, B>): <E1>(self: IOEither<E1, A>) => IOEither<E1 | E2, B>;
    <E1, A, E2, B>(self: IOEither<E1, A>, f: (a: A) => either.Either<E2, B>): IOEither<E1 | E2, B>;
};

// @public (undocumented)
const flatMapEither_2: {
    <A, B, _>(f: (a: A) => Either<_, B>): (self: IOOption<A>) => IOOption<B>;
    <A, B, _>(self: IOOption<A>, f: (a: A) => Either<_, B>): IOOption<B>;
};

// @public (undocumented)
const flatMapEither_3: {
    <A, E2, B>(f: (a: A) => either.Either<E2, B>): <R, E1>(self: ReaderEither<R, E1, A>) => ReaderEither<R, E1 | E2, B>;
    <R, E1, A, E2, B>(self: ReaderEither<R, E1, A>, f: (a: A) => either.Either<E2, B>): ReaderEither<R, E1 | E2, B>;
};

// @public (undocumented)
const flatMapEither_4: {
    <A, E2, B>(f: (a: A) => either.Either<E2, B>): <E1>(self: TaskEither<E1, A>) => TaskEither<E1 | E2, B>;
    <E1, A, E2, B>(self: TaskEither<E1, A>, f: (a: A) => either.Either<E2, B>): TaskEither<E1 | E2, B>;
};

// @public (undocumented)
const flatMapEither_5: {
    <A, E2, B>(f: (a: A) => either.Either<E2, B>): <R, E1>(self: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, B>;
    <R, E1, A, E2, B>(self: ReaderTaskEither<R, E1, A>, f: (a: A) => either.Either<E2, B>): ReaderTaskEither<R, E1 | E2, B>;
};

// @public (undocumented)
const flatMapEither_6: {
    <A, E2, B>(f: (a: A) => Either<E2, B>): <S, R, E1>(self: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, B>;
    <S, R, E1, A, E2, B>(self: StateReaderTaskEither<S, R, E1, A>, f: (a: A) => Either<E2, B>): StateReaderTaskEither<S, R, E1 | E2, B>;
};

// @public (undocumented)
const flatMapIO: {
    <A, B>(f: (a: A) => IO<B>): <E>(self: IOEither<E, A>) => IOEither<E, B>;
    <E, A, B>(self: IOEither<E, A>, f: (a: A) => IO<B>): IOEither<E, B>;
};

// @public (undocumented)
const flatMapIO_2: {
    <A, B>(f: (a: A) => IO<B>): (self: IOOption<A>) => IOOption<B>;
    <A, B>(self: IOOption<A>, f: (a: A) => IO<B>): IOOption<B>;
};

// @public (undocumented)
const flatMapIO_3: {
    <A, B>(f: (a: A) => IO<B>): <R>(self: ReaderIO<R, A>) => ReaderIO<R, B>;
    <R, A, B>(self: ReaderIO<R, A>, f: (a: A) => IO<B>): ReaderIO<R, B>;
};

// @public (undocumented)
const flatMapIO_4: {
    <A, B>(f: (a: A) => IO<B>): <R>(self: ReaderTask<R, A>) => ReaderTask<R, B>;
    <R, A, B>(self: ReaderTask<R, A>, f: (a: A) => IO<B>): ReaderTask<R, B>;
};

// @public (undocumented)
const flatMapIO_5: {
    <A, B>(f: (a: A) => IO<B>): (self: Task<A>) => Task<B>;
    <A, B>(self: Task<A>, f: (a: A) => IO<B>): Task<B>;
};

// @public (undocumented)
const flatMapIO_6: {
    <A, B>(f: (a: A) => IO<B>): <E>(self: TaskEither<E, A>) => TaskEither<E, B>;
    <E, A, B>(self: TaskEither<E, A>, f: (a: A) => IO<B>): TaskEither<E, B>;
};

// @public (undocumented)
const flatMapIO_7: {
    <A, B>(f: (a: A) => IO<B>): <R, E>(self: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;
    <R, E, A, B>(self: ReaderTaskEither<R, E, A>, f: (a: A) => IO<B>): ReaderTaskEither<R, E, B>;
};

// @public (undocumented)
const flatMapIO_8: {
    <A, B>(f: (a: A) => IO<B>): <S, R, E>(self: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;
    <S, R, E, A, B>(self: StateReaderTaskEither<S, R, E, A>, f: (a: A) => IO<B>): StateReaderTaskEither<S, R, E, B>;
};

// @public (undocumented)
const flatMapIO_9: {
    <A, B>(f: (a: A) => IO<B>): (self: TaskOption<A>) => TaskOption<B>;
    <A, B>(self: TaskOption<A>, f: (a: A) => IO<B>): TaskOption<B>;
};

// @public (undocumented)
const flatMapIOEither: {
    <A, E2, B>(f: (a: A) => IOEither<E2, B>): <E1>(self: TaskEither<E1, A>) => TaskEither<E1 | E2, B>;
    <E1, A, E2, B>(self: TaskEither<E1, A>, f: (a: A) => IOEither<E2, B>): TaskEither<E1 | E2, B>;
};

// @public (undocumented)
const flatMapIOEither_2: {
    <A, E2, B>(f: (a: A) => IOEither<E2, B>): <R, E1>(self: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, B>;
    <R, E1, A, E2, B>(self: ReaderTaskEither<R, E1, A>, f: (a: A) => IOEither<E2, B>): ReaderTaskEither<R, E1 | E2, B>;
};

// @public (undocumented)
const flatMapIOEither_3: {
    <A, E2, B>(f: (a: A) => IOEither<E2, B>): <S, R, E1>(self: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, B>;
    <S, R, E1, A, E2, B>(self: StateReaderTaskEither<S, R, E1, A>, f: (a: A) => IOEither<E2, B>): StateReaderTaskEither<S, R, E1 | E2, B>;
};

// @public (undocumented)
const flatMapNullable: {
    <A, B, E2>(f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): <E1>(self: Either<E1, A>) => Either<E2 | E1, NonNullable<B>>;
    <E1, A, B, E2>(self: Either<E1, A>, f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): Either<E1 | E2, NonNullable<B>>;
};

// @public (undocumented)
const flatMapNullable_2: {
    <A, B, E2>(f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): <E1>(self: IOEither<E1, A>) => IOEither<E2 | E1, NonNullable<B>>;
    <E1, A, B, E2>(self: IOEither<E1, A>, f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): IOEither<E1 | E2, NonNullable<B>>;
};

// @public (undocumented)
const flatMapNullable_3: {
    <A, B>(f: (a: A) => B | null | undefined): (self: IOOption<A>) => IOOption<B>;
    <A, B>(self: IOOption<A>, f: (a: A) => B | null | undefined): IOOption<B>;
};

// @public (undocumented)
const flatMapNullable_4: {
    <A, B, E2>(f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): <R, E1>(self: ReaderEither<R, E1, A>) => ReaderEither<R, E2 | E1, NonNullable<B>>;
    <R, E1, A, B, E2>(self: ReaderEither<R, E1, A>, f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): ReaderEither<R, E1 | E2, NonNullable<B>>;
};

// @public (undocumented)
const flatMapNullable_5: {
    <A, B, E2>(f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): <E1>(self: TaskEither<E1, A>) => TaskEither<E2 | E1, NonNullable<B>>;
    <E1, A, B, E2>(self: TaskEither<E1, A>, f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): TaskEither<E1 | E2, NonNullable<B>>;
};

// @public (undocumented)
const flatMapNullable_6: {
    <A, B, E2>(f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): <R, E1>(self: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2 | E1, NonNullable<B>>;
    <R, E1, A, B, E2>(self: ReaderTaskEither<R, E1, A>, f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): ReaderTaskEither<R, E1 | E2, NonNullable<B>>;
};

// @public (undocumented)
const flatMapOption: {
    <A, B, E2>(f: (a: A) => Option_2<B>, onNone: (a: A) => E2): <E1>(self: Either<E1, A>) => Either<E2 | E1, B>;
    <E1, A, B, E2>(self: Either<E1, A>, f: (a: A) => Option_2<B>, onNone: (a: A) => E2): Either<E1 | E2, B>;
};

// @public (undocumented)
const flatMapOption_2: {
    <A, B, E2>(f: (a: A) => Option_2<B>, onNone: (a: A) => E2): <E1>(self: IOEither<E1, A>) => IOEither<E2 | E1, B>;
    <E1, A, B, E2>(self: IOEither<E1, A>, f: (a: A) => Option_2<B>, onNone: (a: A) => E2): IOEither<E1 | E2, B>;
};

// @public (undocumented)
const flatMapOption_3: {
    <A, B>(f: (a: A) => Option_2<B>): (self: IOOption<A>) => IOOption<B>;
    <A, B>(self: IOOption<A>, f: (a: A) => Option_2<B>): IOOption<B>;
};

// @public (undocumented)
const flatMapOption_4: {
    <A, B, E2>(f: (a: A) => Option_2<B>, onNone: (a: A) => E2): <R, E1>(self: ReaderEither<R, E1, A>) => ReaderEither<R, E2 | E1, B>;
    <R, E1, A, B, E2>(self: ReaderEither<R, E1, A>, f: (a: A) => Option_2<B>, onNone: (a: A) => E2): ReaderEither<R, E1 | E2, B>;
};

// @public (undocumented)
const flatMapOption_5: {
    <A, B, E2>(f: (a: A) => Option_2<B>, onNone: (a: A) => E2): <E1>(self: TaskEither<E1, A>) => TaskEither<E2 | E1, B>;
    <E1, A, B, E2>(self: TaskEither<E1, A>, f: (a: A) => Option_2<B>, onNone: (a: A) => E2): TaskEither<E1 | E2, B>;
};

// @public (undocumented)
const flatMapOption_6: {
    <A, B, E2>(f: (a: A) => Option_2<B>, onNone: (a: A) => E2): <R, E1>(self: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2 | E1, B>;
    <R, E1, A, B, E2>(self: ReaderTaskEither<R, E1, A>, f: (a: A) => Option_2<B>, onNone: (a: A) => E2): ReaderTaskEither<R, E1 | E2, B>;
};

// @public (undocumented)
const flatMapOption_7: {
    <A, E2, B>(f: (a: A) => Option_2<B>, onNone: (a: A) => E2): <S, R, E1>(self: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, B>;
    <S, R, E1, A, E2, B>(self: StateReaderTaskEither<S, R, E1, A>, f: (a: A) => Option_2<B>, onNone: (a: A) => E2): StateReaderTaskEither<S, R, E1 | E2, B>;
};

// @public (undocumented)
const flatMapReader: {
    <A, R2, B>(f: (a: A) => Reader<R2, B>): <R1, E>(self: ReaderEither<R1, E, A>) => ReaderEither<R1 & R2, E, B>;
    <R1, E, A, R2, B>(self: ReaderEither<R1, E, A>, f: (a: A) => Reader<R2, B>): ReaderEither<R1 & R2, E, B>;
};

// @public (undocumented)
const flatMapReader_2: {
    <A, R2, B>(f: (a: A) => Reader<R2, B>): <R1>(self: ReaderIO<R1, A>) => ReaderIO<R1 & R2, B>;
    <R1, A, R2, B>(self: ReaderIO<R1, A>, f: (a: A) => Reader<R2, B>): ReaderIO<R1 & R2, B>;
};

// @public (undocumented)
const flatMapReader_3: {
    <A, R2, B>(f: (a: A) => reader.Reader<R2, B>): <R1>(self: ReaderTask<R1, A>) => ReaderTask<R1 & R2, B>;
    <R1, A, R2, B>(self: ReaderTask<R1, A>, f: (a: A) => reader.Reader<R2, B>): ReaderTask<R1 & R2, B>;
};

// @public (undocumented)
const flatMapReader_4: {
    <A, R2, B>(f: (a: A) => Reader<R2, B>): <R1, E>(self: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, B>;
    <R1, E, A, R2, B>(self: ReaderTaskEither<R1, E, A>, f: (a: A) => Reader<R2, B>): ReaderTaskEither<R1 & R2, E, B>;
};

// @public (undocumented)
const flatMapReader_5: {
    <A, R2, B>(f: (a: A) => Reader<R2, B>): <S, R1, E>(self: StateReaderTaskEither<S, R1, E, A>) => StateReaderTaskEither<S, R1 & R2, E, B>;
    <S, R1, E, A, R2, B>(self: StateReaderTaskEither<S, R1, E, A>, f: (a: A) => Reader<R2, B>): StateReaderTaskEither<S, R1 & R2, E, B>;
};

// @public (undocumented)
const flatMapReaderEither: {
    <A, R2, E2, B>(f: (a: A) => ReaderEither<R2, E2, B>): <R1, E1>(self: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, B>;
    <R1, E1, A, R2, E2, B>(self: ReaderTaskEither<R1, E1, A>, f: (a: A) => ReaderEither<R2, E2, B>): ReaderTaskEither<R1 & R2, E1 | E2, B>;
};

// @public (undocumented)
const flatMapReaderIO: {
    <A, R2, B>(f: (a: A) => ReaderIO<R2, B>): <R1>(self: ReaderTask<R1, A>) => ReaderTask<R1 & R2, B>;
    <R1, A, R2, B>(self: ReaderTask<R1, A>, f: (a: A) => ReaderIO<R2, B>): ReaderTask<R1 & R2, B>;
};

// @public (undocumented)
const flatMapReaderIO_2: {
    <A, R2, B>(f: (a: A) => ReaderIO<R2, B>): <R1, E>(self: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, B>;
    <R1, E, A, R2, B>(self: ReaderTaskEither<R1, E, A>, f: (a: A) => ReaderIO<R2, B>): ReaderTaskEither<R1 & R2, E, B>;
};

// @public (undocumented)
const flatMapReaderTask: {
    <A, R2, B>(f: (a: A) => ReaderTask<R2, B>): <R1, E>(self: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, B>;
    <R1, E, A, R2, B>(self: ReaderTaskEither<R1, E, A>, f: (a: A) => ReaderTask<R2, B>): ReaderTaskEither<R1 & R2, E, B>;
};

// @public (undocumented)
const flatMapReaderTaskEither: {
    <A, R2, E2, B>(f: (a: A) => ReaderTaskEither<R2, E2, B>): <S, R1, E1>(self: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E1 | E2, B>;
    <S, R1, E1, A, R2, E2, B>(self: StateReaderTaskEither<S, R1, E1, A>, f: (a: A) => ReaderTaskEither<R2, E2, B>): StateReaderTaskEither<S, R1 & R2, E1 | E2, B>;
};

// @public (undocumented)
const flatMapState: {
    <S, A, B>(f: (a: A) => State<S, B>): <R, E>(self: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;
    <S, R, E, A, B>(self: StateReaderTaskEither<S, R, E, A>, f: (a: A) => State<S, B>): StateReaderTaskEither<S, R, E, B>;
};

// @public (undocumented)
const flatMapTask: {
    <A, B>(f: (a: A) => Task<B>): <R>(self: ReaderTask<R, A>) => ReaderTask<R, B>;
    <R, A, B>(self: ReaderTask<R, A>, f: (a: A) => Task<B>): ReaderTask<R, B>;
};

// @public (undocumented)
const flatMapTask_2: {
    <A, B>(f: (a: A) => Task<B>): <E>(self: TaskEither<E, A>) => TaskEither<E, B>;
    <E, A, B>(self: TaskEither<E, A>, f: (a: A) => Task<B>): TaskEither<E, B>;
};

// @public (undocumented)
const flatMapTask_3: {
    <A, B>(f: (a: A) => Task<B>): <R, E>(self: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;
    <R, E, A, B>(self: ReaderTaskEither<R, E, A>, f: (a: A) => Task<B>): ReaderTaskEither<R, E, B>;
};

// @public (undocumented)
const flatMapTask_4: {
    <A, B>(f: (a: A) => Task<B>): <S, R, E>(self: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;
    <S, R, E, A, B>(self: StateReaderTaskEither<S, R, E, A>, f: (a: A) => Task<B>): StateReaderTaskEither<S, R, E, B>;
};

// @public (undocumented)
const flatMapTask_5: {
    <A, B>(f: (a: A) => Task<B>): (self: TaskOption<A>) => TaskOption<B>;
    <A, B>(self: TaskOption<A>, f: (a: A) => Task<B>): TaskOption<B>;
};

// @public (undocumented)
const flatMapTaskEither: {
    <A, E2, B>(f: (a: A) => TaskEither<E2, B>): <R, E1>(self: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, B>;
    <R, E1, A, E2, B>(self: ReaderTaskEither<R, E1, A>, f: (a: A) => TaskEither<E2, B>): ReaderTaskEither<R, E1 | E2, B>;
};

// @public (undocumented)
const flatMapTaskEither_2: {
    <A, E2, B>(f: (a: A) => TaskEither<E2, B>): <S, R, E1>(self: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, B>;
    <S, R, E1, A, E2, B>(self: StateReaderTaskEither<S, R, E1, A>, f: (a: A) => TaskEither<E2, B>): StateReaderTaskEither<S, R, E1 | E2, B>;
};

// @public (undocumented)
const flatMapTaskOption: {
    <A, E2, B>(f: (a: A) => TaskOption<B>, onNone: (a: A) => E2): <E1>(self: TaskEither<E1, A>) => TaskEither<E1 | E2, B>;
    <E1, A, E2, B>(self: TaskEither<E1, A>, f: (a: A) => TaskOption<B>, onNone: (a: A) => E2): TaskEither<E1 | E2, B>;
};

// @public (undocumented)
const flatten: <A>(mma: ReadonlyNonEmptyArray<ReadonlyNonEmptyArray<A>>) => ReadonlyNonEmptyArray<A>;

// @public (undocumented)
const flatten_10: <R, A>(mma: Reader<R, Reader<R, A>>) => Reader<R, A>;

// @public (undocumented)
const flatten_11: <R, E, A>(mma: ReaderEither<R, E, ReaderEither<R, E, A>>) => ReaderEither<R, E, A>;

// @public (undocumented)
const flatten_12: <R, A>(mma: ReaderIO<R, ReaderIO<R, A>>) => ReaderIO<R, A>;

// @public (undocumented)
const flatten_13: <R, A>(mma: ReaderTask<R, ReaderTask<R, A>>) => ReaderTask<R, A>;

// @public (undocumented)
const flatten_14: <A>(mma: Task<Task<A>>) => Task<A>;

// @public (undocumented)
const flatten_15: <E, A>(mma: TaskEither<E, TaskEither<E, A>>) => TaskEither<E, A>;

// @public (undocumented)
const flatten_16: <R, E, A>(mma: ReaderTaskEither<R, E, ReaderTaskEither<R, E, A>>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const flatten_17: <A>(mma: ReadonlyArray<ReadonlyArray<A>>) => ReadonlyArray<A>;

// @public (undocumented)
const flatten_18: <E, A>(mma: State<E, State<E, A>>) => State<E, A>;

// @public (undocumented)
const flatten_19: <S, R, E, A>(mma: StateReaderTaskEither<S, R, E, StateReaderTaskEither<S, R, E, A>>) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const flatten_2: <A>(mma: NonEmptyArray<NonEmptyArray<A>>) => NonEmptyArray<A>;

// @public (undocumented)
const flatten_20: <A>(mma: TaskOption<TaskOption<A>>) => TaskOption<A>;

// @public (undocumented)
const flatten_21: <A>(mma: Tree<Tree<A>>) => Tree<A>;

// @public
const flatten_3: <A>(mma: Array<Array<A>>) => Array<A>;

// @public (undocumented)
const flatten_4: <A>(mma: Option_2<Option_2<A>>) => Option_2<A>;

// @public
const flatten_5: <E, A>(mma: Either<E, Either<E, A>>) => Either<E, A>;

// @public (undocumented)
const flatten_6: <A>(mma: Identity<Identity<A>>) => Identity<A>;

// @public (undocumented)
const flatten_7: <A>(mma: IO<IO<A>>) => IO<A>;

// @public (undocumented)
const flatten_8: <E, A>(mma: IOEither<E, IOEither<E, A>>) => IOEither<E, A>;

// @public (undocumented)
const flatten_9: <A>(mma: IOOption<IOOption<A>>) => IOOption<A>;

// @public
const flattenW: <E1, E2, A>(mma: Either<E1, Either<E2, A>>) => Either<E1 | E2, A>;

// @public
const flattenW_2: <E1, E2, A>(mma: IOEither<E1, IOEither<E2, A>>) => IOEither<E1 | E2, A>;

// @public
const flattenW_3: <R1, R2, A>(mma: Reader<R1, Reader<R2, A>>) => Reader<R1 & R2, A>;

// @public
const flattenW_4: <R1, R2, E1, E2, A>(mma: ReaderEither<R1, E1, ReaderEither<R2, E2, A>>) => ReaderEither<R1 & R2, E1 | E2, A>;

// @public
const flattenW_5: <R1, R2, A>(mma: ReaderIO<R1, ReaderIO<R2, A>>) => ReaderIO<R1 & R2, A>;

// @public
const flattenW_6: <R1, R2, A>(mma: ReaderTask<R1, ReaderTask<R2, A>>) => ReaderTask<R1 & R2, A>;

// @public
const flattenW_7: <E1, E2, A>(mma: TaskEither<E1, TaskEither<E2, A>>) => TaskEither<E1 | E2, A>;

// @public
const flattenW_8: <R1, E1, R2, E2, A>(mma: ReaderTaskEither<R1, E1, ReaderTaskEither<R2, E2, A>>) => ReaderTaskEither<R1 & R2, E1 | E2, A>;

// @public
const flattenW_9: <S, R1, E1, R2, E2, A>(mma: StateReaderTaskEither<S, R1, E1, StateReaderTaskEither<S, R2, E2, A>>) => StateReaderTaskEither<S, R1 & R2, E1 | E2, A>;

// @public
function flip<A, B, C>(f: (a: A) => (b: B) => C): (b: B) => (a: A) => C;

// @public @deprecated (undocumented)
function flip<A, B, C>(f: (a: A, b: B) => C): (b: B, a: A) => C;

// @public
function flow<A extends ReadonlyArray<unknown>, B>(ab: (...a: A) => B): (...a: A) => B;

// @public (undocumented)
function flow<A extends ReadonlyArray<unknown>, B, C>(ab: (...a: A) => B, bc: (b: B) => C): (...a: A) => C;

// @public (undocumented)
function flow<A extends ReadonlyArray<unknown>, B, C, D>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D): (...a: A) => D;

// @public (undocumented)
function flow<A extends ReadonlyArray<unknown>, B, C, D, E>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E): (...a: A) => E;

// @public (undocumented)
function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F): (...a: A) => F;

// @public (undocumented)
function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G): (...a: A) => G;

// @public (undocumented)
function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H): (...a: A) => H;

// @public (undocumented)
function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H, I>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I): (...a: A) => I;

// @public (undocumented)
function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H, I, J>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J): (...a: A) => J;

// @public @deprecated
function fold<A>(S: Semigroup<A>): {
    (startWith: A): (as: ReadonlyArray<A>) => A;
    (startWith: A, as: ReadonlyArray<A>): A;
};

// @public
const fold_10: <R, E, A, B>(onLeft: (e: E) => reader.Reader<R, B>, onRight: (a: A) => reader.Reader<R, B>) => (ma: ReaderEither<R, E, A>) => reader.Reader<R, B>;

// @public
const fold_11: <R, E, A, B>(onLeft: (e: E) => readerTask.ReaderTask<R, B>, onRight: (a: A) => readerTask.ReaderTask<R, B>) => (ma: ReaderTaskEither<R, E, A>) => readerTask.ReaderTask<R, B>;

// @public
const fold_12: <E, A, B>(onLeft: (e: E) => task.Task<B>, onRight: (a: A) => task.Task<B>) => (ma: TaskEither<E, A>) => task.Task<B>;

// @public
const fold_13: <B, A>(onNone: () => task.Task<B>, onSome: (a: A) => task.Task<B>) => (ma: TaskOption<A>) => task.Task<B>;

// @public
const fold_14: <E, B, A>(onLeft: (e: E) => task.Task<B>, onRight: (a: A) => task.Task<B>, onBoth: (e: E, a: A) => task.Task<B>) => (fa: TaskThese<E, A>) => task.Task<B>;

// @public
const fold_15: <E, A, B>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => (fa: These<E, A>) => B;

// @public
function fold_16<A, B>(f: (a: A, bs: Array<B>) => B): (tree: Tree<A>) => B;

// @public @deprecated
const fold_2: <A>(S: semigroup.Semigroup<A>) => (as: ReadonlyNonEmptyArray<A>) => A;

// @public @deprecated
const fold_3: <A>(S: Semigroup<A>) => (fa: NonEmptyArray<A>) => A;

// @public @deprecated
const fold_4: <A>(M: Monoid<A>) => (as: readonly A[]) => A;

// @public
const fold_5: <A, B>(onNone: LazyArg<B>, onSome: (a: A) => B) => (ma: Option_2<A>) => B;

// @public
const fold_6: <E, A, B>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: Either<E, A>) => B;

// @public
const fold_7: <A>(onFalse: LazyArg<A>, onTrue: LazyArg<A>) => (value: boolean) => A;

// @public
const fold_8: <E, A, B>(onLeft: (e: E) => io.IO<B>, onRight: (a: A) => io.IO<B>) => (ma: IOEither<E, A>) => io.IO<B>;

// @public
const fold_9: <B, A>(onNone: () => io.IO<B>, onSome: (a: A) => io.IO<B>) => (ma: IOOption<A>) => io.IO<B>;

// @public (undocumented)
const Foldable: Foldable1<URI_2>;

declare namespace foldable {
    export {
        reduce_6 as reduce,
        foldMap_6 as foldMap,
        reduceRight_6 as reduceRight,
        reduceM,
        intercalate_5 as intercalate,
        toReadonlyArray,
        traverse_,
        foldM,
        getFoldableComposition,
        Foldable_6 as Foldable,
        Foldable1,
        Foldable2,
        Foldable2C,
        Foldable3,
        Foldable3C,
        Foldable4,
        toArray,
        FoldableComposition,
        FoldableComposition11,
        FoldableComposition12,
        FoldableComposition12C,
        FoldableComposition21,
        FoldableComposition2C1,
        FoldableComposition22,
        FoldableComposition22C
    }
}
export { foldable }

// @public (undocumented)
interface Foldable1<F extends URIS> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <A>(fa: Kind<F, A>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <A, B>(fa: Kind<F, A>, b: B, f: (a: A, b: B) => B) => B;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Foldable2<F extends URIS2> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <E, A>(fa: Kind2<F, E, A>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <E, A, B>(fa: Kind2<F, E, A>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <E, A, B>(fa: Kind2<F, E, A>, b: B, f: (a: A, b: B) => B) => B;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Foldable2C<F extends URIS2, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <A>(fa: Kind2<F, E, A>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <A, B>(fa: Kind2<F, E, A>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <A, B>(fa: Kind2<F, E, A>, b: B, f: (a: A, b: B) => B) => B;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Foldable3<F extends URIS3> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <R, E, A>(fa: Kind3<F, R, E, A>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <R, E, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <R, E, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (a: A, b: B) => B) => B;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Foldable3C<F extends URIS3, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <R, A>(fa: Kind3<F, R, E, A>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <R, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <R, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (a: A, b: B) => B) => B;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Foldable4<F extends URIS4> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <S, R, E, A>(fa: Kind4<F, S, R, E, A>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, b: B, f: (a: A, b: B) => B) => B;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const Foldable_10: Foldable2<URI_28>;

// @public @deprecated
const Foldable_11: Foldable1<URI_29>;

// @public (undocumented)
const Foldable_12: Foldable2<URI_35>;

// @public (undocumented)
const Foldable_13: Foldable1<URI_37>;

// @public (undocumented)
const Foldable_14: Foldable2<URI_38>;

// @public (undocumented)
const Foldable_2: Foldable1<URI_3>;

// @public (undocumented)
const Foldable_3: Foldable1<URI_4>;

// @public (undocumented)
const Foldable_4: Foldable1<URI_7>;

// @public (undocumented)
const Foldable_5: Foldable2<URI_6>;

// @public (undocumented)
interface Foldable_6<F> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <A>(fa: HKT<F, A>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <A, B>(fa: HKT<F, A>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <A, B>(fa: HKT<F, A>, b: B, f: (a: A, b: B) => B) => B;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const Foldable_7: Foldable1<URI_11>;

// @public (undocumented)
const Foldable_8: Foldable1<URI_24>;

// @public @deprecated
const Foldable_9: Foldable1<URI_26>;

// @public @deprecated (undocumented)
interface FoldableComposition<F, G> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <A>(fa: HKT<F, HKT<G, A>>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <A, B>(fga: HKT<F, HKT<G, A>>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <A, B>(fa: HKT<F, HKT<G, A>>, b: B, f: (a: A, b: B) => B) => B;
}

// @public @deprecated (undocumented)
interface FoldableComposition11<F extends URIS, G extends URIS> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <A>(fa: Kind<F, Kind<G, A>>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <A, B>(fga: Kind<F, Kind<G, A>>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <A, B>(fa: Kind<F, Kind<G, A>>, b: B, f: (a: A, b: B) => B) => B;
}

// @public @deprecated (undocumented)
interface FoldableComposition12<F extends URIS, G extends URIS2> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <E, A>(fa: Kind<F, Kind2<G, E, A>>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <E, A, B>(fga: Kind<F, Kind2<G, E, A>>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <E, A, B>(fa: Kind<F, Kind2<G, E, A>>, b: B, f: (a: A, b: B) => B) => B;
}

// @public @deprecated (undocumented)
interface FoldableComposition12C<F extends URIS, G extends URIS2, E> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <A>(fa: Kind<F, Kind2<G, E, A>>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <A, B>(fga: Kind<F, Kind2<G, E, A>>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <A, B>(fa: Kind<F, Kind2<G, E, A>>, b: B, f: (a: A, b: B) => B) => B;
}

// @public @deprecated (undocumented)
interface FoldableComposition21<F extends URIS2, G extends URIS> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <E, A>(fa: Kind2<F, E, Kind<G, A>>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <E, A, B>(fga: Kind2<F, E, Kind<G, A>>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <E, A, B>(fa: Kind2<F, E, Kind<G, A>>, b: B, f: (a: A, b: B) => B) => B;
}

// @public @deprecated (undocumented)
interface FoldableComposition22<F extends URIS2, G extends URIS2> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <FE, GE, A>(fa: Kind2<F, FE, Kind2<G, GE, A>>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <FE, GE, A, B>(fga: Kind2<F, FE, Kind2<G, GE, A>>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <FE, GE, A, B>(fa: Kind2<F, FE, Kind2<G, GE, A>>, b: B, f: (a: A, b: B) => B) => B;
}

// @public @deprecated (undocumented)
interface FoldableComposition22C<F extends URIS2, G extends URIS2, E> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <FE, A>(fa: Kind2<F, FE, Kind2<G, E, A>>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <FE, A, B>(fga: Kind2<F, FE, Kind2<G, E, A>>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <FE, A, B>(fa: Kind2<F, FE, Kind2<G, E, A>>, b: B, f: (a: A, b: B) => B) => B;
}

// @public @deprecated (undocumented)
interface FoldableComposition2C1<F extends URIS2, G extends URIS, E> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <A>(fa: Kind2<F, E, Kind<G, A>>, f: (a: A) => M) => M;
    // (undocumented)
    readonly reduce: <A, B>(fga: Kind2<F, E, Kind<G, A>>, b: B, f: (b: B, a: A) => B) => B;
    // (undocumented)
    readonly reduceRight: <A, B>(fa: Kind2<F, E, Kind<G, A>>, b: B, f: (a: A, b: B) => B) => B;
}

// @public (undocumented)
const FoldableWithIndex: FoldableWithIndex1<URI_2, number>;

declare namespace foldableWithIndex {
    export {
        reduceWithIndex_4 as reduceWithIndex,
        foldMapWithIndex_4 as foldMapWithIndex,
        reduceRightWithIndex_4 as reduceRightWithIndex,
        getFoldableWithIndexComposition,
        FoldableWithIndex_4 as FoldableWithIndex,
        FoldableWithIndex1,
        FoldableWithIndex2,
        FoldableWithIndex2C,
        FoldableWithIndex3,
        FoldableWithIndex3C,
        FoldableWithIndex4,
        FoldableWithIndexComposition,
        FoldableWithIndexComposition11,
        FoldableWithIndexComposition12,
        FoldableWithIndexComposition12C,
        FoldableWithIndexComposition21,
        FoldableWithIndexComposition2C1,
        FoldableWithIndexComposition22,
        FoldableWithIndexComposition22C
    }
}
export { foldableWithIndex }

// @public (undocumented)
interface FoldableWithIndex1<F extends URIS, I> extends Foldable1<F> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(fa: Kind<F, A>, f: (i: I, a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <A, B>(fa: Kind<F, A>, b: B, f: (i: I, a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <A, B>(fa: Kind<F, A>, b: B, f: (i: I, b: B, a: A) => B) => B;
}

// @public (undocumented)
interface FoldableWithIndex2<F extends URIS2, I> extends Foldable2<F> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <E, A>(fa: Kind2<F, E, A>, f: (i: I, a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <E, A, B>(fa: Kind2<F, E, A>, b: B, f: (i: I, a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <E, A, B>(fa: Kind2<F, E, A>, b: B, f: (i: I, b: B, a: A) => B) => B;
}

// @public (undocumented)
interface FoldableWithIndex2C<F extends URIS2, I, E> extends Foldable2C<F, E> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(fa: Kind2<F, E, A>, f: (i: I, a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <A, B>(fa: Kind2<F, E, A>, b: B, f: (i: I, a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <A, B>(fa: Kind2<F, E, A>, b: B, f: (i: I, b: B, a: A) => B) => B;
}

// @public (undocumented)
interface FoldableWithIndex3<F extends URIS3, I> extends Foldable3<F> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <R, E, A>(fa: Kind3<F, R, E, A>, f: (i: I, a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <R, E, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (i: I, a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <R, E, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (i: I, b: B, a: A) => B) => B;
}

// @public (undocumented)
interface FoldableWithIndex3C<F extends URIS3, I, E> extends Foldable3C<F, E> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <R, A>(fa: Kind3<F, R, E, A>, f: (i: I, a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <R, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (i: I, a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <R, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (i: I, b: B, a: A) => B) => B;
}

// @public (undocumented)
interface FoldableWithIndex4<F extends URIS4, I> extends Foldable4<F> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <S, R, E, A>(fa: Kind4<F, S, R, E, A>, f: (i: I, a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, b: B, f: (i: I, a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, b: B, f: (i: I, b: B, a: A) => B) => B;
}

// @public (undocumented)
const FoldableWithIndex_2: FoldableWithIndex1<URI_3, number>;

// @public (undocumented)
const FoldableWithIndex_3: FoldableWithIndex1<URI_4, number>;

// @public (undocumented)
interface FoldableWithIndex_4<F, I> extends Foldable_6<F> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(fa: HKT<F, A>, f: (i: I, a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <A, B>(fa: HKT<F, A>, b: B, f: (i: I, a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <A, B>(fa: HKT<F, A>, b: B, f: (i: I, b: B, a: A) => B) => B;
}

// @public (undocumented)
const FoldableWithIndex_5: FoldableWithIndex1<URI_24, number>;

// @public @deprecated
const FoldableWithIndex_6: FoldableWithIndex1<URI_26, string>;

// @public @deprecated
const FoldableWithIndex_7: FoldableWithIndex1<URI_29, string>;

// @public @deprecated (undocumented)
interface FoldableWithIndexComposition<F, FI, G, GI> extends FoldableComposition<F, G> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(fga: HKT<F, HKT<G, A>>, f: (i: [FI, GI], a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <A, B>(fga: HKT<F, HKT<G, A>>, b: B, f: (i: [FI, GI], a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <A, B>(fga: HKT<F, HKT<G, A>>, b: B, f: (i: [FI, GI], b: B, a: A) => B) => B;
}

// @public @deprecated (undocumented)
interface FoldableWithIndexComposition11<F extends URIS, FI, G extends URIS, GI> extends FoldableComposition11<F, G> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(fga: Kind<F, Kind<G, A>>, f: (i: [FI, GI], a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <A, B>(fga: Kind<F, Kind<G, A>>, b: B, f: (i: [FI, GI], a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <A, B>(fga: Kind<F, Kind<G, A>>, b: B, f: (i: [FI, GI], b: B, a: A) => B) => B;
}

// @public @deprecated (undocumented)
interface FoldableWithIndexComposition12<F extends URIS, FI, G extends URIS2, GI> extends FoldableComposition12<F, G> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <E, A>(fga: Kind<F, Kind2<G, E, A>>, f: (i: [FI, GI], a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <E, A, B>(fga: Kind<F, Kind2<G, E, A>>, b: B, f: (i: [FI, GI], a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <E, A, B>(fga: Kind<F, Kind2<G, E, A>>, b: B, f: (i: [FI, GI], b: B, a: A) => B) => B;
}

// @public @deprecated (undocumented)
interface FoldableWithIndexComposition12C<F extends URIS, FI, G extends URIS2, GI, E> extends FoldableComposition12C<F, G, E> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(fga: Kind<F, Kind2<G, E, A>>, f: (i: [FI, GI], a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <A, B>(fga: Kind<F, Kind2<G, E, A>>, b: B, f: (i: [FI, GI], a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <A, B>(fga: Kind<F, Kind2<G, E, A>>, b: B, f: (i: [FI, GI], b: B, a: A) => B) => B;
}

// @public @deprecated (undocumented)
interface FoldableWithIndexComposition21<F extends URIS2, FI, G extends URIS, GI> extends FoldableComposition21<F, G> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <FE, A>(fga: Kind2<F, FE, Kind<G, A>>, f: (i: [FI, GI], a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <FE, A, B>(fga: Kind2<F, FE, Kind<G, A>>, b: B, f: (i: [FI, GI], a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <FE, A, B>(fga: Kind2<F, FE, Kind<G, A>>, b: B, f: (i: [FI, GI], b: B, a: A) => B) => B;
}

// @public @deprecated (undocumented)
interface FoldableWithIndexComposition22<F extends URIS2, FI, G extends URIS2, GI> extends FoldableComposition22<F, G> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <FE, GE, A>(fga: Kind2<F, FE, Kind2<G, GE, A>>, f: (i: [FI, GI], a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <FE, GE, A, B>(fga: Kind2<F, FE, Kind2<G, GE, A>>, b: B, f: (i: [FI, GI], a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <FE, GE, A, B>(fga: Kind2<F, FE, Kind2<G, GE, A>>, b: B, f: (i: [FI, GI], b: B, a: A) => B) => B;
}

// @public @deprecated (undocumented)
interface FoldableWithIndexComposition22C<F extends URIS2, FI, G extends URIS2, GI, E> extends FoldableComposition22C<F, G, E> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <FE, A>(fga: Kind2<F, FE, Kind2<G, E, A>>, f: (i: [FI, GI], a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <FE, A, B>(fga: Kind2<F, FE, Kind2<G, E, A>>, b: B, f: (i: [FI, GI], a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <FE, A, B>(fga: Kind2<F, FE, Kind2<G, E, A>>, b: B, f: (i: [FI, GI], b: B, a: A) => B) => B;
}

// @public @deprecated (undocumented)
interface FoldableWithIndexComposition2C1<F extends URIS2, FI, G extends URIS, GI, FE> extends FoldableComposition2C1<F, G, FE> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(fga: Kind2<F, FE, Kind<G, A>>, f: (i: [FI, GI], a: A) => M) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <A, B>(fga: Kind2<F, FE, Kind<G, A>>, b: B, f: (i: [FI, GI], a: A, b: B) => B) => B;
    // (undocumented)
    readonly reduceWithIndex: <A, B>(fga: Kind2<F, FE, Kind<G, A>>, b: B, f: (i: [FI, GI], b: B, a: A) => B) => B;
}

// @public
const foldLeft: <A, B>(onEmpty: LazyArg<B>, onNonEmpty: (head: A, tail: Array<A>) => B) => (as: Array<A>) => B;

// @public
const foldLeft_2: <A, B>(onEmpty: LazyArg<B>, onNonEmpty: (head: A, tail: ReadonlyArray<A>) => B) => (as: ReadonlyArray<A>) => B;

// @public @deprecated
function foldM<M extends URIS3, F extends URIS>(M: Monad3<M>, F: Foldable1<F>): <R, E, A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind3<M, R, E, B>) => Kind3<M, R, E, B>;

// @public @deprecated (undocumented)
function foldM<M extends URIS3, F extends URIS, E>(M: Monad3C<M, E>, F: Foldable1<F>): <R, A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind3<M, R, E, B>) => Kind3<M, R, E, B>;

// @public @deprecated (undocumented)
function foldM<M extends URIS2, F extends URIS>(M: Monad2<M>, F: Foldable1<F>): <E, A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind2<M, E, B>) => Kind2<M, E, B>;

// @public @deprecated (undocumented)
function foldM<M extends URIS2, F extends URIS, E>(M: Monad2C<M, E>, F: Foldable1<F>): <A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind2<M, E, B>) => Kind2<M, E, B>;

// @public @deprecated (undocumented)
function foldM<M extends URIS, F extends URIS>(M: Monad1<M>, F: Foldable1<F>): <A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind<M, B>) => Kind<M, B>;

// @public @deprecated (undocumented)
function foldM<M, F>(M: Monad_6<M>, F: Foldable_6<F>): <A, B>(fa: HKT<F, A>, b: B, f: (b: B, a: A) => HKT<M, B>) => HKT<M, B>;

// @public
const foldMap: <S>(S: semigroup.Semigroup<S>) => <A>(f: (a: A) => S) => (as: ReadonlyNonEmptyArray<A>) => S;

// @public (undocumented)
const foldMap_10: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: ReadonlyArray<A>) => M;

// @public (undocumented)
const foldMap_11: <K>(O: Ord<K>) => <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (m: ReadonlyMap<K, A>) => M;

// @public
function foldMap_12(O: Ord<string>): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: ReadonlyRecord<string, A>) => M;

// @public @deprecated
function foldMap_12<M>(M: Monoid<M>): <A>(f: (a: A) => M) => (fa: ReadonlyRecord<string, A>) => M;

// @public (undocumented)
function foldMap_13<A, M>(O: Ord<A>, M: Monoid<M>): (f: (a: A) => M) => (fa: ReadonlySet<A>) => M;

// @public (undocumented)
const foldMap_14: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: readonly [A, E]) => M;

// @public
function foldMap_15(O: Ord<string>): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Record<string, A>) => M;

// @public @deprecated
function foldMap_15<M>(M: Monoid<M>): <A>(f: (a: A) => M) => (fa: Record<string, A>) => M;

// @public (undocumented)
const foldMap_16: <A, M>(O: Ord<A>, M: Monoid<M>) => (f: (a: A) => M) => (fa: Set<A>) => M;

// @public (undocumented)
const foldMap_17: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: These<E, A>) => M;

// @public (undocumented)
const foldMap_18: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Tree<A>) => M;

// @public (undocumented)
const foldMap_19: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: [A, E]) => M;

// @public (undocumented)
const foldMap_2: <S>(S: Semigroup<S>) => <A>(f: (a: A) => S) => (fa: NonEmptyArray<A>) => S;

// @public
const foldMap_3: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Array<A>) => M;

// @public (undocumented)
const foldMap_4: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Option_2<A>) => M;

// @public
const foldMap_5: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: Either<E, A>) => M;

// @public
function foldMap_6<F extends URIS, G extends URIS>(F: Foldable1<F>, G: Foldable1<G>): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fga: Kind<F, Kind<G, A>>) => M;

// @public (undocumented)
function foldMap_6<F, G>(F: Foldable_6<F>, G: Foldable_6<G>): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fga: HKT<F, HKT<G, A>>) => M;

// @public (undocumented)
const foldMap_7: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Identity<A>) => M;

// @public (undocumented)
const foldMap_8: <K>(O: Ord<K>) => <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (m: Map<K, A>) => M;

// @public
function foldMap_9<F extends URIS4>(F: Foldable4<F>): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => M;

// @public (undocumented)
function foldMap_9<F extends URIS3>(F: Foldable3<F>): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <R, E>(fa: Kind3<F, R, E, A>) => M;

// @public (undocumented)
function foldMap_9<F extends URIS3, E>(F: Foldable3C<F, E>): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <R>(fa: Kind3<F, R, E, A>) => M;

// @public (undocumented)
function foldMap_9<F extends URIS2>(F: Foldable2<F>): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: Kind2<F, E, A>) => M;

// @public (undocumented)
function foldMap_9<F extends URIS2, E>(F: Foldable2C<F, E>): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Kind2<F, E, A>) => M;

// @public (undocumented)
function foldMap_9<F extends URIS>(F: Foldable1<F>): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Kind<F, A>) => M;

// @public (undocumented)
function foldMap_9<F>(F: Foldable_6<F>): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: HKT<F, A>) => M;

// @public
const foldMapWithIndex: <S>(S: semigroup.Semigroup<S>) => <A>(f: (i: number, a: A) => S) => (as: ReadonlyNonEmptyArray<A>) => S;

// @public
function foldMapWithIndex_10(O: Ord<string>): <M>(M: Monoid<M>) => <K extends string, A>(f: (k: K, a: A) => M) => (fa: Record<K, A>) => M;

// @public @deprecated
function foldMapWithIndex_10<M>(M: Monoid<M>): <K extends string, A>(f: (k: K, a: A) => M) => (fa: Record<K, A>) => M;

// @public (undocumented)
const foldMapWithIndex_2: <S>(S: Semigroup<S>) => <A>(f: (i: number, a: A) => S) => (fa: NonEmptyArray<A>) => S;

// @public
const foldMapWithIndex_3: <M>(M: Monoid<M>) => <A>(f: (i: number, a: A) => M) => (fa: Array<A>) => M;

// @public
function foldMapWithIndex_4<F extends URIS, I, G extends URIS, J>(F: FoldableWithIndex1<F, I>, G: FoldableWithIndex1<G, J>): <M>(M: Monoid<M>) => <A>(f: (ij: readonly [I, J], a: A) => M) => (fga: Kind<F, Kind<G, A>>) => M;

// @public (undocumented)
function foldMapWithIndex_4<F, I, G, J>(F: FoldableWithIndex_4<F, I>, G: FoldableWithIndex_4<G, J>): <M>(M: Monoid<M>) => <A>(f: (ij: readonly [I, J], a: A) => M) => (fga: HKT<F, HKT<G, A>>) => M;

// @public (undocumented)
const foldMapWithIndex_5: <K>(O: Ord<K>) => <M>(M: Monoid<M>) => <A>(f: (k: K, a: A) => M) => (m: Map<K, A>) => M;

// @public
function foldMapWithIndex_6<F extends URIS4, I>(F: FoldableWithIndex4<F, I>): <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => M;

// @public (undocumented)
function foldMapWithIndex_6<F extends URIS3, I>(F: FoldableWithIndex3<F, I>): <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => <R, E>(fa: Kind3<F, R, E, A>) => M;

// @public (undocumented)
function foldMapWithIndex_6<F extends URIS3, I, E>(F: FoldableWithIndex3C<F, I, E>): <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => <R>(fa: Kind3<F, R, E, A>) => M;

// @public (undocumented)
function foldMapWithIndex_6<F extends URIS2, I>(F: FoldableWithIndex2<F, I>): <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => <E>(fa: Kind2<F, E, A>) => M;

// @public (undocumented)
function foldMapWithIndex_6<F extends URIS2, I, E>(F: FoldableWithIndex2C<F, I, E>): <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => (fa: Kind2<F, E, A>) => M;

// @public (undocumented)
function foldMapWithIndex_6<F extends URIS, I>(F: FoldableWithIndex1<F, I>): <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => (fa: Kind<F, A>) => M;

// @public (undocumented)
function foldMapWithIndex_6<F, I>(F: FoldableWithIndex_4<F, I>): <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => (fa: HKT<F, A>) => M;

// @public (undocumented)
const foldMapWithIndex_7: <M>(M: Monoid<M>) => <A>(f: (i: number, a: A) => M) => (fa: readonly A[]) => M;

// @public (undocumented)
const foldMapWithIndex_8: <K>(O: Ord<K>) => <M>(M: Monoid<M>) => <A>(f: (k: K, a: A) => M) => (m: ReadonlyMap<K, A>) => M;

// @public
function foldMapWithIndex_9(O: Ord<string>): <M>(M: Monoid<M>) => <K extends string, A>(f: (k: K, a: A) => M) => (fa: ReadonlyRecord<K, A>) => M;

// @public @deprecated
function foldMapWithIndex_9<M>(M: Monoid<M>): <K extends string, A>(f: (k: K, a: A) => M) => (fa: ReadonlyRecord<K, A>) => M;

// @public
const foldRight: <A, B>(onEmpty: LazyArg<B>, onNonEmpty: (init: Array<A>, last: A) => B) => (as: Array<A>) => B;

// @public
const foldRight_2: <A, B>(onEmpty: LazyArg<B>, onNonEmpty: (init: ReadonlyArray<A>, last: A) => B) => (as: ReadonlyArray<A>) => B;

// @public
const foldW: <B, A, C>(onNone: LazyArg<B>, onSome: (a: A) => C) => (ma: Option_2<A>) => B | C;

// @public
const foldW_10: <E, B, A, C, D>(onLeft: (e: E) => B, onRight: (a: A) => C, onBoth: (e: E, a: A) => D) => (fa: These<E, A>) => B | C | D;

// @public
const foldW_2: <E, B, A, C>(onLeft: (e: E) => B, onRight: (a: A) => C) => (ma: Either<E, A>) => B | C;

// @public
const foldW_3: <A, B>(onFalse: LazyArg<A>, onTrue: LazyArg<B>) => (value: boolean) => A | B;

// @public
const foldW_4: <E, B, A, C>(onLeft: (e: E) => io.IO<B>, onRight: (a: A) => io.IO<C>) => (ma: IOEither<E, A>) => io.IO<B | C>;

// @public
const foldW_5: <E, R2, B, A, R3, C>(onLeft: (e: E) => reader.Reader<R2, B>, onRight: (a: A) => reader.Reader<R3, C>) => <R1>(ma: ReaderEither<R1, E, A>) => reader.Reader<R1 & R2 & R3, B | C>;

// @public
const foldW_6: <E, R2, B, A, R3, C>(onLeft: (e: E) => readerTask.ReaderTask<R2, B>, onRight: (a: A) => readerTask.ReaderTask<R3, C>) => <R1>(ma: ReaderTaskEither<R1, E, A>) => readerTask.ReaderTask<R1 & R2 & R3, B | C>;

// @public
const foldW_7: <E, B, A, C>(onLeft: (e: E) => task.Task<B>, onRight: (a: A) => task.Task<C>) => (ma: TaskEither<E, A>) => task.Task<B | C>;

// @public
const foldW_8: <B, C, A>(onNone: () => task.Task<B>, onSome: (a: A) => task.Task<C>) => (ma: TaskOption<A>) => task.Task<B | C>;

// @public
const foldW_9: <E, B, A, C, D>(onLeft: (e: E) => task.Task<B>, onRight: (a: A) => task.Task<C>, onBoth: (e: E, a: A) => task.Task<D>) => (fa: TaskThese<E, A>) => task.Task<B | C | D>;

// @public (undocumented)
type Forest<A> = Array<Tree<A>>;

// @public (undocumented)
function forever<M extends URIS4>(M: ChainRec4<M>): <S, R, E, A, B>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>;

// @public (undocumented)
function forever<M extends URIS3>(M: ChainRec3<M>): <R, E, A, B>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>;

// @public (undocumented)
function forever<M extends URIS3, E>(M: ChainRec3C<M, E>): <R, A, B>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>;

// @public (undocumented)
function forever<M extends URIS2>(M: ChainRec2<M>): <E, A, B>(ma: Kind2<M, E, A>) => Kind2<M, E, B>;

// @public (undocumented)
function forever<M extends URIS2, E>(M: ChainRec2C<M, E>): <A, B>(ma: Kind2<M, E, A>) => Kind2<M, E, B>;

// @public (undocumented)
function forever<M extends URIS>(M: ChainRec1<M>): <A, B>(ma: Kind<M, A>) => Kind<M, B>;

// @public
const fromArray: <A>(as: A[]) => Option_2<NonEmptyArray<A>>;

// @public (undocumented)
const fromArray_2: <A>(as: A[]) => Option_2<ReadonlyNonEmptyArray<A>>;

// @public (undocumented)
const fromArray_3: <A>(as: A[]) => readonly A[];

// @public @deprecated
const fromArray_4: <A>(E: Eq<A>) => (as: ReadonlyArray<A>) => ReadonlySet<A>;

// @public
const fromArray_5: <A>(E: Eq<A>) => (as: A[]) => Set<A>;

// @public (undocumented)
const fromCompare: <A>(compare: (first: A, second: A) => Ordering) => Ord<A>;

// @public (undocumented)
const FromEither: FromEither1<URI_7>;

declare namespace fromEither {
    export {
        fromOption_3 as fromOption,
        fromPredicate_4 as fromPredicate,
        fromOptionK_3 as fromOptionK,
        chainOptionK_2 as chainOptionK,
        fromEitherK_3 as fromEitherK,
        chainEitherK_2 as chainEitherK,
        chainFirstEitherK_2 as chainFirstEitherK,
        filterOrElse_2 as filterOrElse,
        FromEither_4 as FromEither,
        FromEither1,
        FromEither2,
        FromEither2C,
        FromEither3,
        FromEither3C,
        FromEither4
    }
}
export { fromEither }

// @public (undocumented)
interface FromEither1<F extends URIS> {
    // (undocumented)
    readonly fromEither: <A>(fa: Either<unknown, A>) => Kind<F, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromEither2<F extends URIS2> {
    // (undocumented)
    readonly fromEither: <E, A>(fa: Either<E, A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromEither2C<F extends URIS2, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly fromEither: <A>(fa: Either<E, A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromEither3<F extends URIS3> {
    // (undocumented)
    readonly fromEither: <E, A, R>(fa: Either<E, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromEither3C<F extends URIS3, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly fromEither: <A, R>(fa: Either<E, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromEither4<F extends URIS4> {
    // (undocumented)
    readonly fromEither: <E, A, S, R>(fa: Either<E, A>) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const FromEither_10: FromEither1<URI_24>;

// @public
const fromEither_10: <A>(fa: Either<unknown, A>) => ReadonlyArray<A>;

// @public (undocumented)
const FromEither_11: FromEither4<URI_31>;

// @public (undocumented)
const fromEither_11: <E, A, S, R = unknown>(fa: Either<E, A>) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const FromEither_12: FromEither1<URI_33>;

// @public (undocumented)
const fromEither_12: <A>(fa: Either<unknown, A>) => TaskOption<A>;

// @public (undocumented)
const FromEither_13: FromEither2<URI_34>;

// @public (undocumented)
const fromEither_13: <E, A>(fa: Either<E, A>) => TaskThese<E, A>;

// @public (undocumented)
const FromEither_14: FromEither2<URI_35>;

// @public (undocumented)
const FromEither_2: FromEither2<URI_6>;

// @public
const fromEither_2: <A>(fa: Either<unknown, A>) => Array<A>;

// @public (undocumented)
const FromEither_3: FromEither1<URI_4>;

// @public
const fromEither_3: <A>(fa: Either<unknown, A>) => Option_2<A>;

// @public (undocumented)
interface FromEither_4<F> {
    // (undocumented)
    readonly fromEither: <E, A>(e: Either<E, A>) => HKT2<F, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const fromEither_4: <E, A>(fa: Either<E, A>) => IOEither<E, A>;

// @public (undocumented)
const FromEither_5: FromEither2<URI_13>;

// @public (undocumented)
const fromEither_5: <A>(fa: Either<unknown, A>) => IOOption<A>;

// @public (undocumented)
const FromEither_6: FromEither1<URI_14>;

// @public (undocumented)
function fromEither_6<F extends URIS4>(F: Pointed4<F>): <A, S, R, E>(e: Either<unknown, A>) => Kind4<F, S, R, E, Option_2<A>>;

// @public (undocumented)
function fromEither_6<F extends URIS3>(F: Pointed3<F>): <A, R, E>(e: Either<unknown, A>) => Kind3<F, R, E, Option_2<A>>;

// @public (undocumented)
function fromEither_6<F extends URIS3, E>(F: Pointed3C<F, E>): <A, R>(e: Either<unknown, A>) => Kind3<F, R, E, Option_2<A>>;

// @public (undocumented)
function fromEither_6<F extends URIS2>(F: Pointed2<F>): <A, E>(e: Either<unknown, A>) => Kind2<F, E, Option_2<A>>;

// @public (undocumented)
function fromEither_6<F extends URIS2, E>(F: Pointed2C<F, E>): <A>(e: Either<unknown, A>) => Kind2<F, E, Option_2<A>>;

// @public (undocumented)
function fromEither_6<F extends URIS2, E>(F: Pointed2C<F, E>): <A>(e: Either<unknown, A>) => Kind2<F, E, Option_2<A>>;

// @public (undocumented)
function fromEither_6<F extends URIS>(F: Pointed1<F>): <A>(e: Either<unknown, A>) => Kind<F, Option_2<A>>;

// @public (undocumented)
function fromEither_6<F>(F: Pointed<F>): <A>(e: Either<unknown, A>) => HKT<F, Option_2<A>>;

// @public (undocumented)
const FromEither_7: FromEither3<URI_18>;

// @public (undocumented)
const fromEither_7: <E, A, R = unknown>(fa: Either<E, A>) => ReaderEither<R, E, A>;

// @public (undocumented)
const FromEither_8: FromEither2<URI_23>;

// @public (undocumented)
const fromEither_8: <E, A, R = unknown>(fa: Either<E, A>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const FromEither_9: FromEither3<URI_22>;

// @public (undocumented)
const fromEither_9: <E, A>(fa: Either<E, A>) => TaskEither<E, A>;

// @public (undocumented)
const fromEitherK: <E, A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Either<E, B>) => (...a: A) => Option_2<B>;

// @public (undocumented)
const fromEitherK_10: <A, B extends A>(getEither: (a: A) => Either<unknown, B>) => Refinement<A, B>;

// @public (undocumented)
const fromEitherK_11: <E, A extends ReadonlyArray<unknown>, B>(f: (...a: A) => either.Either<E, B>) => <S, R = unknown>(...a: A) => StateReaderTaskEither<S, R, E, B>;

// @public (undocumented)
const fromEitherK_12: <E, A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Either<E, B>) => (...a: A) => TaskOption<B>;

// @public (undocumented)
const fromEitherK_2: <E, A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Either<E, B>) => (...a: A) => Array<B>;

// @public (undocumented)
function fromEitherK_3<F extends URIS4>(F: FromEither4<F>): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => Either<E, B>) => <S, R>(...a: A) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function fromEitherK_3<F extends URIS3>(F: FromEither3<F>): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => Either<E, B>) => <R>(...a: A) => Kind3<F, R, E, B>;

// @public (undocumented)
function fromEitherK_3<F extends URIS3, E>(F: FromEither3C<F, E>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Either<E, B>) => <R>(...a: A) => Kind3<F, R, E, B>;

// @public (undocumented)
function fromEitherK_3<F extends URIS2>(F: FromEither2<F>): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => Either<E, B>) => (...a: A) => Kind2<F, E, B>;

// @public (undocumented)
function fromEitherK_3<F extends URIS2, E>(F: FromEither2C<F, E>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Either<E, B>) => (...a: A) => Kind2<F, E, B>;

// @public (undocumented)
function fromEitherK_3<F extends URIS>(F: FromEither1<F>): <E, A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Either<E, B>) => (...a: A) => Kind<F, B>;

// @public (undocumented)
function fromEitherK_3<F>(F: FromEither_4<F>): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => Either<E, B>) => (...a: A) => HKT2<F, E, B>;

// @public (undocumented)
const fromEitherK_4: <E, A extends ReadonlyArray<unknown>, B>(f: (...a: A) => either.Either<E, B>) => (...a: A) => IOEither<E, B>;

// @public (undocumented)
const fromEitherK_5: <E, A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Either<E, B>) => (...a: A) => IOOption<B>;

// @public (undocumented)
const fromEitherK_6: <E, A extends ReadonlyArray<unknown>, B>(f: (...a: A) => either.Either<E, B>) => <R = unknown>(...a: A) => ReaderEither<R, E, B>;

// @public (undocumented)
const fromEitherK_7: <E, A extends ReadonlyArray<unknown>, B>(f: (...a: A) => either.Either<E, B>) => (...a: A) => TaskEither<E, B>;

// @public (undocumented)
const fromEitherK_8: <E, A extends ReadonlyArray<unknown>, B>(f: (...a: A) => either.Either<E, B>) => <R = unknown>(...a: A) => ReaderTaskEither<R, E, B>;

// @public (undocumented)
const fromEitherK_9: <E, A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Either<E, B>) => (...a: A) => ReadonlyArray<B>;

// @public
const fromEntries: <A>(fa: readonly (readonly [string, A])[]) => Readonly<Record<string, A>>;

// @public
const fromEntries_2: <A>(fa: [string, A][]) => Record<string, A>;

// @public (undocumented)
const fromEquals: <A>(equals: (x: A, y: A) => boolean) => Eq<A>;

// @public (undocumented)
function fromF<F extends URIS4>(F: Functor4<F>): <S, R, E, A>(ma: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, Option_2<A>>;

// @public (undocumented)
function fromF<F extends URIS3>(F: Functor3<F>): <R, E, A>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, Option_2<A>>;

// @public (undocumented)
function fromF<F extends URIS3, E>(F: Functor3C<F, E>): <R, A>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, Option_2<A>>;

// @public (undocumented)
function fromF<F extends URIS2>(F: Functor2<F>): <E, A>(ma: Kind2<F, E, A>) => Kind2<F, E, Option_2<A>>;

// @public (undocumented)
function fromF<F extends URIS2, E>(F: Functor2C<F, E>): <A>(ma: Kind2<F, E, A>) => Kind2<F, E, Option_2<A>>;

// @public (undocumented)
function fromF<F extends URIS>(F: Functor1<F>): <A>(ma: Kind<F, A>) => Kind<F, Option_2<A>>;

// @public (undocumented)
function fromF<F>(F: Functor<F>): <A>(ma: HKT<F, A>) => HKT<F, Option_2<A>>;

// @public (undocumented)
function fromF_2<F extends URIS3>(F: Functor3<F>): <R, E, A, S>(ma: Kind3<F, R, E, A>) => StateT3<F, S, R, E, A>;

// @public (undocumented)
function fromF_2<F extends URIS3, E>(F: Functor3C<F, E>): <R, A, S>(ma: Kind3<F, R, E, A>) => StateT3<F, S, R, E, A>;

// @public (undocumented)
function fromF_2<F extends URIS2>(F: Functor2<F>): <E, A, S>(ma: Kind2<F, E, A>) => StateT2<F, S, E, A>;

// @public (undocumented)
function fromF_2<F extends URIS2, E>(F: Functor2C<F, E>): <A, S>(ma: Kind2<F, E, A>) => StateT2<F, S, E, A>;

// @public (undocumented)
function fromF_2<F extends URIS>(F: Functor1<F>): <A, S>(ma: Kind<F, A>) => StateT1<F, S, A>;

// @public (undocumented)
function fromF_2<F>(F: Functor<F>): <A, S>(ma: HKT<F, A>) => StateT<F, S, A>;

// @public
function fromFoldable<F extends URIS3, K, A>(E: Eq<K>, M: Magma<A>, F: Foldable3<F>): <R, E>(fka: Kind3<F, R, E, [K, A]>) => Map<K, A>;

// @public (undocumented)
function fromFoldable<F extends URIS2, K, A>(E: Eq<K>, M: Magma<A>, F: Foldable2<F>): <E>(fka: Kind2<F, E, [K, A]>) => Map<K, A>;

// @public (undocumented)
function fromFoldable<F extends URIS, K, A>(E: Eq<K>, M: Magma<A>, F: Foldable1<F>): (fka: Kind<F, [K, A]>) => Map<K, A>;

// @public (undocumented)
function fromFoldable<F, K, A>(E: Eq<K>, M: Magma<A>, F: Foldable_6<F>): (fka: HKT<F, [K, A]>) => Map<K, A>;

// @public
function fromFoldable_2<F extends URIS3, K, A>(E: Eq<K>, M: Magma<A>, F: Foldable3<F>): <R, E>(fka: Kind3<F, R, E, readonly [K, A]>) => ReadonlyMap<K, A>;

// @public (undocumented)
function fromFoldable_2<F extends URIS2, K, A>(E: Eq<K>, M: Magma<A>, F: Foldable2<F>): <E>(fka: Kind2<F, E, readonly [K, A]>) => ReadonlyMap<K, A>;

// @public (undocumented)
function fromFoldable_2<F extends URIS, K, A>(E: Eq<K>, M: Magma<A>, F: Foldable1<F>): (fka: Kind<F, readonly [K, A]>) => ReadonlyMap<K, A>;

// @public (undocumented)
function fromFoldable_2<F, K, A>(E: Eq<K>, M: Magma<A>, F: Foldable_6<F>): (fka: HKT<F, readonly [K, A]>) => ReadonlyMap<K, A>;

// @public
function fromFoldable_3<F extends URIS3, A>(M: Magma<A>, F: Foldable3<F>): <R, E>(fka: Kind3<F, R, E, readonly [string, A]>) => ReadonlyRecord<string, A>;

// @public (undocumented)
function fromFoldable_3<F extends URIS2, A>(M: Magma<A>, F: Foldable2<F>): <E>(fka: Kind2<F, E, readonly [string, A]>) => ReadonlyRecord<string, A>;

// @public (undocumented)
function fromFoldable_3<F extends URIS, A>(M: Magma<A>, F: Foldable1<F>): (fka: Kind<F, readonly [string, A]>) => ReadonlyRecord<string, A>;

// @public (undocumented)
function fromFoldable_3<F, A>(M: Magma<A>, F: Foldable_6<F>): (fka: HKT<F, readonly [string, A]>) => ReadonlyRecord<string, A>;

// @public
function fromFoldable_4<F extends URIS3, A>(M: Magma<A>, F: Foldable3<F>): <R, E>(fka: Kind3<F, R, E, [string, A]>) => Record<string, A>;

// @public (undocumented)
function fromFoldable_4<F extends URIS2, A>(M: Magma<A>, F: Foldable2<F>): <E>(fka: Kind2<F, E, [string, A]>) => Record<string, A>;

// @public (undocumented)
function fromFoldable_4<F extends URIS, A>(M: Magma<A>, F: Foldable1<F>): (fka: Kind<F, [string, A]>) => Record<string, A>;

// @public (undocumented)
function fromFoldable_4<F, A>(M: Magma<A>, F: Foldable_6<F>): (fka: HKT<F, [string, A]>) => Record<string, A>;

// @public
function fromFoldableMap<F extends URIS3, B>(M: Magma<B>, F: Foldable3<F>): <R, E, A>(fa: Kind3<F, R, E, A>, f: (a: A) => readonly [string, B]) => ReadonlyRecord<string, B>;

// @public (undocumented)
function fromFoldableMap<F extends URIS2, B>(M: Magma<B>, F: Foldable2<F>): <E, A>(fa: Kind2<F, E, A>, f: (a: A) => readonly [string, B]) => ReadonlyRecord<string, B>;

// @public (undocumented)
function fromFoldableMap<F extends URIS, B>(M: Magma<B>, F: Foldable1<F>): <A>(fa: Kind<F, A>, f: (a: A) => readonly [string, B]) => ReadonlyRecord<string, B>;

// @public (undocumented)
function fromFoldableMap<F, B>(M: Magma<B>, F: Foldable_6<F>): <A>(fa: HKT<F, A>, f: (a: A) => readonly [string, B]) => ReadonlyRecord<string, B>;

// @public
function fromFoldableMap_2<F extends URIS3, B>(M: Magma<B>, F: Foldable3<F>): <R, E, A>(fa: Kind3<F, R, E, A>, f: (a: A) => [string, B]) => Record<string, B>;

// @public (undocumented)
function fromFoldableMap_2<F extends URIS2, B>(M: Magma<B>, F: Foldable2<F>): <E, A>(fa: Kind2<F, E, A>, f: (a: A) => [string, B]) => Record<string, B>;

// @public (undocumented)
function fromFoldableMap_2<F extends URIS, B>(M: Magma<B>, F: Foldable1<F>): <A>(fa: Kind<F, A>, f: (a: A) => [string, B]) => Record<string, B>;

// @public (undocumented)
function fromFoldableMap_2<F, B>(M: Magma<B>, F: Foldable_6<F>): <A>(fa: HKT<F, A>, f: (a: A) => [string, B]) => Record<string, B>;

// @public (undocumented)
interface FromIO<F> {
    // (undocumented)
    readonly fromIO: <A>(fa: IO<A>) => HKT<F, A>;
    // (undocumented)
    readonly URI: F;
}

declare namespace fromIO {
    export {
        fromIOK,
        chainIOK,
        chainFirstIOK,
        FromIO,
        FromIO1,
        FromIO2,
        FromIO2C,
        FromIO3,
        FromIO3C,
        FromIO4
    }
}
export { fromIO }

// @public (undocumented)
interface FromIO1<F extends URIS> {
    // (undocumented)
    readonly fromIO: <A>(fa: IO<A>) => Kind<F, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromIO2<F extends URIS2> {
    // (undocumented)
    readonly fromIO: <A, E>(fa: IO<A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromIO2C<F extends URIS2, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly fromIO: <A>(fa: IO<A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromIO3<F extends URIS3> {
    // (undocumented)
    readonly fromIO: <A, R, E>(fa: IO<A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromIO3C<F extends URIS3, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly fromIO: <A, R>(fa: IO<A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromIO4<F extends URIS4> {
    // (undocumented)
    readonly fromIO: <A, S, R, E>(fa: IO<A>) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const FromIO_10: FromIO4<URI_31>;

// @public (undocumented)
const fromIO_10: <A, S, R = unknown, E = never>(fa: IO<A>) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const FromIO_11: FromIO1<URI_33>;

// @public (undocumented)
const fromIO_11: <A>(fa: IO<A>) => TaskOption<A>;

// @public (undocumented)
const FromIO_12: FromIO2<URI_34>;

// @public (undocumented)
const fromIO_12: <A, E = never>(fa: IO<A>) => TaskThese<E, A>;

// @public (undocumented)
const FromIO_2: FromIO1<URI_12>;

// @public @deprecated (undocumented)
const fromIO_2: <A>(fa: IO<A>) => IO<A>;

// @public (undocumented)
const FromIO_3: FromIO2<URI_13>;

// @public (undocumented)
const fromIO_3: <A, E = never>(fa: IO<A>) => IOEither<E, A>;

// @public (undocumented)
const FromIO_4: FromIO1<URI_14>;

// @public (undocumented)
const fromIO_4: <A>(fa: IO<A>) => IOOption<A>;

// @public (undocumented)
const FromIO_5: FromIO2<URI_19>;

// @public (undocumented)
const fromIO_5: <A, R = unknown>(fa: IO<A>) => ReaderIO<R, A>;

// @public (undocumented)
const FromIO_6: FromIO2<URI_20>;

// @public (undocumented)
const fromIO_6: <A, R = unknown>(fa: IO<A>) => ReaderTask<R, A>;

// @public (undocumented)
const FromIO_7: FromIO1<URI_21>;

// @public (undocumented)
const fromIO_7: <A>(fa: IO<A>) => Task<A>;

// @public (undocumented)
const FromIO_8: FromIO2<URI_23>;

// @public (undocumented)
const fromIO_8: <A, R = unknown, E = never>(fa: IO<A>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const FromIO_9: FromIO3<URI_22>;

// @public (undocumented)
const fromIO_9: <A, E = never>(fa: IO<A>) => TaskEither<E, A>;

// @public (undocumented)
const fromIOEither: <A>(fa: IOEither<unknown, A>) => IOOption<A>;

// @public (undocumented)
const fromIOEither_2: <E, A, R = unknown>(fa: IOEither<E, A>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const fromIOEither_3: <E, A>(fa: IOEither<E, A>) => TaskEither<E, A>;

// @public (undocumented)
const fromIOEither_4: <E, A, S, R = unknown>(fa: IOEither<E, A>) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const fromIOEither_5: <E, A>(fa: IOEither<E, A>) => TaskThese<E, A>;

// @public (undocumented)
const fromIOEitherK: <E, A extends readonly unknown[], B>(f: (...a: A) => IOEither<E, B>) => <R = unknown>(...a: A) => ReaderTaskEither<R, E, B>;

// @public (undocumented)
const fromIOEitherK_2: <E, A extends readonly unknown[], B>(f: (...a: A) => IOEither<E, B>) => (...a: A) => TaskEither<E, B>;

// @public (undocumented)
const fromIOEitherK_3: <E, A extends readonly unknown[], B>(f: (...a: A) => IOEither<E, B>) => <S, R = unknown>(...a: A) => StateReaderTaskEither<S, R, E, B>;

// @public (undocumented)
function fromIOK<F extends URIS4>(F: FromIO4<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <S, R, E>(...a: A) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function fromIOK<F extends URIS3>(F: FromIO3<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <R, E>(...a: A) => Kind3<F, R, E, B>;

// @public (undocumented)
function fromIOK<F extends URIS3, E>(F: FromIO3C<F, E>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <R>(...a: A) => Kind3<F, R, E, B>;

// @public (undocumented)
function fromIOK<F extends URIS2>(F: FromIO2<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <E>(...a: A) => Kind2<F, E, B>;

// @public (undocumented)
function fromIOK<F extends URIS2, E>(F: FromIO2C<F, E>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => (...a: A) => Kind2<F, E, B>;

// @public (undocumented)
function fromIOK<F extends URIS>(F: FromIO1<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => (...a: A) => Kind<F, B>;

// @public (undocumented)
function fromIOK<F>(F: FromIO<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => (...a: A) => HKT<F, B>;

// @public (undocumented)
const fromIOK_10: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => (...a: A) => TaskOption<B>;

// @public (undocumented)
const fromIOK_11: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <E = never>(...a: A) => TaskThese<E, B>;

// @public (undocumented)
const fromIOK_2: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => io.IO<B>) => <E = never>(...a: A) => IOEither<E, B>;

// @public (undocumented)
const fromIOK_3: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => io.IO<B>) => (...a: A) => IOOption<B>;

// @public (undocumented)
const fromIOK_4: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => io.IO<B>) => <R = unknown>(...a: A) => ReaderIO<R, B>;

// @public (undocumented)
const fromIOK_5: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <R = unknown>(...a: A) => ReaderTask<R, B>;

// @public (undocumented)
const fromIOK_6: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => (...a: A) => Task<B>;

// @public (undocumented)
const fromIOK_7: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <E = never>(...a: A) => TaskEither<E, B>;

// @public (undocumented)
const fromIOK_8: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <R = unknown, E = never>(...a: A) => ReaderTaskEither<R, E, B>;

// @public (undocumented)
const fromIOK_9: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <S, R = unknown, E = never>(...a: A) => StateReaderTaskEither<S, R, E, B>;

// @public (undocumented)
const fromMap: <K, A>(m: Map<K, A>) => ReadonlyMap<K, A>;

// @public (undocumented)
function fromNaturalTransformation<F extends URIS2, G extends URIS4>(nt: NaturalTransformation24S<F, G>): <R, S, A, E>(f: (r: R) => Kind2<F, S, A>) => Reader<R, Kind4<G, S, R, E, A>>;

// @public (undocumented)
function fromNaturalTransformation<F extends URIS2, G extends URIS3>(nt: NaturalTransformation23R<F, G>): <R, A, E>(f: (r: R) => Kind2<F, R, A>) => Reader<R, Kind3<G, R, E, A>>;

// @public (undocumented)
function fromNaturalTransformation<F extends URIS2, G extends URIS2>(nt: NaturalTransformation22<F, G>): <R, E, A>(f: (r: R) => Kind2<F, E, A>) => Reader<R, Kind2<G, E, A>>;

// @public (undocumented)
function fromNaturalTransformation<F extends URIS, G extends URIS2>(nt: NaturalTransformation12<F, G>): <R, A, E>(f: (r: R) => Kind<F, A>) => Reader<R, Kind2<G, E, A>>;

// @public (undocumented)
function fromNaturalTransformation<F extends URIS, G extends URIS>(nt: NaturalTransformation11<F, G>): <R, A>(f: (r: R) => Kind<F, A>) => Reader<R, Kind<G, A>>;

// @public (undocumented)
function fromNaturalTransformation<F, G>(nt: NaturalTransformation<F, G>): <R, A>(f: (r: R) => HKT<F, A>) => Reader<R, HKT<G, A>>;

// @public
const fromNullable: <A>(a: A) => Option_2<NonNullable<A>>;

// @public
const fromNullable_2: <E>(e: E) => <A>(a: A) => Either<E, NonNullable<A>>;

// @public (undocumented)
function fromNullable_3<F extends URIS3>(F: Pointed3<F>): <E>(e: E) => <A, S, R>(a: A) => Kind3<F, S, R, Either<E, NonNullable<A>>>;

// @public (undocumented)
function fromNullable_3<F extends URIS3, R>(F: Pointed3C<F, R>): <E>(e: E) => <A, S>(a: A) => Kind3<F, S, R, Either<E, NonNullable<A>>>;

// @public (undocumented)
function fromNullable_3<F extends URIS2>(F: Pointed2<F>): <E>(e: E) => <A, R>(a: A) => Kind2<F, R, Either<E, NonNullable<A>>>;

// @public (undocumented)
function fromNullable_3<F extends URIS2, R>(F: Pointed2C<F, R>): <E>(e: E) => <A>(a: A) => Kind2<F, R, Either<E, NonNullable<A>>>;

// @public (undocumented)
function fromNullable_3<F extends URIS>(F: Pointed1<F>): <E>(e: E) => <A>(a: A) => Kind<F, Either<E, NonNullable<A>>>;

// @public (undocumented)
function fromNullable_3<F>(F: Pointed<F>): <E>(e: E) => <A>(a: A) => HKT<F, Either<E, NonNullable<A>>>;

// @public (undocumented)
const fromNullable_4: <A>(a: A) => IOOption<NonNullable<A>>;

// @public (undocumented)
function fromNullable_5<F extends URIS4>(F: Pointed4<F>): <A, S, R, E>(a: A) => Kind4<F, S, R, E, Option_2<NonNullable<A>>>;

// @public (undocumented)
function fromNullable_5<F extends URIS3>(F: Pointed3<F>): <A, R, E>(a: A) => Kind3<F, R, E, Option_2<NonNullable<A>>>;

// @public (undocumented)
function fromNullable_5<F extends URIS3, E>(F: Pointed3C<F, E>): <A, R>(a: A) => Kind3<F, R, E, Option_2<NonNullable<A>>>;

// @public (undocumented)
function fromNullable_5<F extends URIS2>(F: Pointed2<F>): <A, E>(a: A) => Kind2<F, E, Option_2<NonNullable<A>>>;

// @public (undocumented)
function fromNullable_5<F extends URIS2, E>(F: Pointed2C<F, E>): <A>(a: A) => Kind2<F, E, Option_2<NonNullable<A>>>;

// @public (undocumented)
function fromNullable_5<F extends URIS>(F: Pointed1<F>): <A>(a: A) => Kind<F, Option_2<NonNullable<A>>>;

// @public (undocumented)
function fromNullable_5<F>(F: Pointed<F>): <A>(a: A) => HKT<F, Option_2<NonNullable<A>>>;

// @public (undocumented)
const fromNullable_6: <E>(e: E) => <R, A>(a: A) => ReaderTaskEither<R, E, NonNullable<A>>;

// @public (undocumented)
const fromNullable_7: <E>(e: E) => <A>(a: A) => TaskEither<E, NonNullable<A>>;

// @public (undocumented)
const fromNullable_8: <A>(a: A) => TaskOption<NonNullable<A>>;

// @public
const fromNullableK: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => Option_2<NonNullable<B>>;

// @public
const fromNullableK_2: <E>(e: E) => <A extends readonly unknown[], B>(f: (...a: A) => B | null | undefined) => (...a: A) => Either<E, NonNullable<B>>;

// @public (undocumented)
function fromNullableK_3<F extends URIS3>(F: Pointed3<F>): <E>(e: E) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => <S, R>(...a: A) => Kind3<F, S, R, Either<E, NonNullable<B>>>;

// @public (undocumented)
function fromNullableK_3<F extends URIS3, R>(F: Pointed3C<F, R>): <E>(e: E) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => <S>(...a: A) => Kind3<F, S, R, Either<E, NonNullable<B>>>;

// @public (undocumented)
function fromNullableK_3<F extends URIS2>(F: Pointed2<F>): <E>(e: E) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => <R>(...a: A) => Kind2<F, R, Either<E, NonNullable<B>>>;

// @public (undocumented)
function fromNullableK_3<F extends URIS2, R>(F: Pointed2C<F, R>): <E>(e: E) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => Kind2<F, R, Either<E, NonNullable<B>>>;

// @public (undocumented)
function fromNullableK_3<F extends URIS>(F: Pointed1<F>): <E>(e: E) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => Kind<F, Either<E, NonNullable<B>>>;

// @public (undocumented)
function fromNullableK_3<F>(F: Pointed<F>): <E>(e: E) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => HKT<F, Either<E, NonNullable<B>>>;

// @public (undocumented)
const fromNullableK_4: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => IOOption<NonNullable<B>>;

// @public (undocumented)
function fromNullableK_5<F extends URIS4>(F: Pointed4<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => <S, R, E>(...a: A) => Kind4<F, S, R, E, Option_2<NonNullable<B>>>;

// @public (undocumented)
function fromNullableK_5<F extends URIS3>(F: Pointed3<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => <R, E>(...a: A) => Kind3<F, R, E, Option_2<NonNullable<B>>>;

// @public (undocumented)
function fromNullableK_5<F extends URIS3, E>(F: Pointed3C<F, E>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => <R>(...a: A) => Kind3<F, R, E, Option_2<NonNullable<B>>>;

// @public (undocumented)
function fromNullableK_5<F extends URIS2>(F: Pointed2<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => <E>(...a: A) => Kind2<F, E, Option_2<NonNullable<B>>>;

// @public (undocumented)
function fromNullableK_5<F extends URIS2, E>(F: Pointed2C<F, E>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => Kind2<F, E, Option_2<NonNullable<B>>>;

// @public (undocumented)
function fromNullableK_5<F extends URIS>(F: Pointed1<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => Kind<F, Option_2<NonNullable<B>>>;

// @public (undocumented)
function fromNullableK_5<F>(F: Pointed<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => HKT<F, Option_2<NonNullable<B>>>;

// @public
const fromNullableK_6: <E>(e: E) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => <R = unknown>(...a: A) => ReaderTaskEither<R, E, NonNullable<B>>;

// @public
const fromNullableK_7: <E>(e: E) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => TaskEither<E, NonNullable<B>>;

// @public (undocumented)
const fromNullableK_8: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => TaskOption<NonNullable<B>>;

// @public
const fromOption: <A>(fa: Option_2<A>) => Array<A>;

// @public (undocumented)
const fromOption_10: <E>(onNone: LazyArg<E>) => <A, S, R = unknown>(fa: Option_2<A>) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const fromOption_11: <A>(fa: Option_2<A>) => TaskOption<A>;

// @public (undocumented)
const fromOption_12: <E>(onNone: LazyArg<E>) => <A>(fa: Option_2<A>) => TaskThese<E, A>;

// @public (undocumented)
const fromOption_13: <E>(onNone: LazyArg<E>) => <A>(fa: Option_2<A>) => These<E, A>;

// @public (undocumented)
const fromOption_2: <E>(onNone: LazyArg<E>) => <A>(fa: Option_2<A>) => Either<E, A>;

// @public (undocumented)
function fromOption_3<F extends URIS4>(F: FromEither4<F>): <E>(onNone: LazyArg<E>) => <A, S, R>(fa: Option_2<A>) => Kind4<F, S, R, E, A>;

// @public (undocumented)
function fromOption_3<F extends URIS3>(F: FromEither3<F>): <E>(onNone: LazyArg<E>) => <A, R>(fa: Option_2<A>) => Kind3<F, R, E, A>;

// @public (undocumented)
function fromOption_3<F extends URIS3, E>(F: FromEither3C<F, E>): (onNone: LazyArg<E>) => <A, R>(fa: Option_2<A>) => Kind3<F, R, E, A>;

// @public (undocumented)
function fromOption_3<F extends URIS2>(F: FromEither2<F>): <E>(onNone: LazyArg<E>) => <A>(fa: Option_2<A>) => Kind2<F, E, A>;

// @public (undocumented)
function fromOption_3<F extends URIS2, E>(F: FromEither2C<F, E>): (onNone: LazyArg<E>) => <A>(fa: Option_2<A>) => Kind2<F, E, A>;

// @public (undocumented)
function fromOption_3<F>(F: FromEither_4<F>): <E>(onNone: LazyArg<E>) => <A>(ma: Option_2<A>) => HKT2<F, E, A>;

// @public (undocumented)
const fromOption_4: <E>(onNone: LazyArg<E>) => <A>(fa: Option_2<A>) => IOEither<E, A>;

// @public (undocumented)
const fromOption_5: <A>(fa: Option_2<A>) => IOOption<A>;

// @public (undocumented)
const fromOption_6: <E>(onNone: LazyArg<E>) => <A, R = unknown>(fa: Option_2<A>) => ReaderEither<R, E, A>;

// @public (undocumented)
const fromOption_7: <E>(onNone: LazyArg<E>) => <A>(fa: Option_2<A>) => TaskEither<E, A>;

// @public (undocumented)
const fromOption_8: <E>(onNone: LazyArg<E>) => <A, R = unknown>(fa: Option_2<A>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const fromOption_9: <A>(fa: Option_2<A>) => ReadonlyArray<A>;

// @public (undocumented)
const fromOptionK: <A extends readonly unknown[], B>(f: (...a: A) => Option_2<B>) => (...a: A) => B[];

// @public (undocumented)
const fromOptionK_10: <A extends readonly unknown[], B>(f: (...a: A) => Option_2<B>) => (...a: A) => readonly B[];

// @public
const fromOptionK_11: <A, B extends A>(getOption: (a: A) => Option_2<B>) => Refinement<A, B>;

// @public (undocumented)
const fromOptionK_12: <E>(onNone: LazyArg<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => <S, R = unknown>(...a: A) => StateReaderTaskEither<S, R, E, B>;

// @public (undocumented)
const fromOptionK_13: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => (...a: A) => TaskOption<B>;

// @public (undocumented)
const fromOptionK_14: <E>(onNone: LazyArg<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => (...a: A) => TaskThese<E, B>;

// @public (undocumented)
const fromOptionK_15: <E>(onNone: LazyArg<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => (...a: A) => These<E, B>;

// @public
const fromOptionK_2: <E>(onNone: LazyArg<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => (...a: A) => Either<E, B>;

// @public (undocumented)
function fromOptionK_3<F extends URIS4>(F: FromEither4<F>): <E>(onNone: LazyArg<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => <S, R>(...a: A) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function fromOptionK_3<F extends URIS3>(F: FromEither3<F>): <E>(onNone: LazyArg<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => <R>(...a: A) => Kind3<F, R, E, B>;

// @public (undocumented)
function fromOptionK_3<F extends URIS3, E>(F: FromEither3C<F, E>): (onNone: LazyArg<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => <R>(...a: A) => Kind3<F, R, E, B>;

// @public (undocumented)
function fromOptionK_3<F extends URIS2>(F: FromEither2<F>): <E>(onNone: LazyArg<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => (...a: A) => Kind2<F, E, B>;

// @public (undocumented)
function fromOptionK_3<F extends URIS2, E>(F: FromEither2C<F, E>): (onNone: LazyArg<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => (...a: A) => Kind2<F, E, B>;

// @public (undocumented)
function fromOptionK_3<F>(F: FromEither_4<F>): <E>(onNone: LazyArg<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => (...a: A) => HKT2<F, E, B>;

// @public
const fromOptionK_4: <E>(onNone: LazyArg<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => (...a: A) => IOEither<E, B>;

// @public (undocumented)
const fromOptionK_5: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => (...a: A) => IOOption<B>;

// @public (undocumented)
function fromOptionK_6<F extends URIS4>(F: Pointed4<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => <S, R, E>(...a: A) => Kind4<F, S, R, E, Option_2<B>>;

// @public (undocumented)
function fromOptionK_6<F extends URIS3>(F: Pointed3<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => <R, E>(...a: A) => Kind3<F, R, E, Option_2<B>>;

// @public (undocumented)
function fromOptionK_6<F extends URIS3, E>(F: Pointed3C<F, E>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => <R>(...a: A) => Kind3<F, R, E, Option_2<B>>;

// @public (undocumented)
function fromOptionK_6<F extends URIS2>(F: Pointed2<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => <E>(...a: A) => Kind2<F, E, Option_2<B>>;

// @public (undocumented)
function fromOptionK_6<F extends URIS2, E>(F: Pointed2C<F, E>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => (...a: A) => Kind2<F, E, Option_2<B>>;

// @public (undocumented)
function fromOptionK_6<F extends URIS>(F: Pointed1<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => (...a: A) => Kind<F, Option_2<B>>;

// @public (undocumented)
function fromOptionK_6<F>(F: Pointed<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => (...a: A) => HKT<F, Option_2<B>>;

// @public
const fromOptionK_7: <E>(onNone: LazyArg<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => <R = unknown>(...a: A) => ReaderEither<R, E, B>;

// @public
const fromOptionK_8: <E>(onNone: LazyArg<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => (...a: A) => TaskEither<E, B>;

// @public
const fromOptionK_9: <E>(onNone: LazyArg<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option_2<B>) => <R = unknown>(...a: A) => ReaderTaskEither<R, E, B>;

// @public
const fromOptions: <E, A>(fe: Option_2<E>, fa: Option_2<A>) => Option_2<These<E, A>>;

// @public
function fromPredicate<A, B extends A>(refinement: Refinement<A, B>): (a: A) => Array<B>;

// @public (undocumented)
function fromPredicate<A>(predicate: Predicate<A>): <B extends A>(b: B) => Array<B>;

// @public (undocumented)
function fromPredicate<A>(predicate: Predicate<A>): (a: A) => Array<A>;

// @public (undocumented)
const fromPredicate_10: {
    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R = unknown>(a: A) => ReaderTaskEither<R, E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R = unknown, B extends A = A>(b: B) => ReaderTaskEither<R, E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R = unknown>(a: A) => ReaderTaskEither<R, E, A>;
};

// @public (undocumented)
function fromPredicate_11<A, B extends A>(refinement: Refinement<A, B>): (a: A) => ReadonlyArray<B>;

// @public (undocumented)
function fromPredicate_11<A>(predicate: Predicate<A>): <B extends A>(b: B) => ReadonlyArray<B>;

// @public (undocumented)
function fromPredicate_11<A>(predicate: Predicate<A>): (a: A) => ReadonlyArray<A>;

// @public (undocumented)
const fromPredicate_12: {
    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R = unknown>(a: A) => StateReaderTaskEither<S, R, E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R = unknown, B extends A = A>(b: B) => StateReaderTaskEither<S, R, E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R = unknown>(a: A) => StateReaderTaskEither<S, R, E, A>;
};

// @public (undocumented)
const fromPredicate_13: {
    <A, B extends A>(refinement: Refinement<A, B>): (a: A) => TaskOption<B>;
    <A>(predicate: Predicate<A>): <B extends A>(b: B) => TaskOption<B>;
    <A>(predicate: Predicate<A>): (a: A) => TaskOption<A>;
};

// @public (undocumented)
const fromPredicate_14: {
    <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => TaskThese<E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(b: B) => TaskThese<E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => TaskThese<E, A>;
};

// @public (undocumented)
const fromPredicate_15: {
    <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => These<E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(b: B) => These<E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => These<E, A>;
};

// @public
function fromPredicate_2<A, B extends A>(refinement: Refinement<A, B>): (a: A) => Option_2<B>;

// @public (undocumented)
function fromPredicate_2<A>(predicate: Predicate<A>): <B extends A>(b: B) => Option_2<B>;

// @public (undocumented)
function fromPredicate_2<A>(predicate: Predicate<A>): (a: A) => Option_2<A>;

// @public (undocumented)
const fromPredicate_3: {
    <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Either<E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(b: B) => Either<E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Either<E, A>;
};

// @public (undocumented)
function fromPredicate_4<F extends URIS4>(F: FromEither4<F>): {
    <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R>(a: A) => Kind4<F, S, R, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R, B extends A>(b: B) => Kind4<F, S, R, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R>(a: A) => Kind4<F, S, R, E, A>;
};

// @public (undocumented)
function fromPredicate_4<F extends URIS3>(F: FromEither3<F>): {
    <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <R, B extends A>(b: B) => Kind3<F, R, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, A>;
};

// @public (undocumented)
function fromPredicate_4<F extends URIS3, E>(F: FromEither3C<F, E>): {
    <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, B>;
    <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R, B extends A>(b: B) => Kind3<F, R, E, B>;
    <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, A>;
};

// @public (undocumented)
function fromPredicate_4<F extends URIS2>(F: FromEither2<F>): {
    <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(b: B) => Kind2<F, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, A>;
};

// @public (undocumented)
function fromPredicate_4<F extends URIS2, E>(F: FromEither2C<F, E>): {
    <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, B>;
    <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(b: B) => Kind2<F, E, B>;
    <A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, A>;
};

// @public (undocumented)
function fromPredicate_4<F>(F: FromEither_4<F>): {
    <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => HKT2<F, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(b: B) => HKT2<F, E, B>;
    <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => HKT2<F, E, A>;
};

// @public (undocumented)
const fromPredicate_5: {
    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => IOEither<E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(b: B) => IOEither<E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => IOEither<E, A>;
};

// @public (undocumented)
const fromPredicate_6: {
    <A, B extends A>(refinement: Refinement<A, B>): (a: A) => IOOption<B>;
    <A>(predicate: Predicate<A>): <B extends A>(b: B) => IOOption<B>;
    <A>(predicate: Predicate<A>): (a: A) => IOOption<A>;
};

// @public (undocumented)
function fromPredicate_7<F extends URIS4>(F: Pointed4<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): <S, R, E>(a: A) => Kind4<F, S, R, E, Option_2<B>>;
    <A>(predicate: Predicate<A>): <S, R, E, B extends A>(b: B) => Kind4<F, S, R, E, Option_2<B>>;
    <A>(predicate: Predicate<A>): <S, R, E>(a: A) => Kind4<F, S, R, E, Option_2<A>>;
};

// @public (undocumented)
function fromPredicate_7<F extends URIS3>(F: Pointed3<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): <R, E>(a: A) => Kind3<F, R, E, Option_2<B>>;
    <A>(predicate: Predicate<A>): <R, E, B extends A>(b: B) => Kind3<F, R, E, Option_2<B>>;
    <A>(predicate: Predicate<A>): <R, E>(a: A) => Kind3<F, R, E, Option_2<A>>;
};

// @public (undocumented)
function fromPredicate_7<F extends URIS3, E>(F: Pointed3C<F, E>): {
    <A, B extends A>(refinement: Refinement<A, B>): <R>(a: A) => Kind3<F, R, E, Option_2<B>>;
    <A>(predicate: Predicate<A>): <R, B extends A>(b: B) => Kind3<F, R, E, Option_2<B>>;
    <A>(predicate: Predicate<A>): <R>(a: A) => Kind3<F, R, E, Option_2<A>>;
};

// @public (undocumented)
function fromPredicate_7<F extends URIS2>(F: Pointed2<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): <E>(a: A) => Kind2<F, E, Option_2<B>>;
    <A>(predicate: Predicate<A>): <E, B extends A>(b: B) => Kind2<F, E, Option_2<B>>;
    <A>(predicate: Predicate<A>): <E>(a: A) => Kind2<F, E, Option_2<A>>;
};

// @public (undocumented)
function fromPredicate_7<F extends URIS2, E>(F: Pointed2C<F, E>): {
    <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Kind2<F, E, Option_2<B>>;
    <A>(predicate: Predicate<A>): <B extends A>(b: B) => Kind2<F, E, Option_2<B>>;
    <A>(predicate: Predicate<A>): (a: A) => Kind2<F, E, Option_2<A>>;
};

// @public (undocumented)
function fromPredicate_7<F extends URIS>(F: Pointed1<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Kind<F, Option_2<B>>;
    <A>(predicate: Predicate<A>): <B extends A>(b: B) => Kind<F, Option_2<B>>;
    <A>(predicate: Predicate<A>): (a: A) => Kind<F, Option_2<A>>;
};

// @public (undocumented)
function fromPredicate_7<F>(F: Pointed<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): (a: A) => HKT<F, Option_2<B>>;
    <A>(predicate: Predicate<A>): <B extends A>(b: B) => HKT<F, Option_2<B>>;
    <A>(predicate: Predicate<A>): (a: A) => HKT<F, Option_2<A>>;
};

// @public (undocumented)
const fromPredicate_8: {
    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R = unknown>(a: A) => ReaderEither<R, E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R = unknown, B extends A = A>(b: B) => ReaderEither<R, E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R = unknown>(a: A) => ReaderEither<R, E, A>;
};

// @public (undocumented)
const fromPredicate_9: {
    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => TaskEither<E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(b: B) => TaskEither<E, B>;
    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => TaskEither<E, A>;
};

// @public (undocumented)
interface FromReader<F> {
    // (undocumented)
    readonly fromReader: <R, A>(fa: Reader<R, A>) => HKT2<F, R, A>;
    // (undocumented)
    readonly URI: F;
}

declare namespace fromReader {
    export {
        ask,
        asks,
        fromReaderK,
        chainReaderK,
        chainFirstReaderK,
        tapReader,
        FromReader,
        FromReader2,
        FromReader3,
        FromReader3C,
        FromReader4
    }
}
export { fromReader }

// @public (undocumented)
interface FromReader2<F extends URIS2> {
    // (undocumented)
    readonly fromReader: <E, A>(fa: Reader<E, A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromReader3<F extends URIS3> {
    // (undocumented)
    readonly fromReader: <R, A, E>(fa: Reader<R, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromReader3C<F extends URIS3, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly fromReader: <R, A>(fa: Reader<R, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromReader4<F extends URIS4> {
    // (undocumented)
    readonly fromReader: <R, A, S, E>(fa: Reader<R, A>) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const FromReader_2: FromReader3<URI_18>;

// @public (undocumented)
const fromReader_2: <R, A, E = never>(fa: Reader<R, A>) => ReaderEither<R, E, A>;

// @public (undocumented)
const FromReader_3: FromReader2<URI_19>;

// @public (undocumented)
const fromReader_3: <R, A>(fa: Reader<R, A>) => ReaderIO<R, A>;

// @public (undocumented)
const FromReader_4: FromReader2<URI_20>;

// @public (undocumented)
function fromReader_4<F extends URIS4>(F: Pointed4<F>): <R, A, S, FR, FE>(ma: Reader<R, A>) => Reader<R, Kind4<F, S, FR, FE, A>>;

// @public (undocumented)
function fromReader_4<F extends URIS3>(F: Pointed3<F>): <R, A, FR, FE>(ma: Reader<R, A>) => Reader<R, Kind3<F, FR, FE, A>>;

// @public (undocumented)
function fromReader_4<F extends URIS3, FE>(F: Pointed3C<F, FE>): <R, A, FR>(ma: Reader<R, A>) => Reader<R, Kind3<F, FR, FE, A>>;

// @public (undocumented)
function fromReader_4<F extends URIS2>(F: Pointed2<F>): <R, A, FE>(ma: Reader<R, A>) => Reader<R, Kind2<F, FE, A>>;

// @public (undocumented)
function fromReader_4<F extends URIS2, FE>(F: Pointed2C<F, FE>): <R, A>(ma: Reader<R, A>) => Reader<R, Kind2<F, FE, A>>;

// @public (undocumented)
function fromReader_4<F extends URIS>(F: Pointed1<F>): <R, A>(ma: Reader<R, A>) => Reader<R, Kind<F, A>>;

// @public (undocumented)
function fromReader_4<F>(F: Pointed<F>): <R, A>(ma: Reader<R, A>) => Reader<R, HKT<F, A>>;

// @public (undocumented)
const FromReader_5: FromReader3<URI_22>;

// @public (undocumented)
const fromReader_5: <R, A>(fa: reader.Reader<R, A>) => ReaderTask<R, A>;

// @public (undocumented)
const FromReader_6: FromReader4<URI_31>;

// @public (undocumented)
const fromReader_6: <R, A, E = never>(fa: Reader<R, A>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const fromReader_7: <R, A, S, E = never>(fa: Reader<R, A>) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const fromReaderEither: <R, E, A>(fa: ReaderEither<R, E, A>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const fromReaderEither_2: <R, E, A, S>(fa: ReaderEither<R, E, A>) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const fromReaderEitherK: <R, E, A extends readonly unknown[], B>(f: (...a: A) => ReaderEither<R, E, B>) => (...a: A) => ReaderTaskEither<R, E, B>;

// @public (undocumented)
const fromReaderIO: <R, A>(fa: ReaderIO<R, A>) => ReaderTask<R, A>;

// @public (undocumented)
const fromReaderIOK: <A extends readonly unknown[], R, B>(f: (...a: A) => ReaderIO<R, B>) => (...a: A) => ReaderTask<R, B>;

// @public (undocumented)
const fromReaderIOK_2: <A extends readonly unknown[], R, B>(f: (...a: A) => ReaderIO<R, B>) => <E = never>(...a: A) => ReaderTaskEither<R, E, B>;

// @public (undocumented)
function fromReaderK<F extends URIS4>(F: FromReader4<F>): <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => Reader<R, B>) => <S, E>(...a: A) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function fromReaderK<F extends URIS3>(F: FromReader3<F>): <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => Reader<R, B>) => <E>(...a: A) => Kind3<F, R, E, B>;

// @public (undocumented)
function fromReaderK<F extends URIS3, E>(F: FromReader3C<F, E>): <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => Reader<R, B>) => (...a: A) => Kind3<F, R, E, B>;

// @public (undocumented)
function fromReaderK<F extends URIS2>(F: FromReader2<F>): <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => Reader<R, B>) => (...a: A) => Kind2<F, R, B>;

// @public (undocumented)
function fromReaderK<F>(F: FromReader<F>): <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => Reader<R, B>) => (...a: A) => HKT2<F, R, B>;

// @public (undocumented)
const fromReaderK_2: <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => Reader<R, B>) => <E = never>(...a: A) => ReaderEither<R, E, B>;

// @public (undocumented)
const fromReaderK_3: <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => reader.Reader<R, B>) => (...a: A) => ReaderIO<R, B>;

// @public (undocumented)
const fromReaderK_4: <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => reader.Reader<R, B>) => (...a: A) => ReaderTask<R, B>;

// @public (undocumented)
const fromReaderK_5: <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => Reader<R, B>) => <E = never>(...a: A) => ReaderTaskEither<R, E, B>;

// @public (undocumented)
const fromReaderK_6: <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => Reader<R, B>) => <S, E = never>(...a: A) => StateReaderTaskEither<S, R, E, B>;

// @public (undocumented)
const fromReaderTaskEither: <R, E, A, S>(fa: ReaderTaskEither<R, E, A>) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const fromReaderTaskEitherK: <R, E, A extends readonly unknown[], B>(f: (...a: A) => readerTaskEither.ReaderTaskEither<R, E, B>) => <S>(...a: A) => StateReaderTaskEither<S, R, E, B>;

// @public (undocumented)
const fromReaderTaskK: <A extends readonly unknown[], R, B>(f: (...a: A) => readerTask.ReaderTask<R, B>) => <E = never>(...a: A) => ReaderTaskEither<R, E, B>;

// @public
const fromReadonlyArray: <A>(as: readonly A[]) => Option_2<ReadonlyNonEmptyArray<A>>;

// @public
const fromReadonlyArray_2: <A>(E: Eq<A>) => (as: readonly A[]) => ReadonlySet<A>;

// @public (undocumented)
const fromReadonlyNonEmptyArray: <A>(as: ReadonlyNonEmptyArray<A>) => NonEmptyArray<A>;

// @public
const fromRecord: <K extends string, A>(r: Record<K, A>) => Readonly<Record<K, A>>;

// @public (undocumented)
const fromSet: <A>(s: Set<A>) => ReadonlySet<A>;

// @public (undocumented)
interface FromState<F> {
    // (undocumented)
    readonly fromState: <S, A>(fa: State<S, A>) => HKT2<F, S, A>;
    // (undocumented)
    readonly URI: F;
}

declare namespace fromState {
    export {
        get,
        put,
        modify,
        gets,
        fromStateK,
        chainStateK,
        FromState,
        FromState2,
        FromState3,
        FromState3C,
        FromState4
    }
}
export { fromState }

// @public (undocumented)
interface FromState2<F extends URIS2> {
    // (undocumented)
    readonly fromState: <S, A>(fa: State<S, A>) => Kind2<F, S, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromState3<F extends URIS3> {
    // (undocumented)
    readonly fromState: <S, A, E>(fa: State<S, A>) => Kind3<F, S, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromState3C<F extends URIS3, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly fromState: <S, A>(fa: State<S, A>) => Kind3<F, S, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromState4<F extends URIS4> {
    // (undocumented)
    readonly fromState: <S, A, R, E>(fa: State<S, A>) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const FromState_2: FromState2<URI_30>;

// @public (undocumented)
const fromState_2: <S, A, R = unknown, E = never>(fa: State<S, A>) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const FromState_3: FromState4<URI_31>;

// @public (undocumented)
function fromState_3<F extends URIS3>(F: Pointed3<F>): <S, A, R, E>(sa: State<S, A>) => StateT3<F, S, R, E, A>;

// @public (undocumented)
function fromState_3<F extends URIS3, E>(F: Pointed3C<F, E>): <S, A, R>(sa: State<S, A>) => StateT3<F, S, R, E, A>;

// @public (undocumented)
function fromState_3<F extends URIS2>(F: Pointed2<F>): <S, A, E>(sa: State<S, A>) => StateT2<F, S, E, A>;

// @public (undocumented)
function fromState_3<F extends URIS2, E>(F: Pointed2C<F, E>): <S, A>(sa: State<S, A>) => StateT2<F, S, E, A>;

// @public (undocumented)
function fromState_3<F extends URIS>(F: Pointed1<F>): <S, A>(sa: State<S, A>) => StateT1<F, S, A>;

// @public (undocumented)
function fromState_3<F>(F: Pointed<F>): <S, A>(sa: State<S, A>) => StateT<F, S, A>;

// @public (undocumented)
function fromStateK<F extends URIS4>(F: FromState4<F>): <A extends ReadonlyArray<unknown>, S, B>(f: (...a: A) => State<S, B>) => <R, E>(...a: A) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function fromStateK<F extends URIS3>(F: FromState3<F>): <A extends ReadonlyArray<unknown>, S, B>(f: (...a: A) => State<S, B>) => <E>(...a: A) => Kind3<F, S, E, B>;

// @public (undocumented)
function fromStateK<F extends URIS3, E>(F: FromState3C<F, E>): <A extends ReadonlyArray<unknown>, S, B>(f: (...a: A) => State<S, B>) => (...a: A) => Kind3<F, S, E, B>;

// @public (undocumented)
function fromStateK<F extends URIS2>(F: FromState2<F>): <A extends ReadonlyArray<unknown>, S, B>(f: (...a: A) => State<S, B>) => (...a: A) => Kind2<F, S, B>;

// @public (undocumented)
function fromStateK<F>(F: FromState<F>): <A extends ReadonlyArray<unknown>, S, B>(f: (...a: A) => State<S, B>) => (...a: A) => HKT2<F, S, B>;

// @public (undocumented)
const fromStateK_2: <A extends ReadonlyArray<unknown>, S, B>(f: (...a: A) => State<S, B>) => <R = unknown, E = never>(...a: A) => StateReaderTaskEither<S, R, E, B>;

// @public (undocumented)
interface FromTask<F> extends FromIO<F> {
    // (undocumented)
    readonly fromTask: <A>(fa: Task<A>) => HKT<F, A>;
}

declare namespace fromTask {
    export {
        fromTaskK,
        chainTaskK,
        chainFirstTaskK,
        FromTask,
        FromTask1,
        FromTask2,
        FromTask2C,
        FromTask3,
        FromTask3C,
        FromTask4
    }
}
export { fromTask }

// @public (undocumented)
interface FromTask1<F extends URIS> extends FromIO1<F> {
    // (undocumented)
    readonly fromTask: <A>(fa: Task<A>) => Kind<F, A>;
}

// @public (undocumented)
interface FromTask2<F extends URIS2> extends FromIO2<F> {
    // (undocumented)
    readonly fromTask: <A, E>(fa: Task<A>) => Kind2<F, E, A>;
}

// @public (undocumented)
interface FromTask2C<F extends URIS2, E> extends FromIO2C<F, E> {
    // (undocumented)
    readonly fromTask: <A>(fa: Task<A>) => Kind2<F, E, A>;
}

// @public (undocumented)
interface FromTask3<F extends URIS3> extends FromIO3<F> {
    // (undocumented)
    readonly fromTask: <A, R, E>(fa: Task<A>) => Kind3<F, R, E, A>;
}

// @public (undocumented)
interface FromTask3C<F extends URIS3, E> extends FromIO3C<F, E> {
    // (undocumented)
    readonly fromTask: <A, R>(fa: Task<A>) => Kind3<F, R, E, A>;
}

// @public (undocumented)
interface FromTask4<F extends URIS4> extends FromIO4<F> {
    // (undocumented)
    readonly fromTask: <A, S, R, E>(fa: Task<A>) => Kind4<F, S, R, E, A>;
}

// @public (undocumented)
const FromTask_2: FromTask2<URI_20>;

// @public (undocumented)
const fromTask_2: <A, R = unknown>(fa: Task<A>) => ReaderTask<R, A>;

// @public (undocumented)
const FromTask_3: FromTask1<URI_21>;

// @public @deprecated (undocumented)
const fromTask_3: <A>(fa: Task<A>) => Task<A>;

// @public (undocumented)
const FromTask_4: FromTask2<URI_23>;

// @public (undocumented)
const fromTask_4: <A, R = unknown, E = never>(fa: Task<A>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const FromTask_5: FromTask3<URI_22>;

// @public (undocumented)
const fromTask_5: <A, E = never>(fa: Task<A>) => TaskEither<E, A>;

// @public (undocumented)
const FromTask_6: FromTask4<URI_31>;

// @public (undocumented)
const fromTask_6: <A, S, R = unknown, E = never>(fa: Task<A>) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const FromTask_7: FromTask1<URI_33>;

// @public (undocumented)
const fromTask_7: <A>(fa: Task<A>) => TaskOption<A>;

// @public (undocumented)
const FromTask_8: FromTask2<URI_34>;

// @public (undocumented)
const fromTask_8: <A, E = never>(fa: Task<A>) => TaskThese<E, A>;

// @public (undocumented)
const fromTaskEither: <E, A, R = unknown>(fa: TaskEither<E, A>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const fromTaskEither_2: <E, A, S, R = unknown>(fa: TaskEither<E, A>) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const fromTaskEither_3: <A>(fa: TaskEither<unknown, A>) => TaskOption<A>;

// @public (undocumented)
const fromTaskEitherK: <E, A extends readonly unknown[], B>(f: (...a: A) => taskEither.TaskEither<E, B>) => <R = unknown>(...a: A) => ReaderTaskEither<R, E, B>;

// @public (undocumented)
const fromTaskEitherK_2: <E, A extends readonly unknown[], B>(f: (...a: A) => TaskEither<E, B>) => <S, R = unknown>(...a: A) => StateReaderTaskEither<S, R, E, B>;

// @public (undocumented)
function fromTaskK<F extends URIS4>(F: FromTask4<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => <S, R, E>(...a: A) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function fromTaskK<F extends URIS3>(F: FromTask3<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => <R, E>(...a: A) => Kind3<F, R, E, B>;

// @public (undocumented)
function fromTaskK<F extends URIS3, E>(F: FromTask3C<F, E>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => <R>(...a: A) => Kind3<F, R, E, B>;

// @public (undocumented)
function fromTaskK<F extends URIS2>(F: FromTask2<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => <E>(...a: A) => Kind2<F, E, B>;

// @public (undocumented)
function fromTaskK<F extends URIS2, E>(F: FromTask2C<F, E>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => (...a: A) => Kind2<F, E, B>;

// @public (undocumented)
function fromTaskK<F extends URIS>(F: FromTask1<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => (...a: A) => Kind<F, B>;

// @public (undocumented)
function fromTaskK<F>(F: FromTask<F>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => (...a: A) => HKT<F, B>;

// @public (undocumented)
const fromTaskK_2: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => task.Task<B>) => <R = unknown>(...a: A) => ReaderTask<R, B>;

// @public (undocumented)
const fromTaskK_3: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => task.Task<B>) => <E = never>(...a: A) => TaskEither<E, B>;

// @public (undocumented)
const fromTaskK_4: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => task.Task<B>) => <R = unknown, E = never>(...a: A) => ReaderTaskEither<R, E, B>;

// @public (undocumented)
const fromTaskK_5: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => <S, R = unknown, E = never>(...a: A) => StateReaderTaskEither<S, R, E, B>;

// @public (undocumented)
const fromTaskK_6: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => task.Task<B>) => (...a: A) => TaskOption<B>;

// @public (undocumented)
const fromTaskK_7: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => task.Task<B>) => <E = never>(...a: A) => TaskThese<E, B>;

// @public (undocumented)
const fromTaskOption: <E>(onNone: LazyArg<E>) => <A>(fa: TaskOption<A>) => TaskEither<E, A>;

// @public (undocumented)
const fromTaskOptionK: <E>(onNone: LazyArg<E>) => <A extends readonly unknown[], B>(f: (...a: A) => TaskOption<B>) => (...a: A) => TaskEither<E, B>;

// @public (undocumented)
interface FromThese<F> {
    // (undocumented)
    readonly fromThese: <E, A>(e: These<E, A>) => HKT2<F, E, A>;
    // (undocumented)
    readonly URI: F;
}

declare namespace fromThese {
    export {
        fromTheseK,
        FromThese,
        FromThese2,
        FromThese2C,
        FromThese3,
        FromThese3C,
        FromThese4
    }
}
export { fromThese }

// @public (undocumented)
interface FromThese2<F extends URIS2> {
    // (undocumented)
    readonly fromThese: <E, A>(fa: These<E, A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromThese2C<F extends URIS2, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly fromThese: <A>(fa: These<E, A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromThese3<F extends URIS3> {
    // (undocumented)
    readonly fromThese: <E, A, R>(fa: These<E, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromThese3C<F extends URIS3, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly fromThese: <A, R>(fa: These<E, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface FromThese4<F extends URIS4> {
    // (undocumented)
    readonly fromThese: <E, A, S, R>(fa: These<E, A>) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const FromThese_2: FromThese2<URI_34>;

// @public (undocumented)
const fromThese_2: <E, A>(fa: These<E, A>) => TaskThese<E, A>;

// @public (undocumented)
const FromThese_3: FromThese2<URI_35>;

// @public (undocumented)
function fromTheseK<F extends URIS4>(F: FromThese4<F>): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => These<E, B>) => <S, R>(...a: A) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function fromTheseK<F extends URIS3>(F: FromThese3<F>): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => These<E, B>) => <R>(...a: A) => Kind3<F, R, E, B>;

// @public (undocumented)
function fromTheseK<F extends URIS3, E>(F: FromThese3C<F, E>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => These<E, B>) => <R>(...a: A) => Kind3<F, R, E, B>;

// @public (undocumented)
function fromTheseK<F extends URIS2>(F: FromThese2<F>): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => These<E, B>) => (...a: A) => Kind2<F, E, B>;

// @public (undocumented)
function fromTheseK<F extends URIS2, E>(F: FromThese2C<F, E>): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => These<E, B>) => (...a: A) => Kind2<F, E, B>;

// @public (undocumented)
function fromTheseK<F>(F: FromThese<F>): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => These<E, B>) => (...a: A) => HKT2<F, E, B>;

// @public (undocumented)
const fromTheseK_2: <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => these.These<E, B>) => (...a: A) => TaskThese<E, B>;

// @public (undocumented)
function fst<A, E>(ea: readonly [A, E]): A;

// @public (undocumented)
const fst_2: <A, E>(ea: [A, E]) => A;

declare namespace function {
    export {
        identity_2 as identity,
        constant_2 as constant,
        flip,
        flow,
        tuple_7 as tuple,
        increment,
        decrement,
        absurd,
        tupled,
        untupled,
        pipe,
        not,
        getBooleanAlgebra_2 as getBooleanAlgebra,
        getSemigroup_9 as getSemigroup,
        getMonoid_7 as getMonoid,
        getSemiring_2 as getSemiring,
        getRing_2 as getRing,
        apply_2 as apply,
        FunctionN,
        unsafeCoerce,
        constTrue,
        constFalse,
        constNull,
        constUndefined,
        constVoid,
        hole,
        SK,
        Refinement_2 as Refinement,
        Predicate_2 as Predicate,
        Endomorphism_2 as Endomorphism,
        getEndomorphismMonoid_2 as getEndomorphismMonoid,
        LazyArg,
        Lazy
    }
}
export { function }

// @public (undocumented)
interface FunctionN<A extends ReadonlyArray<unknown>, B> {
    // (undocumented)
    (...args: A): B;
}

// @public (undocumented)
interface Functor<F> {
    // (undocumented)
    readonly map: <A, B>(fa: HKT<F, A>, f: (a: A) => B) => HKT<F, B>;
    // (undocumented)
    readonly URI: F;
}

declare namespace functor {
    export {
        map_10 as map,
        flap_8 as flap,
        bindTo_6 as bindTo,
        getFunctorComposition,
        Functor,
        Functor1,
        Functor2,
        Functor2C,
        Functor3,
        Functor3C,
        Functor4,
        let__6 as let,
        FunctorComposition,
        FunctorCompositionHKT1,
        FunctorCompositionHKT2,
        FunctorCompositionHKT2C,
        FunctorComposition11,
        FunctorComposition12,
        FunctorComposition12C,
        FunctorComposition21,
        FunctorComposition2C1,
        FunctorComposition22,
        FunctorComposition22C,
        FunctorComposition23,
        FunctorComposition23C
    }
}
export { functor }

// @public (undocumented)
interface Functor1<F extends URIS> {
    // (undocumented)
    readonly map: <A, B>(fa: Kind<F, A>, f: (a: A) => B) => Kind<F, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Functor2<F extends URIS2> {
    // (undocumented)
    readonly map: <E, A, B>(fa: Kind2<F, E, A>, f: (a: A) => B) => Kind2<F, E, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Functor2C<F extends URIS2, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly map: <A, B>(fa: Kind2<F, E, A>, f: (a: A) => B) => Kind2<F, E, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Functor3<F extends URIS3> {
    // (undocumented)
    readonly map: <R, E, A, B>(fa: Kind3<F, R, E, A>, f: (a: A) => B) => Kind3<F, R, E, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Functor3C<F extends URIS3, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly map: <R, A, B>(fa: Kind3<F, R, E, A>, f: (a: A) => B) => Kind3<F, R, E, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Functor4<F extends URIS4> {
    // (undocumented)
    readonly map: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, f: (a: A) => B) => Kind4<F, S, R, E, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const Functor_10: Functor1<URI_12>;

// @public (undocumented)
const Functor_11: Functor2<URI_13>;

// @public (undocumented)
const Functor_12: Functor1<URI_14>;

// @public (undocumented)
const Functor_13: Functor2<URI_15>;

// @public (undocumented)
const Functor_14: Functor2<URI_17>;

// @public (undocumented)
const Functor_15: Functor3<URI_18>;

// @public (undocumented)
const Functor_16: Functor2<URI_19>;

// @public (undocumented)
const Functor_17: Functor2<URI_20>;

// @public (undocumented)
const Functor_18: Functor1<URI_21>;

// @public (undocumented)
const Functor_19: Functor2<URI_23>;

// @public (undocumented)
const Functor_2: Functor1<URI_2>;

// @public (undocumented)
const Functor_20: Functor3<URI_22>;

// @public (undocumented)
const Functor_21: Functor1<URI_24>;

// @public (undocumented)
const Functor_22: Functor2<URI_25>;

// @public (undocumented)
const Functor_23: Functor1<URI_26>;

// @public (undocumented)
const Functor_24: Functor2<URI_28>;

// @public (undocumented)
const Functor_25: Functor1<URI_29>;

// @public (undocumented)
const Functor_26: Functor2<URI_30>;

// @public (undocumented)
const Functor_27: Functor4<URI_31>;

// @public (undocumented)
const Functor_28: Functor2<URI_32>;

// @public (undocumented)
const Functor_29: Functor1<URI_33>;

// @public (undocumented)
const Functor_3: Functor1<URI_3>;

// @public (undocumented)
const Functor_30: Functor2<URI_34>;

// @public (undocumented)
const Functor_31: Functor2<URI_35>;

// @public (undocumented)
const Functor_32: Functor2<URI_36>;

// @public (undocumented)
const Functor_33: Functor1<URI_37>;

// @public (undocumented)
const Functor_34: Functor2<URI_38>;

// @public (undocumented)
const Functor_35: Functor2<URI_39>;

// @public (undocumented)
const Functor_4: Functor1<URI_4>;

// @public (undocumented)
const Functor_5: Functor2<URI_5>;

// @public (undocumented)
const Functor_6: Functor1<URI_7>;

// @public (undocumented)
const Functor_7: Functor2<URI_6>;

// @public (undocumented)
const Functor_8: Functor2<URI_9>;

// @public (undocumented)
const Functor_9: Functor1<URI_11>;

// @public @deprecated (undocumented)
interface FunctorComposition<F, G> {
    // (undocumented)
    readonly map: <A, B>(fa: HKT<F, HKT<G, A>>, f: (a: A) => B) => HKT<F, HKT<G, B>>;
}

// @public @deprecated (undocumented)
interface FunctorComposition11<F extends URIS, G extends URIS> {
    // (undocumented)
    readonly map: <A, B>(fa: Kind<F, Kind<G, A>>, f: (a: A) => B) => Kind<F, Kind<G, B>>;
}

// @public @deprecated (undocumented)
interface FunctorComposition12<F extends URIS, G extends URIS2> {
    // (undocumented)
    readonly map: <E, A, B>(fa: Kind<F, Kind2<G, E, A>>, f: (a: A) => B) => Kind<F, Kind2<G, E, B>>;
}

// @public @deprecated (undocumented)
interface FunctorComposition12C<F extends URIS, G extends URIS2, E> {
    // (undocumented)
    readonly map: <A, B>(fa: Kind<F, Kind2<G, E, A>>, f: (a: A) => B) => Kind<F, Kind2<G, E, B>>;
}

// @public @deprecated (undocumented)
interface FunctorComposition21<F extends URIS2, G extends URIS> {
    // (undocumented)
    readonly map: <E, A, B>(fa: Kind2<F, E, Kind<G, A>>, f: (a: A) => B) => Kind2<F, E, Kind<G, B>>;
}

// @public @deprecated (undocumented)
interface FunctorComposition22<F extends URIS2, G extends URIS2> {
    // (undocumented)
    readonly map: <FE, GE, A, B>(fa: Kind2<F, FE, Kind2<G, GE, A>>, f: (a: A) => B) => Kind2<F, FE, Kind2<G, GE, B>>;
}

// @public @deprecated (undocumented)
interface FunctorComposition22C<F extends URIS2, G extends URIS2, E> {
    // (undocumented)
    readonly map: <FE, A, B>(fa: Kind2<F, FE, Kind2<G, E, A>>, f: (a: A) => B) => Kind2<F, FE, Kind2<G, E, B>>;
}

// @public @deprecated (undocumented)
interface FunctorComposition23<F extends URIS2, G extends URIS3> {
    // (undocumented)
    readonly map: <FE, R, E, A, B>(fa: Kind2<F, FE, Kind3<G, R, E, A>>, f: (a: A) => B) => Kind2<F, FE, Kind3<G, R, E, B>>;
}

// @public @deprecated (undocumented)
interface FunctorComposition23C<F extends URIS2, G extends URIS3, E> {
    // (undocumented)
    readonly map: <FE, R, A, B>(fa: Kind2<F, FE, Kind3<G, R, E, A>>, f: (a: A) => B) => Kind2<F, FE, Kind3<G, R, E, B>>;
}

// @public @deprecated (undocumented)
interface FunctorComposition2C1<F extends URIS2, G extends URIS, E> {
    // (undocumented)
    readonly map: <A, B>(fa: Kind2<F, E, Kind<G, A>>, f: (a: A) => B) => Kind2<F, E, Kind<G, B>>;
}

// @public @deprecated (undocumented)
interface FunctorCompositionHKT1<F, G extends URIS> {
    // (undocumented)
    readonly map: <A, B>(fa: HKT<F, Kind<G, A>>, f: (a: A) => B) => HKT<F, Kind<G, B>>;
}

// @public @deprecated (undocumented)
interface FunctorCompositionHKT2<F, G extends URIS2> {
    // (undocumented)
    readonly map: <E, A, B>(fa: HKT<F, Kind2<G, E, A>>, f: (a: A) => B) => HKT<F, Kind2<G, E, B>>;
}

// @public @deprecated (undocumented)
interface FunctorCompositionHKT2C<F, G extends URIS2, E> {
    // (undocumented)
    readonly map: <A, B>(fa: HKT<F, Kind2<G, E, A>>, f: (a: A) => B) => HKT<F, Kind2<G, E, B>>;
}

// @public @deprecated
const functorTaskThese: Functor2<URI_34>;

// @public (undocumented)
const FunctorWithIndex: FunctorWithIndex1<URI_2, number>;

declare namespace functorWithIndex {
    export {
        mapWithIndex_4 as mapWithIndex,
        getFunctorWithIndexComposition,
        FunctorWithIndex_4 as FunctorWithIndex,
        FunctorWithIndex1,
        FunctorWithIndex2,
        FunctorWithIndex2C,
        FunctorWithIndex3,
        FunctorWithIndex3C,
        FunctorWithIndex4,
        FunctorWithIndexComposition,
        FunctorWithIndexComposition11,
        FunctorWithIndexComposition12,
        FunctorWithIndexComposition12C,
        FunctorWithIndexComposition21,
        FunctorWithIndexComposition2C1,
        FunctorWithIndexComposition22,
        FunctorWithIndexComposition22C
    }
}
export { functorWithIndex }

// @public (undocumented)
interface FunctorWithIndex1<F extends URIS, I> extends Functor1<F> {
    // (undocumented)
    readonly mapWithIndex: <A, B>(fa: Kind<F, A>, f: (i: I, a: A) => B) => Kind<F, B>;
}

// @public (undocumented)
interface FunctorWithIndex2<F extends URIS2, I> extends Functor2<F> {
    // (undocumented)
    readonly mapWithIndex: <E, A, B>(fa: Kind2<F, E, A>, f: (i: I, a: A) => B) => Kind2<F, E, B>;
}

// @public (undocumented)
interface FunctorWithIndex2C<F extends URIS2, I, E> extends Functor2C<F, E> {
    // (undocumented)
    readonly mapWithIndex: <A, B>(fa: Kind2<F, E, A>, f: (i: I, a: A) => B) => Kind2<F, E, B>;
}

// @public (undocumented)
interface FunctorWithIndex3<F extends URIS3, I> extends Functor3<F> {
    // (undocumented)
    readonly mapWithIndex: <R, E, A, B>(fa: Kind3<F, R, E, A>, f: (i: I, a: A) => B) => Kind3<F, R, E, B>;
}

// @public (undocumented)
interface FunctorWithIndex3C<F extends URIS3, I, E> extends Functor3C<F, E> {
    // (undocumented)
    readonly mapWithIndex: <R, A, B>(fa: Kind3<F, R, E, A>, f: (i: I, a: A) => B) => Kind3<F, R, E, B>;
}

// @public (undocumented)
interface FunctorWithIndex4<F extends URIS4, I> extends Functor4<F> {
    // (undocumented)
    readonly mapWithIndex: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, f: (i: I, a: A) => B) => Kind4<F, S, R, E, B>;
}

// @public (undocumented)
const FunctorWithIndex_2: FunctorWithIndex1<URI_3, number>;

// @public (undocumented)
const FunctorWithIndex_3: FunctorWithIndex1<URI_4, number>;

// @public (undocumented)
interface FunctorWithIndex_4<F, I> extends Functor<F> {
    // (undocumented)
    readonly mapWithIndex: <A, B>(fa: HKT<F, A>, f: (i: I, a: A) => B) => HKT<F, B>;
}

// @public (undocumented)
const FunctorWithIndex_5: FunctorWithIndex1<URI_24, number>;

// @public (undocumented)
const FunctorWithIndex_6: FunctorWithIndex1<URI_26, string>;

// @public (undocumented)
const FunctorWithIndex_7: FunctorWithIndex1<URI_29, string>;

// @public @deprecated (undocumented)
interface FunctorWithIndexComposition<F, FI, G, GI> extends FunctorComposition<F, G> {
    // (undocumented)
    readonly mapWithIndex: <A, B>(fga: HKT<F, HKT<G, A>>, f: (i: [FI, GI], a: A) => B) => HKT<F, HKT<G, B>>;
}

// @public @deprecated (undocumented)
interface FunctorWithIndexComposition11<F extends URIS, FI, G extends URIS, GI> extends FunctorComposition11<F, G> {
    // (undocumented)
    readonly mapWithIndex: <A, B>(fa: Kind<F, Kind<G, A>>, f: (i: [FI, GI], a: A) => B) => Kind<F, Kind<G, B>>;
}

// @public @deprecated (undocumented)
interface FunctorWithIndexComposition12<F extends URIS, FI, G extends URIS2, GI> extends FunctorComposition12<F, G> {
    // (undocumented)
    readonly mapWithIndex: <E, A, B>(fa: Kind<F, Kind2<G, E, A>>, f: (i: [FI, GI], a: A) => B) => Kind<F, Kind2<G, E, B>>;
}

// @public @deprecated (undocumented)
interface FunctorWithIndexComposition12C<F extends URIS, FI, G extends URIS2, GI, E> extends FunctorComposition12C<F, G, E> {
    // (undocumented)
    readonly mapWithIndex: <A, B>(fa: Kind<F, Kind2<G, E, A>>, f: (i: [FI, GI], a: A) => B) => Kind<F, Kind2<G, E, B>>;
}

// @public @deprecated (undocumented)
interface FunctorWithIndexComposition21<F extends URIS2, FI, G extends URIS, GI> extends FunctorComposition21<F, G> {
    // (undocumented)
    readonly mapWithIndex: <E, A, B>(fa: Kind2<F, E, Kind<G, A>>, f: (i: [FI, GI], a: A) => B) => Kind2<F, E, Kind<G, B>>;
}

// @public @deprecated (undocumented)
interface FunctorWithIndexComposition22<F extends URIS2, FI, G extends URIS2, GI> extends FunctorComposition22<F, G> {
    // (undocumented)
    readonly mapWithIndex: <FE, GE, A, B>(fa: Kind2<F, FE, Kind2<G, GE, A>>, f: (i: [FI, GI], a: A) => B) => Kind2<F, FE, Kind2<G, GE, B>>;
}

// @public @deprecated (undocumented)
interface FunctorWithIndexComposition22C<F extends URIS2, FI, G extends URIS2, GI, E> extends FunctorComposition22C<F, G, E> {
    // (undocumented)
    readonly mapWithIndex: <FE, A, B>(fa: Kind2<F, FE, Kind2<G, E, A>>, f: (i: [FI, GI], a: A) => B) => Kind2<F, FE, Kind2<G, E, B>>;
}

// @public @deprecated (undocumented)
interface FunctorWithIndexComposition2C1<F extends URIS2, FI, G extends URIS, GI, E> extends FunctorComposition2C1<F, G, E> {
    // (undocumented)
    readonly mapWithIndex: <A, B>(fa: Kind2<F, E, Kind<G, A>>, f: (i: [FI, GI], a: A) => B) => Kind2<F, E, Kind<G, B>>;
}

// @public
function gcd<A>(E: Eq<A>, field: Field<A>): (x: A, y: A) => A;

// @public
const geq: <A>(O: Ord<A>) => (first: A, second: A) => boolean;

// @public (undocumented)
function get<F extends URIS4>(F: FromState4<F>): <S, R, E>() => Kind4<F, S, R, E, S>;

// @public (undocumented)
function get<F extends URIS3>(F: FromState3<F>): <S, E>() => Kind3<F, S, E, S>;

// @public (undocumented)
function get<F extends URIS3, E>(F: FromState3C<F, E>): <S>() => Kind3<F, S, E, S>;

// @public (undocumented)
function get<F extends URIS2>(F: FromState2<F>): <S>() => Kind2<F, S, S>;

// @public (undocumented)
function get<F>(F: FromState<F>): <S>() => HKT2<F, S, S>;

// @public
const get_2: <S>() => State<S, S>;

// @public
const get_3: <S, R, E = never>() => StateReaderTaskEither<S, R, E, S>;

// @public
function getAlternativeMonoid<F extends URIS4>(F: Alternative4<F>): <A, S, R, E>(S: Semigroup<A>) => Monoid<Kind4<F, S, R, E, A>>;

// @public (undocumented)
function getAlternativeMonoid<F extends URIS3>(F: Alternative3<F>): <A, R, E>(S: Semigroup<A>) => Monoid<Kind3<F, R, E, A>>;

// @public (undocumented)
function getAlternativeMonoid<F extends URIS3, E>(F: Alternative3C<F, E>): <A, R>(S: Semigroup<A>) => Monoid<Kind3<F, R, E, A>>;

// @public (undocumented)
function getAlternativeMonoid<F extends URIS2>(F: Alternative2<F>): <A, E>(S: Semigroup<A>) => Monoid<Kind2<F, E, A>>;

// @public (undocumented)
function getAlternativeMonoid<F extends URIS2, E>(F: Alternative2C<F, E>): <A>(S: Semigroup<A>) => Monoid<Kind2<F, E, A>>;

// @public (undocumented)
function getAlternativeMonoid<F extends URIS>(F: Alternative1<F>): <A>(S: Semigroup<A>) => Monoid<Kind<F, A>>;

// @public (undocumented)
function getAlternativeMonoid<F>(F: Alternative<F>): <A>(S: Semigroup<A>) => Monoid<HKT<F, A>>;

// @public
function getAltIOValidation<E>(S: Semigroup<E>): Alt2C<URI_13, E>;

// @public
function getAltReaderTaskValidation<E>(S: Semigroup<E>): Alt3C<URI_22, E>;

// @public
function getAltReaderValidation<E>(S: Semigroup<E>): Alt3C<URI_18, E>;

// @public
function getAltTaskValidation<E>(S: Semigroup<E>): Alt2C<URI_23, E>;

// @public
const getAltValidation: <E>(SE: Semigroup<E>) => Alt2C<"Either", E>;

// @public (undocumented)
function getApplicative<E>(M: Monoid<E>): Applicative2C<URI_9, E>;

// @public (undocumented)
function getApplicative_2<M>(M: Monoid<M>): Applicative2C<URI_28, M>;

// @public (undocumented)
function getApplicative_3<E>(A: Apply1<task.URI>, S: Semigroup<E>): Applicative2C<URI_34, E>;

// @public (undocumented)
function getApplicative_4<E>(S: Semigroup<E>): Applicative2C<URI_35, E>;

// @public (undocumented)
function getApplicative_5<M>(M: Monoid<M>): Applicative2C<URI_38, M>;

// @public (undocumented)
const getApplicative_6: <W>(M: Monoid<W>) => Applicative2C<"Writer", W>;

// @public @deprecated
function getApplicativeComposition<F extends URIS2, G extends URIS2, E>(F: Applicative2<F>, G: Applicative2C<G, E>): ApplicativeComposition22C<F, G, E>;

// @public @deprecated (undocumented)
function getApplicativeComposition<F extends URIS2, G extends URIS2>(F: Applicative2<F>, G: Applicative2<G>): ApplicativeComposition22<F, G>;

// @public @deprecated (undocumented)
function getApplicativeComposition<F extends URIS2, G extends URIS2, E>(F: Applicative2<F>, G: Applicative2C<G, E>): ApplicativeComposition22C<F, G, E>;

// @public @deprecated (undocumented)
function getApplicativeComposition<F extends URIS2, G extends URIS>(F: Applicative2<F>, G: Applicative1<G>): ApplicativeComposition21<F, G>;

// @public @deprecated (undocumented)
function getApplicativeComposition<F extends URIS, G extends URIS2>(F: Applicative1<F>, G: Applicative2<G>): ApplicativeComposition12<F, G>;

// @public @deprecated (undocumented)
function getApplicativeComposition<F extends URIS, G extends URIS2, E>(F: Applicative1<F>, G: Applicative2C<G, E>): ApplicativeComposition12C<F, G, E>;

// @public @deprecated (undocumented)
function getApplicativeComposition<F extends URIS, G extends URIS>(F: Applicative1<F>, G: Applicative1<G>): ApplicativeComposition11<F, G>;

// @public @deprecated (undocumented)
function getApplicativeComposition<F, G extends URIS2>(F: Applicative<F>, G: Applicative2<G>): ApplicativeCompositionHKT2<F, G>;

// @public @deprecated (undocumented)
function getApplicativeComposition<F, G extends URIS2, E>(F: Applicative<F>, G: Applicative2C<G, E>): ApplicativeCompositionHKT2C<F, G, E>;

// @public @deprecated (undocumented)
function getApplicativeComposition<F, G extends URIS>(F: Applicative<F>, G: Applicative1<G>): ApplicativeCompositionHKT1<F, G>;

// @public @deprecated (undocumented)
function getApplicativeComposition<F, G>(F: Applicative<F>, G: Applicative<G>): ApplicativeComposition<F, G>;

// @public
function getApplicativeIOValidation<E>(S: Semigroup<E>): Applicative2C<URI_13, E>;

// @public
function getApplicativeMonoid<F extends URIS4>(F: Applicative4<F>): <A, S, R, E>(M: Monoid<A>) => Monoid<Kind4<F, S, R, E, A>>;

// @public (undocumented)
function getApplicativeMonoid<F extends URIS3>(F: Applicative3<F>): <A, R, E>(M: Monoid<A>) => Monoid<Kind3<F, R, E, A>>;

// @public (undocumented)
function getApplicativeMonoid<F extends URIS3, E>(F: Applicative3C<F, E>): <A, R>(M: Monoid<A>) => Monoid<Kind3<F, R, E, A>>;

// @public (undocumented)
function getApplicativeMonoid<F extends URIS2>(F: Applicative2<F>): <A, E>(M: Monoid<A>) => Monoid<Kind2<F, E, A>>;

// @public (undocumented)
function getApplicativeMonoid<F extends URIS2, E>(F: Applicative2C<F, E>): <A>(M: Monoid<A>) => Monoid<Kind2<F, E, A>>;

// @public (undocumented)
function getApplicativeMonoid<F extends URIS>(F: Applicative1<F>): <A>(M: Monoid<A>) => Monoid<Kind<F, A>>;

// @public (undocumented)
function getApplicativeMonoid<F>(F: Applicative<F>): <A>(M: Monoid<A>) => Monoid<HKT<F, A>>;

// @public
function getApplicativeReaderTaskValidation<E>(A: Apply1<task.URI>, S: Semigroup<E>): Applicative3C<URI_22, E>;

// @public
function getApplicativeReaderValidation<E>(S: Semigroup<E>): Applicative3C<URI_18, E>;

// @public
function getApplicativeTaskValidation<E>(A: Apply1<task.URI>, S: Semigroup<E>): Applicative2C<URI_23, E>;

// @public
const getApplicativeValidation: <E>(SE: Semigroup<E>) => Applicative2C<"Either", E>;

// @public (undocumented)
function getApply<E>(S: Semigroup<E>): Apply2C<URI_9, E>;

// @public (undocumented)
function getApply_2<S>(S: Semigroup<S>): Apply2C<URI_28, S>;

// @public (undocumented)
const getApply_3: <E>(A: Apply1<task.URI>, S: Semigroup<E>) => Apply2C<"TaskThese", E>;

// @public (undocumented)
const getApply_4: <E>(S: Semigroup<E>) => Apply2C<"These", E>;

// @public (undocumented)
function getApply_5<S>(S: Semigroup<S>): Apply2C<URI_38, S>;

// @public (undocumented)
const getApply_6: <W>(S: Semigroup<W>) => Apply2C<"Writer", W>;

// @public @deprecated
const getApplyMonoid: <A>(M: Monoid<A>) => Monoid<Option_2<A>>;

// @public @deprecated
const getApplyMonoid_2: <E, A>(M: Monoid<A>) => Monoid<Either<E, A>>;

// @public @deprecated
const getApplyMonoid_3: <E, A>(M: Monoid<A>) => Monoid<IOEither<E, A>>;

// @public @deprecated
const getApplyMonoid_4: <R, E, A>(M: Monoid<A>) => Monoid<ReaderEither<R, E, A>>;

// @public @deprecated
const getApplyMonoid_5: <E, A>(M: Monoid<A>) => Monoid<TaskEither<E, A>>;

// @public @deprecated
const getApplyMonoid_6: <R, E, A>(M: Monoid<A>) => Monoid<ReaderTaskEither<R, E, A>>;

// @public
function getApplySemigroup<F extends URIS4>(F: Apply4<F>): <A, S, R, E>(S: Semigroup<A>) => Semigroup<Kind4<F, S, R, E, A>>;

// @public (undocumented)
function getApplySemigroup<F extends URIS3>(F: Apply3<F>): <A, R, E>(S: Semigroup<A>) => Semigroup<Kind3<F, R, E, A>>;

// @public (undocumented)
function getApplySemigroup<F extends URIS3, E>(F: Apply3C<F, E>): <A, R>(S: Semigroup<A>) => Semigroup<Kind3<F, R, E, A>>;

// @public (undocumented)
function getApplySemigroup<F extends URIS2>(F: Apply2<F>): <A, E>(S: Semigroup<A>) => Semigroup<Kind2<F, E, A>>;

// @public (undocumented)
function getApplySemigroup<F extends URIS2, E>(F: Apply2C<F, E>): <A>(S: Semigroup<A>) => Semigroup<Kind2<F, E, A>>;

// @public (undocumented)
function getApplySemigroup<F extends URIS>(F: Apply1<F>): <A>(S: Semigroup<A>) => Semigroup<Kind<F, A>>;

// @public (undocumented)
function getApplySemigroup<F>(F: Apply<F>): <A>(S: Semigroup<A>) => Semigroup<HKT<F, A>>;

// @public @deprecated
const getApplySemigroup_2: <A>(S: Semigroup<A>) => Semigroup<Option_2<A>>;

// @public @deprecated
const getApplySemigroup_3: <E, A>(S: Semigroup<A>) => Semigroup<Either<E, A>>;

// @public @deprecated
const getApplySemigroup_4: <E, A>(S: Semigroup<A>) => Semigroup<IOEither<E, A>>;

// @public @deprecated
const getApplySemigroup_5: <R, E, A>(S: Semigroup<A>) => Semigroup<ReaderEither<R, E, A>>;

// @public @deprecated
const getApplySemigroup_6: <E, A>(S: Semigroup<A>) => Semigroup<TaskEither<E, A>>;

// @public @deprecated
const getApplySemigroup_7: <R, E, A>(S: Semigroup<A>) => Semigroup<ReaderTaskEither<R, E, A>>;

// @public
const getAssignSemigroup: <A extends object = never>() => Semigroup<A>;

// @public (undocumented)
const getBooleanAlgebra: <E, A>(H: BooleanAlgebra_2<E>) => BooleanAlgebra_2<Const<E, A>>;

// @public (undocumented)
const getBooleanAlgebra_2: <B>(B: BooleanAlgebra_2<B>) => <A = never>() => BooleanAlgebra_2<(a: A) => B>;

// @public (undocumented)
const getBounded: <E, A>(B: Bounded<E>) => Bounded<Const<E, A>>;

// @public (undocumented)
function getChain<S>(S: Semigroup<S>): Chain2C<URI_28, S>;

// @public (undocumented)
function getChain_2<E>(S: Semigroup<E>): Chain2C<URI_34, E>;

// @public (undocumented)
function getChain_3<E>(S: Semigroup<E>): Chain2C<URI_35, E>;

// @public (undocumented)
function getChain_4<S>(S: Semigroup<S>): Chain2C<URI_38, S>;

// @public (undocumented)
function getChain_5<W>(S: Semigroup<W>): Chain2C<URI_39, W>;

// @public (undocumented)
function getChainRec<M>(M: Monoid<M>): ChainRec2C<URI_28, M>;

// @public (undocumented)
function getChainRec_2<M>(M: Monoid<M>): ChainRec2C<URI_38, M>;

// @public (undocumented)
function getComonad<P>(monoid: Monoid<P>): Comonad2C<URI_36, P>;

// @public
const getCompactable: <E>(M: Monoid<E>) => Compactable2C<"Either", E>;

// @public (undocumented)
const getCompactable_2: <E>(M: Monoid<E>) => Compactable2C<"IOEither", E>;

// @public (undocumented)
const getCompactable_3: <E>(M: Monoid<E>) => Compactable3C<"ReaderEither", E>;

// @public (undocumented)
const getCompactable_4: <E>(M: Monoid<E>) => Compactable2C<"TaskEither", E>;

// @public (undocumented)
const getCompactable_5: <E>(M: Monoid<E>) => Compactable3C<"ReaderTaskEither", E>;

// @public @deprecated
function getCompactableComposition<F extends URIS2, G extends URIS3, E>(F: Functor2<F>, G: Compactable3C<G, E> & Functor3C<G, E>): CompactableComposition23C<F, G, E>;

// @public @deprecated (undocumented)
function getCompactableComposition<F extends URIS2, G extends URIS2, E>(F: Functor2<F>, G: Compactable2C<G, E> & Functor2C<G, E>): CompactableComposition22C<F, G, E>;

// @public @deprecated (undocumented)
function getCompactableComposition<F extends URIS2, G extends URIS2>(F: Functor2<F>, G: Compactable2<G> & Functor2<G>): CompactableComposition22<F, G>;

// @public @deprecated (undocumented)
function getCompactableComposition<F extends URIS2, G extends URIS, E>(F: Functor2C<F, E>, G: Compactable1<G> & Functor1<G>): CompactableComposition2C1<F, G, E>;

// @public @deprecated (undocumented)
function getCompactableComposition<F extends URIS2, G extends URIS>(F: Functor2<F>, G: Compactable1<G> & Functor1<G>): CompactableComposition21<F, G>;

// @public @deprecated (undocumented)
function getCompactableComposition<F extends URIS, G extends URIS2, E>(F: Functor1<F>, G: Compactable2C<G, E> & Functor2C<G, E>): CompactableComposition12<F, G>;

// @public @deprecated (undocumented)
function getCompactableComposition<F extends URIS, G extends URIS2>(F: Functor1<F>, G: Compactable2<G> & Functor2<G>): CompactableComposition12<F, G>;

// @public @deprecated (undocumented)
function getCompactableComposition<F extends URIS, G extends URIS>(F: Functor1<F>, G: Compactable1<G> & Functor1<G>): CompactableComposition11<F, G>;

// @public @deprecated (undocumented)
function getCompactableComposition<F, G>(F: Functor<F>, G: Compactable_3<G> & Functor<G>): CompactableComposition<F, G>;

// @public
const getDifferenceMagma: <A>(E: Eq<A>) => Magma<A[]>;

// @public (undocumented)
const getDifferenceMagma_2: <K>(E: Eq<K>) => <A>() => Magma<Map<K, A>>;

// @public (undocumented)
const getDifferenceMagma_3: <A>(E: Eq<A>) => Magma<readonly A[]>;

// @public (undocumented)
const getDifferenceMagma_4: <K>(E: Eq<K>) => <A>() => Magma<ReadonlyMap<K, A>>;

// @public
const getDifferenceMagma_5: <A>() => Magma<Readonly<Record<string, A>>>;

// @public (undocumented)
const getDifferenceMagma_6: <A>(E: Eq<A>) => Magma<ReadonlySet<A>>;

// @public
const getDifferenceMagma_7: <A>() => Magma<Record<string, A>>;

// @public (undocumented)
const getDifferenceMagma_8: <A>(E: Eq<A>) => Magma<Set<A>>;

// @public @deprecated
const getDualBooleanAlgebra: <A>(B: BooleanAlgebra_2<A>) => BooleanAlgebra_2<A>;

// @public @deprecated
const getDualMonoid: <A>(M: Monoid<A>) => Monoid<A>;

// @public @deprecated
const getDualOrd: <A>(O: Ord<A>) => Ord<A>;

// @public @deprecated
const getDualSemigroup: <A>(S: Semigroup<A>) => Semigroup<A>;

// @public @deprecated (undocumented)
function getEitherM<M extends URIS2>(M: Monad2<M>): EitherM2<M>;

// @public @deprecated (undocumented)
function getEitherM<M extends URIS>(M: Monad1<M>): EitherM1<M>;

// @public @deprecated (undocumented)
function getEitherM<M>(M: Monad_6<M>): EitherM<M>;

// @public @deprecated
const getEndomorphismMonoid: <A = never>() => Monoid<Endomorphism<A>>;

// @public @deprecated
const getEndomorphismMonoid_2: <A = never>() => Monoid<Endomorphism_2<A>>;

// @public (undocumented)
const getEq: <A>(E: Eq<A>) => Eq<ReadonlyNonEmptyArray<A>>;

// @public (undocumented)
function getEq_10<K, A>(SK: Eq<K>, SA: Eq<A>): Eq<ReadonlyMap<K, A>>;

// @public
function getEq_11<K extends string, A>(E: Eq<A>): Eq<ReadonlyRecord<K, A>>;

// @public (undocumented)
function getEq_12<A>(E: Eq<A>): Eq<ReadonlySet<A>>;

// @public
const getEq_13: <K extends string, A>(E: Eq<A>) => Eq<Record<K, A>>;

// @public (undocumented)
const getEq_14: <A>(E: Eq<A>) => Eq<Set<A>>;

// @public (undocumented)
function getEq_15<E, A>(EE: Eq<E>, EA: Eq<A>): Eq<These<E, A>>;

// @public (undocumented)
function getEq_16<A>(E: Eq<A>): Eq<Tree<A>>;

// @public (undocumented)
const getEq_2: <A>(E: Eq<A>) => Eq<NonEmptyArray<A>>;

// @public
const getEq_3: <A>(E: Eq<A>) => Eq<Array<A>>;

// @public (undocumented)
const getEq_4: <A>(E: Eq<A>) => Eq<Option_2<A>>;

// @public (undocumented)
const getEq_5: <E, A>(EL: Eq<E>, EA: Eq<A>) => Eq<Either<E, A>>;

// @public (undocumented)
const getEq_6: <E, A>(E: Eq<E>) => Eq<Const<E, A>>;

// @public (undocumented)
const getEq_7: <A>(E: Eq<A>) => Eq<Identity<A>>;

// @public (undocumented)
const getEq_8: <K, A>(SK: Eq<K>, SA: Eq<A>) => Eq<Map<K, A>>;

// @public
const getEq_9: <A>(E: Eq<A>) => Eq<readonly A[]>;

// @public
const getFilterable: <E>(M: Monoid<E>) => Filterable2C<"Either", E>;

// @public (undocumented)
function getFilterable_2<E>(M: Monoid<E>): Filterable2C<URI_13, E>;

// @public (undocumented)
function getFilterable_3<E>(M: Monoid<E>): Filterable3C<URI_18, E>;

// @public (undocumented)
function getFilterable_4<E>(M: Monoid<E>): Filterable3C<URI_22, E>;

// @public (undocumented)
function getFilterable_5<E>(M: Monoid<E>): Filterable2C<URI_23, E>;

// @public @deprecated
function getFilterableComposition<F extends URIS2, G extends URIS3, E>(F: Functor2<F>, G: Filterable3C<G, E>): FilterableComposition23C<F, G, E>;

// @public @deprecated (undocumented)
function getFilterableComposition<F extends URIS2, G extends URIS2, E>(F: Functor2<F>, G: Filterable2C<G, E>): FilterableComposition22C<F, G, E>;

// @public @deprecated (undocumented)
function getFilterableComposition<F extends URIS2, G extends URIS2>(F: Functor2<F>, G: Filterable2<G>): FilterableComposition22<F, G>;

// @public @deprecated (undocumented)
function getFilterableComposition<F extends URIS2, G extends URIS, E>(F: Functor2C<F, E>, G: Filterable1<G>): FilterableComposition2C1<F, G, E>;

// @public @deprecated (undocumented)
function getFilterableComposition<F extends URIS2, G extends URIS>(F: Functor2<F>, G: Filterable1<G>): FilterableComposition21<F, G>;

// @public @deprecated (undocumented)
function getFilterableComposition<F extends URIS, G extends URIS2, E>(F: Functor1<F>, G: Filterable2C<G, E>): FilterableComposition12C<F, G, E>;

// @public @deprecated (undocumented)
function getFilterableComposition<F extends URIS, G extends URIS2>(F: Functor1<F>, G: Filterable2<G>): FilterableComposition12<F, G>;

// @public @deprecated (undocumented)
function getFilterableComposition<F extends URIS, G extends URIS>(F: Functor1<F>, G: Filterable1<G>): FilterableComposition11<F, G>;

// @public @deprecated (undocumented)
function getFilterableComposition<F, G>(F: Functor<F>, G: Filterable_3<G>): FilterableComposition<F, G>;

// @public (undocumented)
function getFilterableWithIndex<K = never>(): FilterableWithIndex2C<URI_15, K, K>;

// @public (undocumented)
function getFilterableWithIndex_2<K = never>(): FilterableWithIndex2C<URI_25, K, K>;

// @public @deprecated
const getFirstMonoid: <A = never>() => Monoid<Option_2<A>>;

// @public @deprecated
const getFirstSemigroup: <A = never>() => Semigroup<A>;

// @public (undocumented)
const getFoldable: <K>(O: Ord<K>) => Foldable2C<"Map", K>;

// @public (undocumented)
const getFoldable_2: <K>(O: Ord<K>) => Foldable2C<"ReadonlyMap", K>;

// @public
const getFoldable_3: (O: Ord<string>) => Foldable1<URI_26>;

// @public
const getFoldable_4: (O: Ord<string>) => Foldable1<URI_29>;

// @public @deprecated
function getFoldableComposition<F extends URIS2, G extends URIS2, E>(F: Foldable2<F>, G: Foldable2C<G, E>): FoldableComposition22C<F, G, E>;

// @public @deprecated (undocumented)
function getFoldableComposition<F extends URIS2, G extends URIS2>(F: Foldable2<F>, G: Foldable2<G>): FoldableComposition22<F, G>;

// @public @deprecated (undocumented)
function getFoldableComposition<F extends URIS2, G extends URIS, E>(F: Foldable2C<F, E>, G: Foldable1<G>): FoldableComposition2C1<F, G, E>;

// @public @deprecated (undocumented)
function getFoldableComposition<F extends URIS2, G extends URIS>(F: Foldable2<F>, G: Foldable1<G>): FoldableComposition21<F, G>;

// @public @deprecated (undocumented)
function getFoldableComposition<F extends URIS, G extends URIS2, E>(F: Foldable1<F>, G: Foldable2C<G, E>): FoldableComposition12C<F, G, E>;

// @public @deprecated (undocumented)
function getFoldableComposition<F extends URIS, G extends URIS2>(F: Foldable1<F>, G: Foldable2<G>): FoldableComposition12<F, G>;

// @public @deprecated (undocumented)
function getFoldableComposition<F extends URIS, G extends URIS>(F: Foldable1<F>, G: Foldable1<G>): FoldableComposition11<F, G>;

// @public @deprecated (undocumented)
function getFoldableComposition<F, G>(F: Foldable_6<F>, G: Foldable_6<G>): FoldableComposition<F, G>;

// @public (undocumented)
const getFoldableWithIndex: <K>(O: Ord<K>) => FoldableWithIndex2C<"Map", K, K>;

// @public (undocumented)
const getFoldableWithIndex_2: <K>(O: Ord<K>) => FoldableWithIndex2C<"ReadonlyMap", K, K>;

// @public
const getFoldableWithIndex_3: (O: Ord<string>) => FoldableWithIndex1<URI_26, string>;

// @public
const getFoldableWithIndex_4: (O: Ord<string>) => FoldableWithIndex1<URI_29, string>;

// @public @deprecated
function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI, E>(F: FoldableWithIndex2<F, FI>, G: FoldableWithIndex2C<G, GI, E>): FoldableWithIndexComposition22C<F, FI, G, GI, E>;

// @public @deprecated (undocumented)
function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI>(F: FoldableWithIndex2<F, FI>, G: FoldableWithIndex2<G, GI>): FoldableWithIndexComposition22<F, FI, G, GI>;

// @public @deprecated (undocumented)
function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS, GI, E>(F: FoldableWithIndex2C<F, FI, E>, G: FoldableWithIndex1<G, GI>): FoldableWithIndexComposition2C1<F, FI, G, GI, E>;

// @public @deprecated (undocumented)
function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS, GI>(F: FoldableWithIndex2<F, FI>, G: FoldableWithIndex1<G, GI>): FoldableWithIndexComposition21<F, FI, G, GI>;

// @public @deprecated (undocumented)
function getFoldableWithIndexComposition<F extends URIS, FI, G extends URIS2, GI>(F: FoldableWithIndex1<F, FI>, G: FoldableWithIndex2<G, GI>): FoldableWithIndexComposition12<F, FI, G, GI>;

// @public @deprecated (undocumented)
function getFoldableWithIndexComposition<F extends URIS, FI, G extends URIS2, GI>(F: FoldableWithIndex1<F, FI>, G: FoldableWithIndex2<G, GI>): FoldableWithIndexComposition12<F, FI, G, GI>;

// @public @deprecated (undocumented)
function getFoldableWithIndexComposition<F extends URIS, FI, G extends URIS, GI>(F: FoldableWithIndex1<F, FI>, G: FoldableWithIndex1<G, GI>): FoldableWithIndexComposition11<F, FI, G, GI>;

// @public @deprecated (undocumented)
function getFoldableWithIndexComposition<F, FI, G, GI>(F: FoldableWithIndex_4<F, FI>, G: FoldableWithIndex_4<G, GI>): FoldableWithIndexComposition<F, FI, G, GI>;

// @public @deprecated
const getFunctionBooleanAlgebra: <B>(B: BooleanAlgebra_2<B>) => <A = never>() => BooleanAlgebra_2<(a: A) => B>;

// @public @deprecated
const getFunctionMonoid: <M>(M: Monoid<M>) => <A = never>() => Monoid<(a: A) => M>;

// @public @deprecated
const getFunctionRing: <A, B>(R: Ring<B>) => Ring<(a: A) => B>;

// @public @deprecated
const getFunctionSemigroup: <S>(S: Semigroup<S>) => <A = never>() => Semigroup<(a: A) => S>;

// @public @deprecated
const getFunctionSemiring: <A, B>(S: Semiring<B>) => Semiring<(a: A) => B>;

// @public @deprecated
function getFunctorComposition<F extends URIS2, G extends URIS3, E>(F: Functor2<F>, G: Functor3C<G, E>): FunctorComposition23C<F, G, E>;

// @public @deprecated (undocumented)
function getFunctorComposition<F extends URIS2, G extends URIS2, E>(F: Functor2<F>, G: Functor2C<G, E>): FunctorComposition22C<F, G, E>;

// @public @deprecated (undocumented)
function getFunctorComposition<F extends URIS2, G extends URIS2>(F: Functor2<F>, G: Functor2<G>): FunctorComposition22<F, G>;

// @public @deprecated (undocumented)
function getFunctorComposition<F extends URIS2, G extends URIS, E>(F: Functor2C<F, E>, G: Functor1<G>): FunctorComposition2C1<F, G, E>;

// @public @deprecated (undocumented)
function getFunctorComposition<F extends URIS2, G extends URIS>(F: Functor2<F>, G: Functor1<G>): FunctorComposition21<F, G>;

// @public @deprecated (undocumented)
function getFunctorComposition<F extends URIS, G extends URIS2, E>(F: Functor1<F>, G: Functor2C<G, E>): FunctorComposition12C<F, G, E>;

// @public @deprecated (undocumented)
function getFunctorComposition<F extends URIS, G extends URIS2>(F: Functor1<F>, G: Functor2<G>): FunctorComposition12<F, G>;

// @public @deprecated (undocumented)
function getFunctorComposition<F extends URIS, G extends URIS>(F: Functor1<F>, G: Functor1<G>): FunctorComposition11<F, G>;

// @public @deprecated (undocumented)
function getFunctorComposition<F, G>(F: Functor<F>, G: Functor<G>): FunctorComposition<F, G>;

// @public (undocumented)
const getFunctorWithIndex: <K = never>() => FunctorWithIndex2C<"ReadonlyMap", K, K>;

// @public @deprecated
function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI, E>(F: FunctorWithIndex2<F, FI>, G: FunctorWithIndex2C<G, FI, E>): FunctorWithIndexComposition22C<F, FI, G, GI, E>;

// @public @deprecated (undocumented)
function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI>(F: FunctorWithIndex2<F, FI>, G: FunctorWithIndex2<G, FI>): FunctorWithIndexComposition22<F, FI, G, GI>;

// @public @deprecated (undocumented)
function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS, GI, E>(F: FunctorWithIndex2C<F, FI, E>, G: FunctorWithIndex1<G, GI>): FunctorWithIndexComposition2C1<F, FI, G, GI, E>;

// @public @deprecated (undocumented)
function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS, GI>(F: FunctorWithIndex2<F, FI>, G: FunctorWithIndex1<G, GI>): FunctorWithIndexComposition21<F, FI, G, GI>;

// @public @deprecated (undocumented)
function getFunctorWithIndexComposition<F extends URIS, FI, G extends URIS2, GI, E>(F: FunctorWithIndex1<F, FI>, G: FunctorWithIndex2C<G, GI, E>): FunctorWithIndexComposition12C<F, FI, G, GI, E>;

// @public @deprecated (undocumented)
function getFunctorWithIndexComposition<F extends URIS, FI, G extends URIS2, GI>(F: FunctorWithIndex1<F, FI>, G: FunctorWithIndex2<G, GI>): FunctorWithIndexComposition12<F, FI, G, GI>;

// @public @deprecated (undocumented)
function getFunctorWithIndexComposition<F extends URIS, FI, G extends URIS, GI>(F: FunctorWithIndex1<F, FI>, G: FunctorWithIndex1<G, GI>): FunctorWithIndexComposition11<F, FI, G, GI>;

// @public @deprecated (undocumented)
function getFunctorWithIndexComposition<F, FI, G, GI>(F: FunctorWithIndex_4<F, FI>, G: FunctorWithIndex_4<G, GI>): FunctorWithIndexComposition<F, FI, G, GI>;

// @public (undocumented)
const getHeytingAlgebra: <E, A>(H: HeytingAlgebra<E>) => HeytingAlgebra<Const<E, A>>;

// @public @deprecated
const getIntercalateSemigroup: <A>(middle: A) => (S: Semigroup<A>) => Semigroup<A>;

// @public
const getIntersectionSemigroup: <A>(E: Eq<A>) => Semigroup<A[]>;

// @public (undocumented)
const getIntersectionSemigroup_2: <K, A>(E: Eq<K>, S: Semigroup<A>) => Semigroup<Map<K, A>>;

// @public (undocumented)
const getIntersectionSemigroup_3: <A>(E: Eq<A>) => Semigroup<readonly A[]>;

// @public (undocumented)
const getIntersectionSemigroup_4: <K, A>(E: Eq<K>, S: Semigroup<A>) => Semigroup<ReadonlyMap<K, A>>;

// @public
const getIntersectionSemigroup_5: <A>(S: Semigroup<A>) => Semigroup<Readonly<Record<string, A>>>;

// @public (undocumented)
const getIntersectionSemigroup_6: <A>(E: Eq<A>) => Semigroup<ReadonlySet<A>>;

// @public
const getIntersectionSemigroup_7: <A>(S: semigroup.Semigroup<A>) => semigroup.Semigroup<Record<string, A>>;

// @public (undocumented)
const getIntersectionSemigroup_8: <A>(E: Eq<A>) => Semigroup<Set<A>>;

// @public @deprecated
function getIOValidation<E>(SE: Semigroup<E>): Monad2C<URI_13, E> & Bifunctor2<URI_13> & Alt2C<URI_13, E> & MonadIO2C<URI_13, E> & MonadThrow2C<URI_13, E>;

// @public @deprecated
const getJoinMonoid: <A>(B: Bounded<A>) => Monoid<A>;

// @public @deprecated
const getJoinSemigroup: <A>(O: ord.Ord<A>) => Semigroup<A>;

// @public @deprecated
const getLastMonoid: <A = never>() => Monoid<Option_2<A>>;

// @public @deprecated
const getLastSemigroup: <A = never>() => Semigroup<A>;

// @public
const getLeft: <E, A>(ma: Either<E, A>) => Option_2<E>;

// @public
function getLeft_2<E, A>(fa: These<E, A>): Option_2<E>;

// @public
function getLeftOnly<E, A>(fa: These<E, A>): Option_2<E>;

// @public @deprecated
const getMeetMonoid: <A>(B: Bounded<A>) => Monoid<A>;

// @public @deprecated
const getMeetSemigroup: <A>(O: ord.Ord<A>) => Semigroup<A>;

// @public (undocumented)
function getMinMaxBoundedDistributiveLattice<A>(O: Ord<A>): (min: A, max: A) => BoundedDistributiveLattice<A>;

// @public (undocumented)
function getMinMaxDistributiveLattice<A>(O: Ord<A>): DistributiveLattice<A>;

// @public (undocumented)
function getMonad<M>(M: Monoid<M>): Monad2C<URI_28, M>;

// @public (undocumented)
function getMonad_2<E>(S: Semigroup<E>): Monad2C<URI_34, E> & MonadTask2C<URI_34, E>;

// @public (undocumented)
function getMonad_3<E>(S: Semigroup<E>): Monad2C<URI_35, E> & MonadThrow2C<URI_35, E>;

// @public (undocumented)
function getMonad_4<M>(M: Monoid<M>): Monad2C<URI_38, M>;

// @public (undocumented)
function getMonad_5<W>(M: Monoid<W>): Monad2C<URI_39, W>;

// @public
const getMonoid: <A = never>() => Monoid<Ord<A>>;

// @public @deprecated
const getMonoid_10: <R, A>(M: Monoid<A>) => Monoid<Reader<R, A>>;

// @public @deprecated
const getMonoid_11: <A>(M: Monoid<A>) => Monoid<Task<A>>;

// @public @deprecated
const getMonoid_12: <R, A>(M: Monoid<A>) => Monoid<ReaderTask<R, A>>;

// @public
const getMonoid_13: <A = never>() => Monoid<readonly A[]>;

// @public
function getMonoid_14<K, A>(SK: Eq<K>, SA: Semigroup<A>): Monoid<ReadonlyMap<K, A>>;

// @public
function getMonoid_15<K extends string, A>(S: Semigroup<A>): Monoid<ReadonlyRecord<K, A>>;

// @public
const getMonoid_16: <K extends string, A>(S: Semigroup<A>) => Monoid<Record<K, A>>;

// @public
const getMonoid_2: <A = never>() => Monoid<A[]>;

// @public
const getMonoid_3: <A>(S: Semigroup<A>) => Monoid<Option_2<A>>;

// @public (undocumented)
const getMonoid_4: <A>() => Monoid<Eq<A>>;

// @public (undocumented)
const getMonoid_5: <E, A>(M: Monoid<E>) => Monoid<Const<E, A>>;

// @public
const getMonoid_6: <A = never>() => Monoid<Endomorphism<A>>;

// @public
const getMonoid_7: <M>(M: Monoid<M>) => <A = never>() => Monoid<(a: A) => M>;

// @public @deprecated
const getMonoid_8: <A>(M: Monoid<A>) => Monoid<IO<A>>;

// @public
function getMonoid_9<K, A>(SK: Eq<K>, SA: Semigroup<A>): Monoid<Map<K, A>>;

// @public (undocumented)
const getMonoidAll: <A = never>() => Monoid<Predicate<A>>;

// @public (undocumented)
const getMonoidAny: <A = never>() => Monoid<Predicate<A>>;

// @public @deprecated
const getObjectSemigroup: <A extends object = never>() => Semigroup<A>;

// @public @deprecated (undocumented)
function getOptionM<M extends URIS2>(M: Monad2<M>): OptionM2<M>;

// @public @deprecated (undocumented)
function getOptionM<M extends URIS2, E>(M: Monad2C<M, E>): OptionM2C<M, E>;

// @public @deprecated (undocumented)
function getOptionM<M extends URIS>(M: Monad1<M>): OptionM1<M>;

// @public @deprecated (undocumented)
function getOptionM<M>(M: Monad_6<M>): OptionM<M>;

// @public
const getOrd: <A>(O: Ord<A>) => Ord<Array<A>>;

// @public
const getOrd_2: <A>(O: Ord<A>) => Ord<Option_2<A>>;

// @public (undocumented)
const getOrd_3: <E, A>(O: Ord<E>) => Ord<Const<E, A>>;

// @public
const getOrd_4: <A>(O: Ord<A>) => Ord<readonly A[]>;

// @public
const getOrElse: <A>(onNone: LazyArg<A>) => (ma: Option_2<A>) => A;

// @public (undocumented)
const getOrElse_10: <A>(onNone: LazyArg<Task<A>>) => (fa: TaskOption<A>) => Task<A>;

// @public
const getOrElse_2: <E, A>(onLeft: (e: E) => A) => (ma: Either<E, A>) => A;

// @public (undocumented)
function getOrElse_3<M extends URIS3>(M: Monad3<M>): <E, R, ME, A>(onLeft: (e: E) => Kind3<M, R, ME, A>) => (ma: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, A>;

// @public (undocumented)
function getOrElse_3<M extends URIS3, ME>(M: Monad3C<M, ME>): <E, R, A>(onLeft: (e: E) => Kind3<M, R, ME, A>) => (ma: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, A>;

// @public (undocumented)
function getOrElse_3<M extends URIS2>(M: Monad2<M>): <E, ME, A>(onLeft: (e: E) => Kind2<M, ME, A>) => (ma: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, A>;

// @public (undocumented)
function getOrElse_3<M extends URIS2, ME>(M: Monad2C<M, ME>): <E, A>(onLeft: (e: E) => Kind2<M, ME, A>) => (ma: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, A>;

// @public (undocumented)
function getOrElse_3<M extends URIS>(M: Monad1<M>): <E, A>(onLeft: (e: E) => Kind<M, A>) => (ma: Kind<M, Either<E, A>>) => Kind<M, A>;

// @public (undocumented)
function getOrElse_3<M>(M: Monad_6<M>): <E, A>(onLeft: (e: E) => HKT<M, A>) => (ma: HKT<M, Either<E, A>>) => HKT<M, A>;

// @public (undocumented)
const getOrElse_4: <E, A>(onLeft: (e: E) => IO<A>) => (ma: IOEither<E, A>) => IO<A>;

// @public (undocumented)
const getOrElse_5: <A>(onNone: LazyArg<IO<A>>) => (fa: IOOption<A>) => IO<A>;

// @public (undocumented)
function getOrElse_6<M extends URIS4>(M: Monad4<M>): <S, R, E, A>(onNone: LazyArg<Kind4<M, S, R, E, A>>) => (fa: Kind4<M, S, R, E, Option_2<A>>) => Kind4<M, S, R, E, A>;

// @public (undocumented)
function getOrElse_6<M extends URIS3>(M: Monad3<M>): <R, E, A>(onNone: LazyArg<Kind3<M, R, E, A>>) => (fa: Kind3<M, R, E, Option_2<A>>) => Kind3<M, R, E, A>;

// @public (undocumented)
function getOrElse_6<M extends URIS3, E>(M: Monad3C<M, E>): <R, A>(onNone: LazyArg<Kind3<M, R, E, A>>) => (fa: Kind3<M, R, E, Option_2<A>>) => Kind3<M, R, E, A>;

// @public (undocumented)
function getOrElse_6<M extends URIS2>(M: Monad2<M>): <E, A>(onNone: LazyArg<Kind2<M, E, A>>) => (fa: Kind2<M, E, Option_2<A>>) => Kind2<M, E, A>;

// @public (undocumented)
function getOrElse_6<M extends URIS2, E>(M: Monad2C<M, E>): <A>(onNone: LazyArg<Kind2<M, E, A>>) => (fa: Kind2<M, E, Option_2<A>>) => Kind2<M, E, A>;

// @public (undocumented)
function getOrElse_6<M extends URIS>(M: Monad1<M>): <A>(onNone: LazyArg<Kind<M, A>>) => (fa: Kind<M, Option_2<A>>) => Kind<M, A>;

// @public (undocumented)
function getOrElse_6<M>(M: Monad_6<M>): <A>(onNone: LazyArg<HKT<M, A>>) => (fa: HKT<M, Option_2<A>>) => HKT<M, A>;

// @public (undocumented)
const getOrElse_7: <E, R, A>(onLeft: (e: E) => Reader<R, A>) => (ma: ReaderEither<R, E, A>) => Reader<R, A>;

// @public (undocumented)
const getOrElse_8: <R, E, A>(onLeft: (e: E) => ReaderTask<R, A>) => (ma: ReaderTaskEither<R, E, A>) => ReaderTask<R, A>;

// @public (undocumented)
const getOrElse_9: <E, A>(onLeft: (e: E) => Task<A>) => (ma: TaskEither<E, A>) => Task<A>;

// @public
const getOrElseW: <B>(onNone: LazyArg<B>) => <A>(ma: Option_2<A>) => B | A;

// @public
const getOrElseW_2: <E, B>(onLeft: (e: E) => B) => <A>(ma: Either<E, A>) => B | A;

// @public
const getOrElseW_3: <E, B>(onLeft: (e: E) => IO<B>) => <A>(ma: IOEither<E, A>) => IO<A | B>;

// @public
const getOrElseW_4: <B>(onNone: LazyArg<IO<B>>) => <A>(ma: IOOption<A>) => IO<A | B>;

// @public
const getOrElseW_5: <R2, E, B>(onLeft: (e: E) => Reader<R2, B>) => <R1, A>(ma: ReaderEither<R1, E, A>) => Reader<R1 & R2, A | B>;

// @public
const getOrElseW_6: <R2, E, B>(onLeft: (e: E) => ReaderTask<R2, B>) => <R1, A>(ma: ReaderTaskEither<R1, E, A>) => ReaderTask<R1 & R2, A | B>;

// @public
const getOrElseW_7: <E, B>(onLeft: (e: E) => Task<B>) => <A>(ma: TaskEither<E, A>) => Task<A | B>;

// @public
const getOrElseW_8: <B>(onNone: LazyArg<Task<B>>) => <A>(ma: TaskOption<A>) => Task<A | B>;

// @public (undocumented)
const getPointed: <W>(M: Monoid<W>) => Pointed2C<"Writer", W>;

// @public
function getRaceMonoid<A = never>(): Monoid<Task<A>>;

// @public @deprecated (undocumented)
function getReaderM<M extends URIS3>(M: Monad3<M>): ReaderM3<M>;

// @public @deprecated (undocumented)
function getReaderM<M extends URIS2>(M: Monad2<M>): ReaderM2<M>;

// @public @deprecated (undocumented)
function getReaderM<M extends URIS2, E>(M: Monad2C<M, E>): ReaderM2C<M, E>;

// @public @deprecated (undocumented)
function getReaderM<M extends URIS>(M: Monad1<M>): ReaderM1<M>;

// @public @deprecated (undocumented)
function getReaderM<M>(M: Monad_6<M>): ReaderM<M>;

// @public @deprecated
function getReaderTaskValidation<E>(SE: Semigroup<E>): Monad3C<URI_22, E> & Bifunctor3<URI_22> & Alt3C<URI_22, E> & MonadTask3C<URI_22, E> & MonadThrow3C<URI_22, E>;

// @public @deprecated
function getReaderValidation<E>(SE: Semigroup<E>): Monad3C<URI_18, E> & Bifunctor3<URI_18> & Alt3C<URI_18, E> & MonadThrow3C<URI_18, E>;

// @public @deprecated
function getRefinement<A, B extends A>(getOption: (a: A) => Option_2<B>): Refinement<A, B>;

// @public
const getRight: <E, A>(ma: Either<E, A>) => Option_2<A>;

// @public
function getRight_2<E, A>(fa: These<E, A>): Option_2<A>;

// @public
function getRightOnly<E, A>(fa: These<E, A>): Option_2<A>;

// @public (undocumented)
const getRing: <E, A>(S: Ring<E>) => Ring<Const<E, A>>;

// @public (undocumented)
const getRing_2: <A, B>(R: Ring<B>) => Ring<(a: A) => B>;

// @public (undocumented)
function gets<F extends URIS4>(F: FromState4<F>): <S, R, E, A>(f: (s: S) => A) => Kind4<F, S, R, E, A>;

// @public (undocumented)
function gets<F extends URIS3>(F: FromState3<F>): <S, E, A>(f: (s: S) => A) => Kind3<F, S, E, A>;

// @public (undocumented)
function gets<F extends URIS3, E>(F: FromState3C<F, E>): <S, A>(f: (s: S) => A) => Kind3<F, S, E, A>;

// @public (undocumented)
function gets<F extends URIS2>(F: FromState2<F>): <S, A>(f: (s: S) => A) => Kind2<F, S, A>;

// @public (undocumented)
function gets<F>(F: FromState<F>): <S, A>(f: (s: S) => A) => HKT2<F, S, A>;

// @public
const gets_2: <S, A>(f: (s: S) => A) => State<S, A>;

// @public
const gets_3: <S, R, E = never, A = never>(f: (s: S) => A) => StateReaderTaskEither<S, R, E, A>;

// @public
const getSemigroup: <A = never>() => Semigroup<Ord<A>>;

// @public @deprecated
const getSemigroup_10: <A>(S: Semigroup<A>) => Semigroup<IO<A>>;

// @public @deprecated
const getSemigroup_11: <E, A>(S: Semigroup<A>) => Semigroup<IOEither<E, A>>;

// @public @deprecated
const getSemigroup_12: <R, A>(S: Semigroup<A>) => Semigroup<Reader<R, A>>;

// @public @deprecated
const getSemigroup_13: <R, E, A>(S: Semigroup<A>) => Semigroup<ReaderEither<R, E, A>>;

// @public @deprecated
const getSemigroup_14: <A>(S: Semigroup<A>) => Semigroup<Task<A>>;

// @public @deprecated
const getSemigroup_15: <R, A>(S: Semigroup<A>) => Semigroup<ReaderTask<R, A>>;

// @public @deprecated
const getSemigroup_16: <E, A>(S: Semigroup<A>) => Semigroup<TaskEither<E, A>>;

// @public @deprecated
const getSemigroup_17: <R, E, A>(S: Semigroup<A>) => Semigroup<ReaderTaskEither<R, E, A>>;

// @public (undocumented)
const getSemigroup_18: <A = never>() => Semigroup<readonly A[]>;

// @public (undocumented)
function getSemigroup_19<E, A>(SE: Semigroup<E>, SA: Semigroup<A>): Semigroup<These<E, A>>;

// @public
const getSemigroup_2: <A = never>() => semigroup.Semigroup<ReadonlyNonEmptyArray<A>>;

// @public @deprecated
const getSemigroup_20: <E, A>(SE: Semigroup<E>, SA: Semigroup<A>) => Semigroup<TaskThese<E, A>>;

// @public
const getSemigroup_3: <A = never>() => Semigroup<NonEmptyArray<A>>;

// @public
const getSemigroup_4: <A = never>() => Semigroup<A[]>;

// @public
const getSemigroup_5: <E, A>(S: Semigroup<A>) => Semigroup<Either<E, A>>;

// @public (undocumented)
const getSemigroup_6: <A>() => Semigroup<Eq<A>>;

// @public (undocumented)
const getSemigroup_7: <E, A>(S: Semigroup<E>) => Semigroup<Const<E, A>>;

// @public
const getSemigroup_8: <A = never>() => Semigroup<Endomorphism<A>>;

// @public
const getSemigroup_9: <S>(S: Semigroup<S>) => <A = never>() => Semigroup<(a: A) => S>;

// @public (undocumented)
const getSemigroupAll: <A = never>() => Semigroup<Predicate<A>>;

// @public (undocumented)
const getSemigroupAny: <A = never>() => Semigroup<Predicate<A>>;

// @public (undocumented)
const getSemiring: <E, A>(S: Semiring<E>) => Semiring<Const<E, A>>;

// @public (undocumented)
const getSemiring_2: <A, B>(S: Semiring<B>) => Semiring<(a: A) => B>;

// @public (undocumented)
const getShow: <A>(S: Show<A>) => Show<ReadonlyNonEmptyArray<A>>;

// @public (undocumented)
function getShow_10<K, A>(SK: Show<K>, SA: Show<A>): Show<ReadonlyMap<K, A>>;

// @public
function getShow_11(O: Ord<string>): <A>(S: Show<A>) => Show<ReadonlyRecord<string, A>>;

// @public @deprecated
function getShow_11<A>(S: Show<A>): Show<ReadonlyRecord<string, A>>;

// @public (undocumented)
function getShow_12<A>(S: Show<A>): Show<ReadonlySet<A>>;

// @public
function getShow_13(O: Ord<string>): <A>(S: Show<A>) => Show<Record<string, A>>;

// @public @deprecated
function getShow_13<A>(S: Show<A>): Show<Record<string, A>>;

// @public (undocumented)
const getShow_14: <A>(S: Show<A>) => Show<Set<A>>;

// @public (undocumented)
function getShow_15<E, A>(SE: Show<E>, SA: Show<A>): Show<These<E, A>>;

// @public (undocumented)
function getShow_16<A>(S: Show<A>): Show<Tree<A>>;

// @public (undocumented)
const getShow_2: <A>(S: Show<A>) => Show<NonEmptyArray<A>>;

// @public
const getShow_3: <A>(S: Show<A>) => Show<Array<A>>;

// @public (undocumented)
const getShow_4: <A>(S: Show<A>) => Show<Option_2<A>>;

// @public (undocumented)
const getShow_5: <E, A>(SE: Show<E>, SA: Show<A>) => Show<Either<E, A>>;

// @public (undocumented)
function getShow_6<E, A>(S: Show<E>): Show<Const<E, A>>;

// @public (undocumented)
const getShow_7: <A>(S: Show<A>) => Show<Identity<A>>;

// @public (undocumented)
const getShow_8: <K, A>(SK: Show<K>, SA: Show<A>) => Show<Map<K, A>>;

// @public (undocumented)
const getShow_9: <A>(S: Show<A>) => Show<readonly A[]>;

// @public @deprecated (undocumented)
function getStateM<M extends URIS3>(M: Monad3<M>): StateM3<M>;

// @public @deprecated (undocumented)
function getStateM<M extends URIS3, E>(M: Monad3C<M, E>): StateM3C<M, E>;

// @public @deprecated (undocumented)
function getStateM<M extends URIS2>(M: Monad2<M>): StateM2<M>;

// @public @deprecated (undocumented)
function getStateM<M extends URIS2, E>(M: Monad2C<M, E>): StateM2C<M, E>;

// @public @deprecated (undocumented)
function getStateM<M extends URIS>(M: Monad1<M>): StateM1<M>;

// @public @deprecated (undocumented)
function getStateM<M>(M: Monad_6<M>): StateM<M>;

// @public @deprecated
const getStructEq: <O extends ReadonlyRecord<string, any>>(eqs: {
    [K in keyof O]: Eq<O[K]>;
}) => Eq<O>;

// @public @deprecated
const getStructMonoid: <O extends ReadonlyRecord<string, any>>(monoids: {
    [K in keyof O]: Monoid<O[K]>;
}) => Monoid<O>;

// @public @deprecated
const getStructSemigroup: <O extends ReadonlyRecord<string, any>>(semigroups: {
    [K in keyof O]: Semigroup<O[K]>;
}) => Semigroup<O>;

// @public @deprecated
const getStructShow: <O extends ReadonlyRecord<string, any>>(shows: {
    [K in keyof O]: Show<O[K]>;
}) => Show<O>;

// @public @deprecated
function getTaskValidation<E>(SE: Semigroup<E>): Monad2C<URI_23, E> & Bifunctor2<URI_23> & Alt2C<URI_23, E> & MonadTask2C<URI_23, E> & MonadThrow2C<URI_23, E>;

// @public @deprecated (undocumented)
function getTheseM<M extends URIS2>(M: Monad2<M>): TheseM2<M>;

// @public @deprecated (undocumented)
function getTheseM<M extends URIS>(M: Monad1<M>): TheseM1<M>;

// @public @deprecated (undocumented)
function getTheseM<M>(M: Monad_6<M>): TheseM<M>;

// @public (undocumented)
const getTraversable: <K>(O: Ord<K>) => Traversable2C<"ReadonlyMap", K>;

// @public
const getTraversable_2: (O: Ord<string>) => Traversable1<URI_26>;

// @public
const getTraversable_3: (O: Ord<string>) => Traversable1<URI_29>;

// @public @deprecated
function getTraversableComposition<F extends URIS, G extends URIS>(F: Traversable1<F>, G: Traversable1<G>): TraversableComposition11<F, G>;

// @public @deprecated (undocumented)
function getTraversableComposition<F, G>(F: Traversable_12<F>, G: Traversable_12<G>): TraversableComposition<F, G>;

// @public (undocumented)
const getTraversableWithIndex: <K>(O: Ord<K>) => TraversableWithIndex2C<"Map", K, K>;

// @public (undocumented)
const getTraversableWithIndex_2: <K>(O: Ord<K>) => TraversableWithIndex2C<"ReadonlyMap", K, K>;

// @public
const getTraversableWithIndex_3: (O: Ord<string>) => TraversableWithIndex1<URI_26, string>;

// @public
const getTraversableWithIndex_4: (O: Ord<string>) => TraversableWithIndex1<URI_29, string>;

// @public @deprecated
const getTupleEq: <T extends ReadonlyArray<Eq<any>>>(...eqs: T) => Eq<{
    [K in keyof T]: T[K] extends Eq<infer A> ? A : never;
}>;

// @public @deprecated
const getTupleMonoid: <T extends ReadonlyArray<Monoid<any>>>(...monoids: T) => Monoid<{
    [K in keyof T]: T[K] extends semigroup.Semigroup<infer A> ? A : never;
}>;

// @public @deprecated
const getTupleOrd: <T extends ReadonlyArray<Ord<any>>>(...ords: T) => Ord<{
    [K in keyof T]: T[K] extends Ord<infer A> ? A : never;
}>;

// @public @deprecated
const getTupleRing: <T extends ReadonlyArray<Ring<any>>>(...rings: T) => Ring<{
    [K in keyof T]: T[K] extends Ring<infer A> ? A : never;
}>;

// @public @deprecated
const getTupleSemigroup: <T extends ReadonlyArray<Semigroup<any>>>(...semigroups: T) => Semigroup<{
    [K in keyof T]: T[K] extends Semigroup<infer A> ? A : never;
}>;

// @public @deprecated
const getTupleShow: <T extends ReadonlyArray<Show<any>>>(...shows: T) => Show<{
    [K in keyof T]: T[K] extends Show<infer A> ? A : never;
}>;

// @public
const getUnionMonoid: <A>(E: Eq<A>) => Monoid<A[]>;

// @public (undocumented)
const getUnionMonoid_2: <K, A>(E: Eq<K>, S: Semigroup<A>) => Monoid<Map<K, A>>;

// @public (undocumented)
const getUnionMonoid_3: <A>(E: Eq<A>) => Monoid<readonly A[]>;

// @public (undocumented)
const getUnionMonoid_4: <K, A>(E: Eq<K>, S: Semigroup<A>) => Monoid<ReadonlyMap<K, A>>;

// @public
const getUnionMonoid_5: <A>(S: Semigroup<A>) => Monoid<Readonly<Record<string, A>>>;

// @public (undocumented)
const getUnionMonoid_6: <A>(E: Eq<A>) => Monoid<ReadonlySet<A>>;

// @public
const getUnionMonoid_7: <A>(S: semigroup.Semigroup<A>) => Monoid<Record<string, A>>;

// @public (undocumented)
const getUnionMonoid_8: <A>(E: Eq<A>) => Monoid<Set<A>>;

// @public (undocumented)
const getUnionSemigroup: <A>(E: Eq<A>) => semigroup.Semigroup<ReadonlyNonEmptyArray<A>>;

// @public (undocumented)
const getUnionSemigroup_10: <A>(E: Eq<A>) => Semigroup<Set<A>>;

// @public (undocumented)
const getUnionSemigroup_2: <A>(E: Eq<A>) => Semigroup<NonEmptyArray<A>>;

// @public
const getUnionSemigroup_3: <A>(E: Eq<A>) => Semigroup<A[]>;

// @public (undocumented)
const getUnionSemigroup_4: <K, A>(E: Eq<K>, S: Semigroup<A>) => Semigroup<Map<K, A>>;

// @public (undocumented)
const getUnionSemigroup_5: <A>(E: Eq<A>) => Semigroup<readonly A[]>;

// @public (undocumented)
const getUnionSemigroup_6: <K, A>(E: Eq<K>, S: Semigroup<A>) => Semigroup<ReadonlyMap<K, A>>;

// @public
const getUnionSemigroup_7: <A>(S: Semigroup<A>) => Semigroup<Readonly<Record<string, A>>>;

// @public (undocumented)
const getUnionSemigroup_8: <A>(E: Eq<A>) => Semigroup<ReadonlySet<A>>;

// @public
const getUnionSemigroup_9: <A>(S: semigroup.Semigroup<A>) => semigroup.Semigroup<Record<string, A>>;

// @public @deprecated
function getValidation<E>(SE: Semigroup<E>): Monad2C<URI_6, E> & Foldable2<URI_6> & Traversable2<URI_6> & Bifunctor2<URI_6> & Alt2C<URI_6, E> & Extend2<URI_6> & chainRec.ChainRec2C<URI_6, E> & MonadThrow2C<URI_6, E>;

// @public @deprecated
function getValidationM<E, M extends URIS2>(S: Semigroup<E>, M: Monad2<M>): ValidationM2<M, E>;

// @public @deprecated (undocumented)
function getValidationM<E, M extends URIS>(S: Semigroup<E>, M: Monad1<M>): ValidationM1<M, E>;

// @public @deprecated (undocumented)
function getValidationM<E, M>(S: Semigroup<E>, M: Monad_6<M>): ValidationM<M, E>;

// @public @deprecated
const getValidationMonoid: <E, A>(SE: Semigroup<E>, MA: Monoid<A>) => Monoid<Either<E, A>>;

// @public @deprecated
const getValidationSemigroup: <E, A>(SE: Semigroup<E>, SA: Semigroup<A>) => Semigroup<Either<E, A>>;

// @public
const getWitherable: <E>(M: Monoid<E>) => Witherable2C<"Either", E>;

// @public (undocumented)
function getWitherable_2<K>(O: Ord<K>): Witherable2C<URI_15, K> & TraversableWithIndex2C<URI_15, K, K>;

// @public (undocumented)
function getWitherable_3<K>(O: Ord<K>): Witherable2C<URI_25, K> & TraversableWithIndex2C<URI_25, K, K>;

// @public (undocumented)
const getWitherable_4: (O: Ord<string>) => Witherable1<URI_26>;

// @public (undocumented)
const getWitherable_5: (O: Ord<string>) => Witherable1<URI_29>;

// @public (undocumented)
function getWriterM<M extends URIS3>(M: Monad3<M>): WriterM3<M>;

// @public (undocumented)
function getWriterM<M extends URIS2>(M: Monad2<M>): WriterM2<M>;

// @public (undocumented)
function getWriterM<M extends URIS2, E>(M: Monad2C<M, E>): WriterM2C<M, E>;

// @public (undocumented)
function getWriterM<M extends URIS>(M: Monad1<M>): WriterM1<M>;

// @public (undocumented)
function getWriterM<M>(M: Monad_6<M>): WriterM<M>;

// @public (undocumented)
interface Group<A> extends Monoid<A> {
    // (undocumented)
    readonly inverse: (a: A) => A;
}

declare namespace group {
    export {
        Group
    }
}
export { group }

// @public
function group_2<B>(E: Eq<B>): {
    <A extends B>(as: NonEmptyArray<A>): NonEmptyArray<NonEmptyArray<A>>;
    <A extends B>(as: Array<A>): Array<NonEmptyArray<A>>;
};

// @public
function group_3<B>(E: Eq<B>): {
    <A extends B>(as: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<ReadonlyNonEmptyArray<A>>;
    <A extends B>(as: ReadonlyArray<A>): ReadonlyArray<ReadonlyNonEmptyArray<A>>;
};

// @public
const groupBy: <A>(f: (a: A) => string) => (as: readonly A[]) => Readonly<Record<string, ReadonlyNonEmptyArray<A>>>;

// @public
const groupBy_2: <A>(f: (a: A) => string) => (as: A[]) => Record<string, NonEmptyArray<A>>;

// @public @deprecated
function groupSort<B>(O: Ord<B>): {
    <A extends B>(as: NonEmptyArray<A>): NonEmptyArray<NonEmptyArray<A>>;
    <A extends B>(as: Array<A>): Array<NonEmptyArray<A>>;
};

// @public @deprecated
function groupSort_2<B>(O: Ord<B>): {
    <A extends B>(as: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<ReadonlyNonEmptyArray<A>>;
    <A extends B>(as: ReadonlyArray<A>): ReadonlyArray<ReadonlyNonEmptyArray<A>>;
};

// @public
const gt: <A>(O: Ord<A>) => (first: A, second: A) => boolean;

// @public (undocumented)
const guard: (b: boolean) => void[];

// @public (undocumented)
const guard_2: (b: boolean) => Option_2<void>;

// @public (undocumented)
const guard_3: (b: boolean) => IOOption<void>;

// @public (undocumented)
const guard_4: (b: boolean) => readonly void[];

// @public (undocumented)
const guard_5: (b: boolean) => TaskOption<void>;

// @public (undocumented)
function guard_6<F extends URIS4>(F: Zero4<F>, P: Pointed4<F>): <S, R, E>(b: boolean) => Kind4<F, S, R, E, void>;

// @public (undocumented)
function guard_6<F extends URIS3>(F: Zero3<F>, P: Pointed3<F>): <R, E>(b: boolean) => Kind3<F, R, E, void>;

// @public (undocumented)
function guard_6<F extends URIS3, E>(F: Zero3C<F, E>, P: Pointed3C<F, E>): <R>(b: boolean) => Kind3<F, R, E, void>;

// @public (undocumented)
function guard_6<F extends URIS2>(F: Zero2<F>, P: Pointed2<F>): <E>(b: boolean) => Kind2<F, E, void>;

// @public (undocumented)
function guard_6<F extends URIS2, E>(F: Zero2C<F, E>, P: Pointed2C<F, E>): (b: boolean) => Kind2<F, E, void>;

// @public (undocumented)
function guard_6<F extends URIS>(F: Zero1<F>, P: Pointed1<F>): (b: boolean) => Kind<F, void>;

// @public (undocumented)
function guard_6<F>(F: Zero<F>, P: Pointed<F>): (b: boolean) => HKT<F, void>;

// @public
const has: <K extends string>(k: string, r: Readonly<Record<K, unknown>>) => k is K;

// @public
const has_2: <K extends string>(k: string, r: Record<K, unknown>) => k is K;

// @public @deprecated
function hasOwnProperty<K extends string>(k: string, r: ReadonlyRecord<K, unknown>): k is K;

// @public @deprecated
const hasOwnProperty_2: <K extends string>(k: string, r: Record<K, unknown>) => k is K;

// @public (undocumented)
const head: <A>(as: ReadonlyNonEmptyArray<A>) => A;

// @public (undocumented)
const head_2: <A>(nea: NonEmptyArray<A>) => A;

// @public
const head_3: <A>(as: Array<A>) => Option_2<A>;

// @public
const head_4: <A>(as: readonly A[]) => Option_2<A>;

// @public (undocumented)
interface HeytingAlgebra<A> extends BoundedDistributiveLattice<A> {
    // (undocumented)
    readonly implies: (x: A, y: A) => A;
    // (undocumented)
    readonly not: (x: A) => A;
}

declare namespace heytingAlgebra {
    export {
        HeytingAlgebra
    }
}
export { heytingAlgebra }

// @public
interface HKT<URI, A> {
    // (undocumented)
    readonly _A: A;
    // (undocumented)
    readonly _URI: URI;
}

declare namespace hkt {
    export {
        HKT,
        HKT2,
        HKT3,
        HKT4,
        URItoKind,
        URItoKind2,
        URItoKind3,
        URItoKind4,
        URIS,
        URIS2,
        URIS3,
        URIS4,
        Kind,
        Kind2,
        Kind3,
        Kind4
    }
}
export { hkt }

// @public
interface HKT2<URI, E, A> extends HKT<URI, A> {
    // (undocumented)
    readonly _E: E;
}

// @public
interface HKT3<URI, R, E, A> extends HKT2<URI, E, A> {
    // (undocumented)
    readonly _R: R;
}

// @public
interface HKT4<URI, S, R, E, A> extends HKT3<URI, R, E, A> {
    // (undocumented)
    readonly _S: S;
}

// @public
const hole: <T>() => T;

// @public (undocumented)
const id: Category2<URI_17>['id'];

// @public (undocumented)
const id_2: <A>() => Refinement<A, A>;

// @public (undocumented)
type Identity<A> = A;

declare namespace identity {
    export {
        Identity,
        map_11 as map,
        ap_8 as ap,
        of_6 as of,
        flatMap_6 as flatMap,
        extend_7 as extend,
        extract_3 as extract,
        duplicate_6 as duplicate,
        flatten_6 as flatten,
        reduce_7 as reduce,
        foldMap_7 as foldMap,
        reduceRight_7 as reduceRight,
        traverse_6 as traverse,
        sequence_6 as sequence,
        altW_6 as altW,
        alt_8 as alt,
        URI_11 as URI,
        getShow_7 as getShow,
        getEq_7 as getEq,
        Functor_9 as Functor,
        flap_9 as flap,
        Pointed_7 as Pointed,
        Apply_7 as Apply,
        apFirst_7 as apFirst,
        apSecond_7 as apSecond,
        Applicative_7 as Applicative,
        Chain_7 as Chain,
        Monad_7 as Monad,
        chainFirst_7 as chainFirst,
        Foldable_7 as Foldable,
        Traversable_6 as Traversable,
        Alt_7 as Alt,
        Comonad_4 as Comonad,
        chainRec_3 as chainRec,
        ChainRec_4 as ChainRec,
        Do_6 as Do,
        bindTo_7 as bindTo,
        let__7 as let,
        bind_7 as bind,
        apS_7 as apS,
        chain_8 as chain,
        identity_3 as identity
    }
}
export { identity }

// @public (undocumented)
function identity_2<A>(a: A): A;

// @public @deprecated
const identity_3: Monad1<URI_11> & Foldable1<URI_11> & Traversable1<URI_11> & Alt1<URI_11> & Comonad1<URI_11> & ChainRec1<URI_11>;

// @public (undocumented)
const includes: (searchString: string, position?: number) => (s: string) => boolean;

// @public (undocumented)
function increment(n: number): number;

// @public (undocumented)
const info: <A>(a: A) => IO<void>;

// @public
const init: <A>(as: ReadonlyNonEmptyArray<A>) => readonly A[];

// @public
const init_2: <A>(as: NonEmptyArray<A>) => A[];

// @public
const init_3: <A>(as: A[]) => Option_2<A[]>;

// @public
const init_4: <A>(as: readonly A[]) => Option_2<readonly A[]>;

// @public
function insert<A>(E: Eq<A>): (a: A) => (set: ReadonlySet<A>) => ReadonlySet<A>;

// @public
function insert_2<A>(E: Eq<A>): (a: A) => (set: Set<A>) => Set<A>;

// @public @deprecated
const insertAt: <A>(i: number, a: A) => (as: readonly A[]) => Option_2<ReadonlyNonEmptyArray<A>>;

// @public (undocumented)
const insertAt_2: <A>(i: number, a: A) => (as: A[]) => Option_2<NonEmptyArray<A>>;

// @public
const insertAt_3: <A>(i: number, a: A) => (as: A[]) => Option_2<nonEmptyArray.NonEmptyArray<A>>;

// @public @deprecated
const insertAt_4: <K>(E: Eq<K>) => <A>(k: K, a: A) => (m: Map<K, A>) => Map<K, A>;

// @public
const insertAt_5: <A>(i: number, a: A) => (as: readonly A[]) => Option_2<readonlyNonEmptyArray.ReadonlyNonEmptyArray<A>>;

// @public @deprecated
const insertAt_6: <K>(E: Eq<K>) => <A>(k: K, a: A) => (m: ReadonlyMap<K, A>) => ReadonlyMap<K, A>;

// @public @deprecated
const insertAt_7: <A>(k: string, a: A) => (r: ReadonlyRecord<string, A>) => ReadonlyRecord<string, A>;

// @public @deprecated
const insertAt_8: <A>(k: string, a: A) => (r: Record<string, A>) => Record<string, A>;

// @public
const intercalate: <A>(middle: A) => (S: Semigroup<A>) => Semigroup<A>;

// @public
const intercalate_2: <A>(S: semigroup.Semigroup<A>) => (middle: A) => (as: ReadonlyNonEmptyArray<A>) => A;

// @public
const intercalate_3: <A>(S: Semigroup<A>) => (middle: A) => (as: NonEmptyArray<A>) => A;

// @public
const intercalate_4: <A>(M: Monoid<A>) => (middle: A) => (as: Array<A>) => A;

// @public
function intercalate_5<M, F extends URIS3>(M: Monoid<M>, F: Foldable3<F>): <R, E>(middle: M, fm: Kind3<F, R, E, M>) => M;

// @public (undocumented)
function intercalate_5<M, F extends URIS2>(M: Monoid<M>, F: Foldable2<F>): <E>(middle: M, fm: Kind2<F, E, M>) => M;

// @public (undocumented)
function intercalate_5<M, F extends URIS2, E>(M: Monoid<M>, F: Foldable2C<F, E>): (middle: M, fm: Kind2<F, E, M>) => M;

// @public (undocumented)
function intercalate_5<M, F extends URIS>(M: Monoid<M>, F: Foldable1<F>): (middle: M, fm: Kind<F, M>) => M;

// @public (undocumented)
function intercalate_5<M, F>(M: Monoid<M>, F: Foldable_6<F>): (middle: M, fm: HKT<F, M>) => M;

// @public
const intercalate_6: <A>(M: Monoid<A>) => (middle: A) => (as: readonly A[]) => A;

// @public
function intersection<A>(E: Eq<A>): {
    (xs: Array<A>): (ys: Array<A>) => Array<A>;
    (xs: Array<A>, ys: Array<A>): Array<A>;
};

// @public (undocumented)
const intersection_2: <K, A>(E: Eq<K>, M: Magma<A>) => (second: Map<K, A>) => (first: Map<K, A>) => Map<K, A>;

// @public
function intersection_3<A>(E: Eq<A>): {
    (xs: ReadonlyArray<A>): (ys: ReadonlyArray<A>) => ReadonlyArray<A>;
    (xs: ReadonlyArray<A>, ys: ReadonlyArray<A>): ReadonlyArray<A>;
};

// @public (undocumented)
const intersection_4: <K, A>(E: Eq<K>, M: Magma<A>) => (second: ReadonlyMap<K, A>) => (first: ReadonlyMap<K, A>) => ReadonlyMap<K, A>;

// @public
const intersection_5: <A>(M: Magma<A>) => (second: Readonly<Record<string, A>>) => (first: Readonly<Record<string, A>>) => Readonly<Record<string, A>>;

// @public
function intersection_6<A>(E: Eq<A>): {
    (that: ReadonlySet<A>): (me: ReadonlySet<A>) => ReadonlySet<A>;
    (me: ReadonlySet<A>, that: ReadonlySet<A>): ReadonlySet<A>;
};

// @public
const intersection_7: <A>(M: Magma<A>) => (second: Record<string, A>) => (first: Record<string, A>) => Record<string, A>;

// @public
function intersection_8<A>(E: Eq<A>): {
    (that: Set<A>): (me: Set<A>) => Set<A>;
    (me: Set<A>, that: Set<A>): Set<A>;
};

// @public
const intersperse: <A>(middle: A) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public
const intersperse_2: <A>(middle: A) => (as: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public
const intersperse_3: <A>(middle: A) => (as: A[]) => A[];

// @public
const intersperse_4: <A>(middle: A) => (as: readonly A[]) => readonly A[];

// @public (undocumented)
interface Invariant<F> {
    // (undocumented)
    readonly imap: <A, B>(fa: HKT<F, A>, f: (a: A) => B, g: (b: B) => A) => HKT<F, B>;
    // (undocumented)
    readonly URI: F;
}

declare namespace invariant {
    export {
        Invariant,
        Invariant1,
        Invariant2,
        Invariant2C,
        Invariant3,
        Invariant3C,
        Invariant4
    }
}
export { invariant }

// @public (undocumented)
interface Invariant1<F extends URIS> {
    // (undocumented)
    readonly imap: <A, B>(fa: Kind<F, A>, f: (a: A) => B, g: (b: B) => A) => Kind<F, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Invariant2<F extends URIS2> {
    // (undocumented)
    readonly imap: <E, A, B>(fa: Kind2<F, E, A>, f: (a: A) => B, g: (b: B) => A) => Kind2<F, E, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Invariant2C<F extends URIS2, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly imap: <A, B>(fa: Kind2<F, E, A>, f: (a: A) => B, g: (b: B) => A) => Kind2<F, E, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Invariant3<F extends URIS3> {
    // (undocumented)
    readonly imap: <R, E, A, B>(fa: Kind3<F, R, E, A>, f: (a: A) => B, g: (b: B) => A) => Kind3<F, R, E, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Invariant3C<F extends URIS3, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly imap: <R, A, B>(fa: Kind3<F, R, E, A>, f: (a: A) => B, g: (b: B) => A) => Kind3<F, R, E, B>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Invariant4<F extends URIS4> {
    // (undocumented)
    readonly imap: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, f: (a: A) => B, g: (b: B) => A) => Kind4<F, S, R, E, B>;
    // (undocumented)
    readonly URI: F;
}

// @public @deprecated
const invert: (o: Ordering) => Ordering;

// @public (undocumented)
interface IO<A> {
    // (undocumented)
    (): A;
}

declare namespace io {
    export {
        IO,
        map_12 as map,
        ap_9 as ap,
        of_7 as of,
        flatMap_7 as flatMap,
        flatten_7 as flatten,
        URI_12 as URI,
        Functor_10 as Functor,
        as_3 as as,
        asUnit_3 as asUnit,
        flap_10 as flap,
        Pointed_8 as Pointed,
        Apply_8 as Apply,
        apFirst_8 as apFirst,
        apSecond_8 as apSecond,
        Applicative_8 as Applicative,
        Chain_8 as Chain,
        Monad_8 as Monad,
        tap_3 as tap,
        fromIO_2 as fromIO,
        MonadIO,
        chainRec_4 as chainRec,
        ChainRec_5 as ChainRec,
        FromIO_2 as FromIO,
        Do_7 as Do,
        bindTo_8 as bindTo,
        let__8 as let,
        bind_8 as bind,
        apS_8 as apS,
        ApT_3 as ApT,
        do__4 as do,
        traverseReadonlyNonEmptyArrayWithIndex_3 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_3 as traverseReadonlyArrayWithIndex,
        traverseArrayWithIndex_3 as traverseArrayWithIndex,
        traverseArray_3 as traverseArray,
        sequenceArray_3 as sequenceArray,
        chain_9 as chain,
        chainFirst_8 as chainFirst,
        io_2 as io,
        getSemigroup_10 as getSemigroup,
        getMonoid_8 as getMonoid
    }
}
export { io }

// @public @deprecated
const io_2: Monad1<URI_12> & MonadIO1<URI_12> & ChainRec1<URI_12>;

// @public (undocumented)
interface IOEither<E, A> extends IO<Either<E, A>> {
}

declare namespace ioEither {
    export {
        getApplicativeIOValidation,
        getAltIOValidation,
        getFilterable_2 as getFilterable,
        getIOValidation,
        IOEither,
        left_4 as left,
        right_4 as right,
        rightIO,
        leftIO,
        fromEither_4 as fromEither,
        fromIO_3 as fromIO,
        match_6 as match,
        matchW_5 as matchW,
        matchE_2 as matchE,
        fold_8 as fold,
        matchEW,
        foldW_4 as foldW,
        getOrElse_4 as getOrElse,
        getOrElseW_3 as getOrElseW,
        tryCatch_3 as tryCatch,
        tryCatchK_3 as tryCatchK,
        toUnion_3 as toUnion,
        orElse_4 as orElse,
        orElseW_2 as orElseW,
        tapError,
        orElseFirstIOK,
        orLeft_2 as orLeft,
        swap_3 as swap,
        map_13 as map,
        mapBoth,
        bimap_5 as bimap,
        mapError,
        mapLeft_5 as mapLeft,
        ap_10 as ap,
        apW_2 as apW,
        of_8 as of,
        flatMap_8 as flatMap,
        flattenW_2 as flattenW,
        flatten_8 as flatten,
        alt_9 as alt,
        altW_7 as altW,
        throwError_3 as throwError,
        URI_13 as URI,
        getCompactable_2 as getCompactable,
        Functor_11 as Functor,
        as_4 as as,
        asUnit_4 as asUnit,
        flap_11 as flap,
        Pointed_9 as Pointed,
        Bifunctor_5 as Bifunctor,
        ApplyPar,
        apFirst_9 as apFirst,
        apFirstW_2 as apFirstW,
        apSecond_9 as apSecond,
        apSecondW_2 as apSecondW,
        ApplicativePar,
        ApplicativeSeq,
        Chain_9 as Chain,
        chainRec_5 as chainRec,
        ChainRec_6 as ChainRec,
        Monad_9 as Monad,
        FromEither_5 as FromEither,
        FromIO_3 as FromIO,
        tap_4 as tap,
        tapEither_2 as tapEither,
        tapIO,
        Alt_8 as Alt,
        MonadIO_2 as MonadIO,
        MonadThrow_3 as MonadThrow,
        fromIOK_2 as fromIOK,
        chainFirstIOK_2 as chainFirstIOK,
        fromOption_4 as fromOption,
        fromOptionK_4 as fromOptionK,
        chainOptionK_3 as chainOptionK,
        chainOptionKW_2 as chainOptionKW,
        liftNullable_2 as liftNullable,
        liftOption_2 as liftOption,
        flatMapNullable_2 as flatMapNullable,
        flatMapOption_2 as flatMapOption,
        flatMapEither,
        flatMapIO,
        chainIOK_2 as chainIOK,
        chainEitherK_3 as chainEitherK,
        chainEitherKW,
        chainFirstEitherK_3 as chainFirstEitherK,
        chainFirstEitherKW,
        fromPredicate_5 as fromPredicate,
        filterOrElse_3 as filterOrElse,
        filterOrElseW_2 as filterOrElseW,
        fromEitherK_4 as fromEitherK,
        bracket,
        bracketW,
        Do_8 as Do,
        bindTo_9 as bindTo,
        let__9 as let,
        bind_9 as bind,
        bindW_2 as bindW,
        apS_9 as apS,
        apSW_2 as apSW,
        ApT_4 as ApT,
        do__5 as do,
        traverseReadonlyNonEmptyArrayWithIndex_4 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_4 as traverseReadonlyArrayWithIndex,
        traverseReadonlyNonEmptyArrayWithIndexSeq,
        traverseReadonlyArrayWithIndexSeq,
        traverseArrayWithIndex_4 as traverseArrayWithIndex,
        traverseArray_4 as traverseArray,
        sequenceArray_4 as sequenceArray,
        traverseSeqArrayWithIndex,
        traverseSeqArray,
        sequenceSeqArray,
        Applicative_9 as Applicative,
        chain_10 as chain,
        chainW_2 as chainW,
        chainFirst_9 as chainFirst,
        chainFirstW_2 as chainFirstW,
        orElseFirst_2 as orElseFirst,
        orElseFirstW,
        ioEither_2 as ioEither,
        getApplySemigroup_4 as getApplySemigroup,
        getApplyMonoid_3 as getApplyMonoid,
        getSemigroup_11 as getSemigroup
    }
}
export { ioEither }

// @public @deprecated
const ioEither_2: Monad2<URI_13> & Bifunctor2<URI_13> & Alt2<URI_13> & MonadIO2<URI_13> & MonadThrow2<URI_13>;

// @public (undocumented)
interface IOOption<A> extends IO<Option_2<A>> {
}

declare namespace ioOption {
    export {
        IOOption,
        some_3 as some,
        fromPredicate_6 as fromPredicate,
        fromOption_5 as fromOption,
        fromEither_5 as fromEither,
        fromIO_4 as fromIO,
        fromIOEither,
        match_7 as match,
        matchW_6 as matchW,
        matchE_3 as matchE,
        fold_9 as fold,
        matchEW_2 as matchEW,
        getOrElse_5 as getOrElse,
        getOrElseW_4 as getOrElseW,
        toUndefined_2 as toUndefined,
        toNullable_2 as toNullable,
        fromNullable_4 as fromNullable,
        fromNullableK_4 as fromNullableK,
        chainNullableK_4 as chainNullableK,
        fromOptionK_5 as fromOptionK,
        map_14 as map,
        ap_11 as ap,
        of_9 as of,
        flatMap_9 as flatMap,
        flatten_9 as flatten,
        alt_10 as alt,
        altW_8 as altW,
        zero_4 as zero,
        throwError_4 as throwError,
        none_2 as none,
        compact_4 as compact,
        separate_4 as separate,
        filter_6 as filter,
        filterMap_4 as filterMap,
        partition_4 as partition,
        partitionMap_4 as partitionMap,
        URI_14 as URI,
        Functor_12 as Functor,
        as_5 as as,
        asUnit_5 as asUnit,
        flap_12 as flap,
        Pointed_10 as Pointed,
        Apply_9 as Apply,
        apFirst_10 as apFirst,
        apSecond_10 as apSecond,
        Applicative_10 as Applicative,
        Chain_10 as Chain,
        chainRec_6 as chainRec,
        ChainRec_7 as ChainRec,
        FromEither_6 as FromEither,
        FromIO_4 as FromIO,
        tap_5 as tap,
        tapEither_3 as tapEither,
        tapIO_2 as tapIO,
        Alt_9 as Alt,
        Zero_4 as Zero,
        guard_3 as guard,
        Alternative_4 as Alternative,
        Monad_10 as Monad,
        MonadIO_3 as MonadIO,
        MonadThrow_4 as MonadThrow,
        Compactable_4 as Compactable,
        Filterable_4 as Filterable,
        flatMapIO_2 as flatMapIO,
        flatMapOption_3 as flatMapOption,
        flatMapEither_2 as flatMapEither,
        flatMapNullable_3 as flatMapNullable,
        fromIOK_3 as fromIOK,
        chainIOK_3 as chainIOK,
        chainFirstIOK_3 as chainFirstIOK,
        fromEitherK_5 as fromEitherK,
        chainEitherK_4 as chainEitherK,
        chainFirstEitherK_4 as chainFirstEitherK,
        chainOptionK_4 as chainOptionK,
        Do_9 as Do,
        bindTo_10 as bindTo,
        let__10 as let,
        bind_10 as bind,
        apS_10 as apS,
        ApT_5 as ApT,
        do__6 as do,
        traverseReadonlyNonEmptyArrayWithIndex_5 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_5 as traverseReadonlyArrayWithIndex,
        chain_11 as chain,
        chainFirst_10 as chainFirst
    }
}
export { ioOption }

// @public (undocumented)
class IORef<A> {
    constructor(value: A);
    // (undocumented)
    modify(f: (a: A) => A): IO<void>;
    // (undocumented)
    readonly read: IO<A>;
    // (undocumented)
    write(a: A): IO<void>;
}

declare namespace ioRef {
    export {
        newIORef,
        IORef
    }
}
export { ioRef }

// @public (undocumented)
const isBoolean: Refinement<unknown, boolean>;

// @public
function isBoth<E, A>(fa: These<E, A>): fa is Both<E, A>;

// @public
const isEmpty: <A>(as: A[]) => as is [];

// @public
const isEmpty_2: <K, A>(m: Map<K, A>) => boolean;

// @public
const isEmpty_3: <A>(as: readonly A[]) => as is readonly [];

// @public
const isEmpty_4: <K, A>(m: ReadonlyMap<K, A>) => boolean;

// @public
const isEmpty_5: <A>(r: Readonly<Record<string, A>>) => boolean;

// @public
const isEmpty_6: <A>(set: ReadonlySet<A>) => boolean;

// @public
const isEmpty_7: <A>(r: Record<string, A>) => boolean;

// @public
const isEmpty_8: <A>(set: Set<A>) => boolean;

// @public
const isEmpty_9: (s: string) => boolean;

// @public
const isLeft: <E>(ma: Either<E, unknown>) => ma is Left<E>;

// @public
const isLeft_2: <E>(fa: These<E, unknown>) => fa is Left<E>;

// @public
const isNone: (fa: Option_2<unknown>) => fa is None;

// @public
const isNonEmpty: <A>(as: Array<A>) => as is NonEmptyArray<A>;

// @public
const isNonEmpty_2: <A>(as: ReadonlyArray<A>) => as is ReadonlyNonEmptyArray<A>;

// @public (undocumented)
const isNumber: Refinement<unknown, number>;

// @public
const isOutOfBound: <A>(i: number, as: Array<A>) => boolean;

// @public
const isOutOfBound_2: <A>(i: number, as: ReadonlyArray<A>) => boolean;

// @public
const isRight: <A>(ma: Either<unknown, A>) => ma is Right<A>;

// @public
const isRight_2: <A>(fa: These<unknown, A>) => fa is Right<A>;

// @public
const isSome: <A>(fa: Option_2<A>) => fa is Some<A>;

// @public (undocumented)
const isString: Refinement<unknown, string>;

// @public
const isSubmap: <K, A>(SK: Eq<K>, SA: Eq<A>) => {
    (that: Map<K, A>): (me: Map<K, A>) => boolean;
    (me: Map<K, A>, that: Map<K, A>): boolean;
};

// @public
function isSubmap_2<K, A>(SK: Eq<K>, SA: Eq<A>): {
    (that: ReadonlyMap<K, A>): (me: ReadonlyMap<K, A>) => boolean;
    (me: ReadonlyMap<K, A>, that: ReadonlyMap<K, A>): boolean;
};

// @public
function isSubrecord<A>(E: Eq<A>): {
    (that: ReadonlyRecord<string, A>): (me: ReadonlyRecord<string, A>) => boolean;
    (me: ReadonlyRecord<string, A>, that: ReadonlyRecord<string, A>): boolean;
};

// @public
const isSubrecord_2: <A>(E: Eq<A>) => {
    (that: Record<string, A>): (me: Record<string, A>) => boolean;
    (me: Record<string, A>, that: Record<string, A>): boolean;
};

// @public
function isSubset<A>(E: Eq<A>): {
    (that: ReadonlySet<A>): (me: ReadonlySet<A>) => boolean;
    (me: ReadonlySet<A>, that: ReadonlySet<A>): boolean;
};

// @public (undocumented)
const isSubset_2: <A>(E: Eq<A>) => (that: Set<A>) => (me: Set<A>) => boolean;

// @public (undocumented)
interface JoinSemilattice<A> {
    // (undocumented)
    readonly join: (x: A, y: A) => A;
}

declare namespace joinSemilattice {
    export {
        JoinSemilattice
    }
}
export { joinSemilattice }

// @public @deprecated
type Json = boolean | number | string | null | JsonArray | JsonRecord;

declare namespace json {
    export {
        Json_2 as Json,
        JsonRecord_2 as JsonRecord,
        JsonArray_2 as JsonArray,
        parse,
        stringify
    }
}
export { json }

// @public (undocumented)
type Json_2 = boolean | number | string | null | JsonArray_2 | JsonRecord_2;

// @public @deprecated
interface JsonArray extends ReadonlyArray<Json> {
}

// @public (undocumented)
interface JsonArray_2 extends ReadonlyArray<Json_2> {
}

// @public @deprecated
interface JsonRecord {
    // (undocumented)
    readonly [key: string]: Json;
}

// @public (undocumented)
interface JsonRecord_2 {
    // (undocumented)
    readonly [key: string]: Json_2;
}

// @public
const keys: <K>(O: Ord<K>) => <A>(m: Map<K, A>) => K[];

// @public
const keys_2: <K>(O: Ord<K>) => <A>(m: ReadonlyMap<K, A>) => readonly K[];

// @public (undocumented)
const keys_3: <K extends string>(r: ReadonlyRecord<K, unknown>) => ReadonlyArray<K>;

// @public
const keys_4: <K extends string>(r: Record<K, unknown>) => Array<K>;

// @public
type Kind<URI extends URIS, A> = URI extends URIS ? URItoKind<A>[URI] : any;

// @public
type Kind2<URI extends URIS2, E, A> = URI extends URIS2 ? URItoKind2<E, A>[URI] : any;

// @public
type Kind3<URI extends URIS3, R, E, A> = URI extends URIS3 ? URItoKind3<R, E, A>[URI] : any;

// @public
type Kind4<URI extends URIS4, S, R, E, A> = URI extends URIS4 ? URItoKind4<S, R, E, A>[URI] : any;

// @public (undocumented)
interface KindGenerator2<M extends URIS2, E, out A> {
    // (undocumented)
    [Symbol.iterator](): Generator<KindGenerator2<M, E, A>, A>;
    // (undocumented)
    readonly value: Kind2<M, E, A>;
}

// @public
const last: <A = never>() => Semigroup<A>;

// @public (undocumented)
const last_2: <A>(as: ReadonlyNonEmptyArray<A>) => A;

// @public (undocumented)
const last_3: <A>(nea: NonEmptyArray<A>) => A;

// @public
const last_4: <A>(as: Array<A>) => Option_2<A>;

// @public
const last_5: <A>(as: readonly A[]) => Option_2<A>;

// @public (undocumented)
interface Lattice<A> extends JoinSemilattice<A>, MeetSemilattice<A> {
}

declare namespace lattice {
    export {
        Lattice
    }
}
export { lattice }

// @public
interface Lazy<A> {
    // (undocumented)
    (): A;
}

// @public
interface LazyArg<A> {
    // (undocumented)
    (): A;
}

// @public
function lcm<A>(E: Eq<A>, F: Field<A>): (x: A, y: A) => A;

// @public (undocumented)
interface Left<E> {
    // (undocumented)
    readonly left: E;
    // (undocumented)
    readonly _tag: 'Left';
}

// @public (undocumented)
const left: <E, A>(s: Separated<E, A>) => E;

// @public (undocumented)
const left_10: <E = never, A = never>(e: E) => TaskThese<E, A>;

// @public (undocumented)
function left_11<E = never, A = never>(left: E): These<E, A>;

// @public (undocumented)
function left_12<F extends URIS3>(F: Pointed3<F>): <E, R, FE, A = never>(e: E) => Kind3<F, R, FE, These<E, A>>;

// @public (undocumented)
function left_12<F extends URIS3, FE>(F: Pointed3C<F, FE>): <E, R, A = never>(e: E) => Kind3<F, R, FE, These<E, A>>;

// @public (undocumented)
function left_12<F extends URIS2>(F: Pointed2<F>): <E, FE, A = never>(e: E) => Kind2<F, FE, These<E, A>>;

// @public (undocumented)
function left_12<F extends URIS2, FE>(F: Pointed2C<F, FE>): <E, A = never>(e: E) => Kind2<F, FE, These<E, A>>;

// @public (undocumented)
function left_12<F extends URIS>(F: Pointed1<F>): <E, A = never>(e: E) => Kind<F, These<E, A>>;

// @public (undocumented)
function left_12<F>(F: Pointed<F>): <E, A = never>(e: E) => HKT<F, These<E, A>>;

// @public
const left_2: <E = never, A = never>(e: E) => Either<E, A>;

// @public (undocumented)
function left_3<F extends URIS3>(F: Pointed3<F>): <E, R, FE, A = never>(e: E) => Kind3<F, R, FE, Either<E, A>>;

// @public (undocumented)
function left_3<F extends URIS3, FE>(F: Pointed3C<F, FE>): <E, R, A = never>(e: E) => Kind3<F, R, FE, Either<E, A>>;

// @public (undocumented)
function left_3<F extends URIS2>(F: Pointed2<F>): <E, FE, A = never>(e: E) => Kind2<F, FE, Either<E, A>>;

// @public (undocumented)
function left_3<F extends URIS2, FE>(F: Pointed2C<F, FE>): <E, A = never>(e: E) => Kind2<F, FE, Either<E, A>>;

// @public (undocumented)
function left_3<F extends URIS>(F: Pointed1<F>): <E, A = never>(e: E) => Kind<F, Either<E, A>>;

// @public (undocumented)
function left_3<F>(F: Pointed<F>): <E, A = never>(e: E) => HKT<F, Either<E, A>>;

// @public (undocumented)
const left_4: <E = never, A = never>(l: E) => IOEither<E, A>;

// @public (undocumented)
const left_5: Choice2<URI_17>['left'];

// @public (undocumented)
const left_6: <R, E = never, A = never>(e: E) => ReaderEither<R, E, A>;

// @public (undocumented)
const left_7: <R, E = never, A = never>(e: E) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const left_8: <E = never, A = never>(e: E) => TaskEither<E, A>;

// @public (undocumented)
const left_9: <S, R, E, A = never>(e: E) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
function leftF<F extends URIS3>(F: Functor3<F>): <R, FE, E, A = never>(fe: Kind3<F, R, FE, E>) => Kind3<F, R, FE, Either<E, A>>;

// @public (undocumented)
function leftF<F extends URIS3, FE>(F: Functor3C<F, FE>): <R, E, A = never>(fe: Kind3<F, R, FE, E>) => Kind3<F, R, FE, Either<E, A>>;

// @public (undocumented)
function leftF<F extends URIS2>(F: Functor2<F>): <FE, E, A = never>(fe: Kind2<F, FE, E>) => Kind2<F, FE, Either<E, A>>;

// @public (undocumented)
function leftF<F extends URIS2, FE>(F: Functor2C<F, FE>): <E, A = never>(fe: Kind2<F, FE, E>) => Kind2<F, FE, Either<E, A>>;

// @public (undocumented)
function leftF<F extends URIS>(F: Functor1<F>): <E, A = never>(fe: Kind<F, E>) => Kind<F, Either<E, A>>;

// @public (undocumented)
function leftF<F>(F: Functor<F>): <E, A = never>(fe: HKT<F, E>) => HKT<F, Either<E, A>>;

// @public (undocumented)
function leftF_2<F extends URIS3>(F: Functor3<F>): <R, FE, E, A = never>(fe: Kind3<F, R, FE, E>) => Kind3<F, R, FE, These<E, A>>;

// @public (undocumented)
function leftF_2<F extends URIS3, FE>(F: Functor3C<F, FE>): <R, E, A = never>(fe: Kind3<F, R, FE, E>) => Kind3<F, R, FE, These<E, A>>;

// @public (undocumented)
function leftF_2<F extends URIS2>(F: Functor2<F>): <FE, E, A = never>(fe: Kind2<F, FE, E>) => Kind2<F, FE, These<E, A>>;

// @public (undocumented)
function leftF_2<F extends URIS2, FE>(F: Functor2C<F, FE>): <E, A = never>(fe: Kind2<F, FE, E>) => Kind2<F, FE, These<E, A>>;

// @public (undocumented)
function leftF_2<F extends URIS>(F: Functor1<F>): <E, A = never>(fe: Kind<F, E>) => Kind<F, These<E, A>>;

// @public (undocumented)
function leftF_2<F>(F: Functor<F>): <E, A = never>(fe: HKT<F, E>) => HKT<F, These<E, A>>;

// @public (undocumented)
const leftIO: <E = never, A = never>(me: IO<E>) => IOEither<E, A>;

// @public (undocumented)
const leftIO_2: <R, E = never, A = never>(me: IO<E>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const leftIO_3: <E = never, A = never>(me: IO<E>) => TaskEither<E, A>;

// @public (undocumented)
function leftIO_4<S, R, E, A = never>(me: IO<E>): StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const leftIO_5: <E = never, A = never>(me: IO<E>) => TaskThese<E, A>;

// @public (undocumented)
function leftOrBoth<E>(e: E): <A>(ma: Option_2<A>) => These<E, A>;

// @public (undocumented)
const leftReader: <R, E = never, A = never>(me: Reader<R, E>) => ReaderEither<R, E, A>;

// @public (undocumented)
const leftReader_2: <R, E = never, A = never>(me: Reader<R, E>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
function leftReader_3<S, R, E, A = never>(me: Reader<R, E>): StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const leftReaderIO: <R, E = never, A = never>(me: ReaderIO<R, E>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const leftReaderTask: <R, E = never, A = never>(me: ReaderTask<R, E>) => ReaderTaskEither<R, E, A>;

// @public
const lefts: <E, A>(as: Either<E, A>[]) => E[];

// @public
const lefts_2: <E, A>(as: readonly Either<E, A>[]) => readonly E[];

// @public (undocumented)
const leftState: <S, R, E, A = never>(me: State<S, E>) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const leftTask: <R, E = never, A = never>(me: Task<E>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const leftTask_2: <E = never, A = never>(me: Task<E>) => TaskEither<E, A>;

// @public (undocumented)
function leftTask_3<S, R, E, A = never>(me: Task<E>): StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const leftTask_4: <E = never, A = never>(me: Task<E>) => TaskThese<E, A>;

// @public
const leq: <A>(O: Ord<A>) => (first: A, second: A) => boolean;

// @public (undocumented)
const let_: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__10: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: IOOption<A>) => IOOption<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__11: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => <E>(fa: Reader<E, A>) => Reader<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__12: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => <R, E>(fa: ReaderEither<R, E, A>) => ReaderEither<R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__13: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: Task<A>) => Task<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__14: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => <E>(fa: ReaderTask<E, A>) => ReaderTask<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__15: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => <E>(fa: TaskEither<E, A>) => TaskEither<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__16: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => <R, E>(fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__17: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: readonly A[]) => readonly { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }[];

// @public (undocumented)
const let__18: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => <E>(fa: State<E, A>) => State<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__19: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => <S, R, E>(fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__2: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: NonEmptyArray<A>) => NonEmptyArray<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__20: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: TaskOption<A>) => TaskOption<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__21: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: Tree<A>) => Tree<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__3: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: Option_2<A>) => Option_2<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__4: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => <E>(fa: Either<E, A>) => Either<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__5: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: A[]) => { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }[];

// @public (undocumented)
function let__6<F extends URIS4>(F: Functor4<F>): <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function let__6<F extends URIS3>(F: Functor3<F>): <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function let__6<F extends URIS3, E>(F: Functor3C<F, E>): <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function let__6<F extends URIS2>(F: Functor2<F>): <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function let__6<F extends URIS2, E>(F: Functor2C<F, E>): <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: Kind2<F, E, A>) => Kind2<F, E, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function let__6<F extends URIS>(F: Functor1<F>): <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: Kind<F, A>) => Kind<F, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
function let__6<F>(F: Functor<F>): <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: HKT<F, A>) => HKT<F, {
    readonly [K in keyof A | N]: K extends keyof A ? A[K] : B;
}>;

// @public (undocumented)
const let__7: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: A) => { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; };

// @public (undocumented)
const let__8: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: IO<A>) => IO<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const let__9: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => <E>(fa: IOEither<E, A>) => IOEither<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;

// @public (undocumented)
const liftNullable: <A extends ReadonlyArray<unknown>, B, E>(f: (...a: A) => B | null | undefined, onNullable: (...a: A) => E) => (...a: A) => Either<E, NonNullable<B>>;

// @public (undocumented)
const liftNullable_2: <A extends ReadonlyArray<unknown>, B, E>(f: (...a: A) => B | null | undefined, onNullable: (...a: A) => E) => (...a: A) => IOEither<E, NonNullable<B>>;

// @public (undocumented)
const liftNullable_3: <A extends ReadonlyArray<unknown>, B, E>(f: (...a: A) => B | null | undefined, onNullable: (...a: A) => E) => <R>(...a: A) => ReaderEither<R, E, NonNullable<B>>;

// @public (undocumented)
const liftNullable_4: <A extends ReadonlyArray<unknown>, B, E>(f: (...a: A) => B | null | undefined, onNullable: (...a: A) => E) => (...a: A) => TaskEither<E, NonNullable<B>>;

// @public (undocumented)
const liftNullable_5: <A extends ReadonlyArray<unknown>, B, E>(f: (...a: A) => B | null | undefined, onNullable: (...a: A) => E) => <R>(...a: A) => ReaderTaskEither<R, E, NonNullable<B>>;

// @public (undocumented)
const liftOption: <A extends ReadonlyArray<unknown>, B, E>(f: (...a: A) => Option_2<B>, onNone: (...a: A) => E) => (...a: A) => Either<E, B>;

// @public (undocumented)
const liftOption_2: <A extends ReadonlyArray<unknown>, B, E>(f: (...a: A) => Option_2<B>, onNone: (...a: A) => E) => (...a: A) => IOEither<E, B>;

// @public (undocumented)
const liftOption_3: <A extends ReadonlyArray<unknown>, B, E>(f: (...a: A) => Option_2<B>, onNone: (...a: A) => E) => <R>(...a: A) => ReaderEither<R, E, B>;

// @public (undocumented)
const liftOption_4: <A extends ReadonlyArray<unknown>, B, E>(f: (...a: A) => Option_2<B>, onNone: (...a: A) => E) => (...a: A) => TaskEither<E, B>;

// @public (undocumented)
const liftOption_5: <A extends ReadonlyArray<unknown>, B, E>(f: (...a: A) => Option_2<B>, onNone: (...a: A) => E) => <R>(...a: A) => ReaderTaskEither<R, E, B>;

// @public
function listen<P, A>(wa: Traced<P, A>): Traced<P, [A, P]>;

// @public
const listen_2: <W, A>(fa: Writer<W, A>) => Writer<W, [A, W]>;

// @public
function listens<P, B>(f: (p: P) => B): <A>(wa: Traced<P, A>) => Traced<P, [A, B]>;

// @public
const listens_2: <W, B>(f: (w: W) => B) => <A>(fa: Writer<W, A>) => Writer<W, [A, B]>;

// @public
const local: <R2, R1>(f: (r2: R2) => R1) => <A>(ma: Reader<R1, A>) => Reader<R2, A>;

// @public
const local_2: <R2, R1>(f: (r2: R2) => R1) => <E, A>(ma: ReaderEither<R1, E, A>) => ReaderEither<R2, E, A>;

// @public
const local_3: <R2, R1>(f: (r2: R2) => R1) => <A>(ma: ReaderIO<R1, A>) => ReaderIO<R2, A>;

// @public
const local_4: <R2, R1>(f: (r2: R2) => R1) => <A>(ma: ReaderTask<R1, A>) => ReaderTask<R2, A>;

// @public
const local_5: <R2, R1>(f: (r2: R2) => R1) => <E, A>(ma: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R2, E, A>;

// @public
const local_6: <R2, R1>(f: (r2: R2) => R1) => <S, E, A>(ma: StateReaderTaskEither<S, R1, E, A>) => StateReaderTaskEither<S, R2, E, A>;

// @public (undocumented)
const log: <A>(a: A) => IO<void>;

// @public
const lookup: {
    (i: number): <A>(as: Array<A>) => Option_2<A>;
    <A>(i: number, as: Array<A>): Option_2<A>;
};

// @public
const lookup_2: <K>(E: Eq<K>) => {
    (k: K): <A>(m: Map<K, A>) => Option_2<A>;
    <A>(k: K, m: Map<K, A>): Option_2<A>;
};

// @public
function lookup_3(i: number): <A>(as: ReadonlyArray<A>) => Option_2<A>;

// @public (undocumented)
function lookup_3<A>(i: number, as: ReadonlyArray<A>): Option_2<A>;

// @public
function lookup_4<K>(E: Eq<K>): {
    (k: K): <A>(m: ReadonlyMap<K, A>) => Option_2<A>;
    <A>(k: K, m: ReadonlyMap<K, A>): Option_2<A>;
};

// @public
function lookup_5(k: string): <A>(r: ReadonlyRecord<string, A>) => Option_2<A>;

// @public (undocumented)
function lookup_5<A>(k: string, r: ReadonlyRecord<string, A>): Option_2<A>;

// @public
const lookup_6: {
    (k: string): <A>(r: Record<string, A>) => Option_2<A>;
    <A>(k: string, r: Record<string, A>): Option_2<A>;
};

// @public
function lookupWithKey<K>(E: Eq<K>): {
    (k: K): <A>(m: Map<K, A>) => Option_2<[K, A]>;
    <A>(k: K, m: Map<K, A>): Option_2<[K, A]>;
};

// @public
function lookupWithKey_2<K>(E: Eq<K>): {
    (k: K): <A>(m: ReadonlyMap<K, A>) => Option_2<readonly [K, A]>;
    <A>(k: K, m: ReadonlyMap<K, A>): Option_2<readonly [K, A]>;
};

// @public
const lt: <A>(O: Ord<A>) => (first: A, second: A) => boolean;

// @public (undocumented)
interface Magma<A> {
    // (undocumented)
    readonly concat: (x: A, y: A) => A;
}

declare namespace magma {
    export {
        Magma,
        reverse_9 as reverse,
        filterFirst,
        filterSecond,
        endo,
        concatAll_5 as concatAll
    }
}
export { magma }

// @public (undocumented)
const MagmaSub: Magma<number>;

// @public (undocumented)
const make: <E, A = never>(e: E) => Const<E, A>;

// @public (undocumented)
function make_2<A>(value: A, forest?: Forest<A>): Tree<A>;

// @public
const makeBy: <A>(f: (i: number) => A) => (n: number) => NonEmptyArray<A>;

// @public
const makeBy_2: <A>(f: (i: number) => A) => (n: number) => ReadonlyNonEmptyArray<A>;

// @public
const makeBy_3: <A>(n: number, f: (i: number) => A) => A[];

// @public
const makeBy_4: <A>(n: number, f: (i: number) => A) => readonly A[];

declare namespace map {
    export {
        collect,
        toArray_2 as toArray,
        toUnfoldable,
        pop,
        lookupWithKey,
        getMonoid_9 as getMonoid,
        fromFoldable,
        partitionWithIndex_2 as partitionWithIndex,
        filterWithIndex_4 as filterWithIndex,
        getFilterableWithIndex,
        getWitherable_2 as getWitherable,
        getShow_8 as getShow,
        size_2 as size,
        isEmpty_2 as isEmpty,
        member,
        elem_4 as elem,
        keys,
        values,
        upsertAt,
        deleteAt_2 as deleteAt,
        updateAt_4 as updateAt,
        modifyAt_4 as modifyAt,
        lookup_2 as lookup,
        isSubmap,
        getEq_8 as getEq,
        singleton,
        partitionMapWithIndex_2 as partitionMapWithIndex,
        filterMapWithIndex_2 as filterMapWithIndex,
        compact_5 as compact,
        filter_7 as filter,
        filterMap_5 as filterMap,
        map_15 as map,
        mapWithIndex_5 as mapWithIndex,
        partition_5 as partition,
        partitionMap_5 as partitionMap,
        separate_5 as separate,
        URI_15 as URI,
        getUnionSemigroup_4 as getUnionSemigroup,
        getUnionMonoid_2 as getUnionMonoid,
        getIntersectionSemigroup_2 as getIntersectionSemigroup,
        getDifferenceMagma_2 as getDifferenceMagma,
        reduce_8 as reduce,
        foldMap_8 as foldMap,
        reduceRight_8 as reduceRight,
        getFoldable,
        reduceWithIndex_5 as reduceWithIndex,
        foldMapWithIndex_5 as foldMapWithIndex,
        reduceRightWithIndex_5 as reduceRightWithIndex,
        getFoldableWithIndex,
        getTraversableWithIndex,
        Functor_13 as Functor,
        flap_13 as flap,
        Compactable_5 as Compactable,
        Filterable_5 as Filterable,
        union_4 as union,
        intersection_2 as intersection,
        difference_2 as difference,
        empty_2 as empty,
        insertAt_4 as insertAt,
        map_
    }
}
export { map }

// @public @deprecated
const map_: Filterable2<URI_15>;

// @public
function map_10<F extends URIS3, G extends URIS>(F: Functor3<F>, G: Functor1<G>): <A, B>(f: (a: A) => B) => <R, E>(fa: Kind3<F, R, E, Kind<G, A>>) => Kind3<F, R, E, Kind<G, B>>;

// @public (undocumented)
function map_10<F extends URIS2, G extends URIS2>(F: Functor2<F>, G: Functor2<G>): <A, B>(f: (a: A) => B) => <EF, EG>(fa: Kind2<F, EF, Kind2<G, EG, A>>) => Kind2<F, EF, Kind2<G, EG, B>>;

// @public (undocumented)
function map_10<F extends URIS2, G extends URIS>(F: Functor2<F>, G: Functor1<G>): <A, B>(f: (a: A) => B) => <E>(fa: Kind2<F, E, Kind<G, A>>) => Kind2<F, E, Kind<G, B>>;

// @public (undocumented)
function map_10<F extends URIS, G extends URIS3>(F: Functor1<F>, G: Functor3<G>): <A, B>(f: (a: A) => B) => <R, E>(fa: Kind<F, Kind3<G, R, E, A>>) => Kind<F, Kind3<G, R, E, B>>;

// @public (undocumented)
function map_10<F extends URIS, G extends URIS2>(F: Functor1<F>, G: Functor2<G>): <A, B>(f: (a: A) => B) => <E>(fa: Kind<F, Kind2<G, E, A>>) => Kind<F, Kind2<G, E, B>>;

// @public (undocumented)
function map_10<F extends URIS, G extends URIS>(F: Functor1<F>, G: Functor1<G>): <A, B>(f: (a: A) => B) => (fa: Kind<F, Kind<G, A>>) => Kind<F, Kind<G, B>>;

// @public (undocumented)
function map_10<F, G extends URIS2>(F: Functor<F>, G: Functor2<G>): <A, B>(f: (a: A) => B) => <E>(fa: HKT<F, Kind2<G, E, A>>) => HKT<F, Kind2<G, E, B>>;

// @public (undocumented)
function map_10<F, G extends URIS>(F: Functor<F>, G: Functor1<G>): <A, B>(f: (a: A) => B) => (fa: HKT<F, Kind<G, A>>) => HKT<F, Kind<G, B>>;

// @public (undocumented)
function map_10<F, G>(F: Functor<F>, G: Functor<G>): <A, B>(f: (a: A) => B) => (fa: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, B>>;

// @public
const map_11: <A, B>(f: (a: A) => B) => (fa: Identity<A>) => Identity<B>;

// @public
const map_12: <A, B>(f: (a: A) => B) => (fa: IO<A>) => IO<B>;

// @public
const map_13: <A, B>(f: (a: A) => B) => <E>(fa: IOEither<E, A>) => IOEither<E, B>;

// @public
const map_14: <A, B>(f: (a: A) => B) => (fa: IOOption<A>) => IOOption<B>;

// @public
const map_15: <A, B>(f: (a: A) => B) => <K>(fa: Map<K, A>) => Map<K, B>;

// @public (undocumented)
function map_16<F extends URIS4>(F: Functor4<F>): <A, B>(f: (a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, Option_2<A>>) => Kind4<F, S, R, E, Option_2<B>>;

// @public (undocumented)
function map_16<F extends URIS3>(F: Functor3<F>): <A, B>(f: (a: A) => B) => <R, E>(fa: Kind3<F, R, E, Option_2<A>>) => Kind3<F, R, E, Option_2<B>>;

// @public (undocumented)
function map_16<F extends URIS3, E>(F: Functor3C<F, E>): <A, B>(f: (a: A) => B) => <R>(fa: Kind3<F, R, E, Option_2<A>>) => Kind3<F, R, E, Option_2<B>>;

// @public (undocumented)
function map_16<F extends URIS2>(F: Functor2<F>): <A, B>(f: (a: A) => B) => <E>(fa: Kind2<F, E, Option_2<A>>) => Kind2<F, E, Option_2<B>>;

// @public (undocumented)
function map_16<F extends URIS2, E>(F: Functor2C<F, E>): <A, B>(f: (a: A) => B) => (fa: Kind2<F, E, Option_2<A>>) => Kind2<F, E, Option_2<B>>;

// @public (undocumented)
function map_16<F extends URIS>(F: Functor1<F>): <A, B>(f: (a: A) => B) => (fa: Kind<F, Option_2<A>>) => Kind<F, Option_2<B>>;

// @public (undocumented)
function map_16<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => (fa: HKT<F, Option_2<A>>) => HKT<F, Option_2<B>>;

// @public
function map_17<F extends URIS4>(F: Functor4<F>): <A, B>(f: (a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function map_17<F extends URIS3>(F: Functor3<F>): <A, B>(f: (a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function map_17<F extends URIS3, E>(F: Functor3C<F, E>): <A, B>(f: (a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function map_17<F extends URIS2>(F: Functor2<F>): <A, B>(f: (a: A) => B) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function map_17<F extends URIS2, E>(F: Functor2C<F, E>): <A, B>(f: (a: A) => B) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function map_17<F extends URIS>(F: Functor1<F>): <A, B>(f: (a: A) => B) => (fa: Kind<F, A>) => Kind<F, B>;

// @public (undocumented)
function map_17<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => (fa: HKT<F, A>) => HKT<F, B>;

// @public
const map_18: <A, B>(f: (a: A) => B) => <R>(fa: Reader<R, A>) => Reader<R, B>;

// @public
const map_19: <A, B>(f: (a: A) => B) => <R, E>(fa: ReaderEither<R, E, A>) => ReaderEither<R, E, B>;

// @public
const map_2: <A, B>(f: (a: A) => B) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>;

// @public
const map_20: <A, B>(f: (a: A) => B) => <R>(fa: ReaderIO<R, A>) => ReaderIO<R, B>;

// @public (undocumented)
function map_21<F extends URIS4>(F: Functor4<F>): <A, B>(f: (a: A) => B) => <R, S, FR, FE>(fa: Reader<R, Kind4<F, S, FR, FE, A>>) => Reader<R, Kind4<F, S, FR, FE, B>>;

// @public (undocumented)
function map_21<F extends URIS3>(F: Functor3<F>): <A, B>(f: (a: A) => B) => <R, FR, FE>(fa: Reader<R, Kind3<F, FR, FE, A>>) => Reader<R, Kind3<F, FR, FE, B>>;

// @public (undocumented)
function map_21<F extends URIS3, FE>(F: Functor3C<F, FE>): <A, B>(f: (a: A) => B) => <R, FR>(fa: Reader<R, Kind3<F, FR, FE, A>>) => Reader<R, Kind3<F, FR, FE, B>>;

// @public (undocumented)
function map_21<F extends URIS2>(F: Functor2<F>): <A, B>(f: (a: A) => B) => <R, FE>(fa: Reader<R, Kind2<F, FE, A>>) => Reader<R, Kind2<F, FE, B>>;

// @public (undocumented)
function map_21<F extends URIS2, FE>(F: Functor2C<F, FE>): <A, B>(f: (a: A) => B) => <R>(fa: Reader<R, Kind2<F, FE, A>>) => Reader<R, Kind2<F, FE, B>>;

// @public (undocumented)
function map_21<F extends URIS>(F: Functor1<F>): <A, B>(f: (a: A) => B) => <R>(fa: Reader<R, Kind<F, A>>) => Reader<R, Kind<F, B>>;

// @public (undocumented)
function map_21<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => <R>(fa: Reader<R, HKT<F, A>>) => Reader<R, HKT<F, B>>;

// @public
const map_22: <A, B>(f: (a: A) => B) => <R>(fa: ReaderTask<R, A>) => ReaderTask<R, B>;

// @public
const map_23: <A, B>(f: (a: A) => B) => (fa: Task<A>) => Task<B>;

// @public
const map_24: <A, B>(f: (a: A) => B) => <E>(fa: TaskEither<E, A>) => TaskEither<E, B>;

// @public
const map_25: <A, B>(f: (a: A) => B) => <R, E>(fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>;

// @public
const map_26: <A, B>(f: (a: A) => B) => (fa: ReadonlyArray<A>) => ReadonlyArray<B>;

// @public
const map_27: <A, B>(f: (a: A) => B) => <K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B>;

// @public
function map_28<A, B>(f: (a: A) => B): <K extends string>(fa: ReadonlyRecord<K, A>) => ReadonlyRecord<K, B>;

// @public
function map_29<B>(E: Eq<B>): <A>(f: (x: A) => B) => (set: ReadonlySet<A>) => ReadonlySet<B>;

// @public
const map_3: <A, B>(f: (a: A) => B) => (as: NonEmptyArray<A>) => NonEmptyArray<B>;

// @public
const map_30: <A, B>(f: (a: A) => B) => <E>(fa: readonly [A, E]) => readonly [B, E];

// @public
const map_31: <A, B>(f: (a: A) => B) => <K extends string>(fa: Record<K, A>) => Record<K, B>;

// @public
function map_32<B>(E: Eq<B>): <A>(f: (x: A) => B) => (set: Set<A>) => Set<B>;

// @public
const map_33: <A, B>(f: (a: A) => B) => <E>(fa: State<E, A>) => State<E, B>;

// @public
const map_34: <A, B>(f: (a: A) => B) => <S, R, E>(fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>;

// @public (undocumented)
function map_35<F extends URIS3>(F: Functor3<F>): <A, B>(f: (a: A) => B) => <S, R, E>(fa: StateT3<F, S, R, E, A>) => StateT3<F, S, R, E, B>;

// @public (undocumented)
function map_35<F extends URIS3, E>(F: Functor3C<F, E>): <A, B>(f: (a: A) => B) => <S, R>(fa: StateT3<F, S, R, E, A>) => StateT3<F, S, R, E, B>;

// @public (undocumented)
function map_35<F extends URIS2>(F: Functor2<F>): <A, B>(f: (a: A) => B) => <S, E>(fa: StateT2<F, S, E, A>) => StateT2<F, S, E, B>;

// @public (undocumented)
function map_35<F extends URIS2, E>(F: Functor2C<F, E>): <A, B>(f: (a: A) => B) => <S>(fa: StateT2<F, S, E, A>) => StateT2<F, S, E, B>;

// @public (undocumented)
function map_35<F extends URIS>(F: Functor1<F>): <A, B>(f: (a: A) => B) => <S>(fa: StateT1<F, S, A>) => StateT1<F, S, B>;

// @public (undocumented)
function map_35<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => <S>(fa: StateT<F, S, A>) => StateT<F, S, B>;

// @public
const map_36: <A, B>(f: (a: A) => B) => <E>(fa: Store<E, A>) => Store<E, B>;

// @public
const map_37: <A, B>(f: (a: A) => B) => (fa: TaskOption<A>) => TaskOption<B>;

// @public
const map_38: <A, B>(f: (a: A) => B) => <E>(fa: TaskThese<E, A>) => TaskThese<E, B>;

// @public
const map_39: <A, B>(f: (a: A) => B) => <E>(fa: These<E, A>) => These<E, B>;

// @public
const map_4: <A, B>(f: (a: A) => B) => (fa: Array<A>) => Array<B>;

// @public (undocumented)
function map_40<F extends URIS3>(F: Functor3<F>): <A, B>(f: (a: A) => B) => <R, FE, E>(fa: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<E, B>>;

// @public (undocumented)
function map_40<F extends URIS3, FE>(F: Functor3C<F, FE>): <A, B>(f: (a: A) => B) => <R, E>(fa: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<E, B>>;

// @public (undocumented)
function map_40<F extends URIS2>(F: Functor2<F>): <A, B>(f: (a: A) => B) => <FE, E>(fa: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<E, B>>;

// @public (undocumented)
function map_40<F extends URIS2, FE>(F: Functor2C<F, FE>): <A, B>(f: (a: A) => B) => <E>(fa: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<E, B>>;

// @public (undocumented)
function map_40<F extends URIS>(F: Functor1<F>): <A, B>(f: (a: A) => B) => <E>(fa: Kind<F, These<E, A>>) => Kind<F, These<E, B>>;

// @public (undocumented)
function map_40<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => <E>(fa: HKT<F, These<E, A>>) => HKT<F, These<E, B>>;

// @public
const map_41: <A, B>(f: (a: A) => B) => <E>(fa: Traced<E, A>) => Traced<E, B>;

// @public
const map_42: <A, B>(f: (a: A) => B) => (fa: Tree<A>) => Tree<B>;

// @public @deprecated
const map_43: <A, B>(f: (a: A) => B) => <E>(fa: [A, E]) => [B, E];

// @public
const map_44: <A, B>(f: (a: A) => B) => <E>(fa: Writer<E, A>) => Writer<E, B>;

// @public
const map_5: <A, B>(f: (a: A) => B) => <E>(fa: Separated<E, A>) => Separated<E, B>;

// @public (undocumented)
const map_6: <A, B>(f: (a: A) => B) => (fa: Option_2<A>) => Option_2<B>;

// @public (undocumented)
const map_7: <A, B>(f: (a: A) => B) => <E>(fa: Either<E, A>) => Either<E, B>;

// @public
const map_8: <A, B>(f: (a: A) => B) => <E>(fa: Const<E, A>) => Const<E, B>;

// @public (undocumented)
function map_9<F extends URIS3>(F: Functor3<F>): <A, B>(f: (a: A) => B) => <R, FE, E>(fa: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<E, B>>;

// @public (undocumented)
function map_9<F extends URIS3, FE>(F: Functor3C<F, FE>): <A, B>(f: (a: A) => B) => <R, E>(fa: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<E, B>>;

// @public (undocumented)
function map_9<F extends URIS2>(F: Functor2<F>): <A, B>(f: (a: A) => B) => <FE, E>(fa: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<E, B>>;

// @public (undocumented)
function map_9<F extends URIS2, FE>(F: Functor2C<F, FE>): <A, B>(f: (a: A) => B) => <E>(fa: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<E, B>>;

// @public (undocumented)
function map_9<F extends URIS>(F: Functor1<F>): <A, B>(f: (a: A) => B) => <E>(fa: Kind<F, Either<E, A>>) => Kind<F, Either<E, B>>;

// @public (undocumented)
function map_9<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => <E>(fa: HKT<F, Either<E, A>>) => HKT<F, Either<E, B>>;

// @public
const mapBoth: {
    <E, G, A, B>(f: (e: E) => G, g: (a: A) => B): (self: IOEither<E, A>) => IOEither<G, B>;
    <E, A, G, B>(self: IOEither<E, A>, f: (e: E) => G, g: (a: A) => B): IOEither<G, B>;
};

// @public
const mapBoth_2: {
    <E, G, A, B>(f: (e: E) => G, g: (a: A) => B): <R>(self: ReaderEither<R, E, A>) => ReaderEither<R, G, B>;
    <R, E, A, G, B>(self: ReaderEither<R, E, A>, f: (e: E) => G, g: (a: A) => B): ReaderEither<R, G, B>;
};

// @public
const mapBoth_3: {
    <E, G, A, B>(f: (e: E) => G, g: (a: A) => B): (self: TaskEither<E, A>) => TaskEither<G, B>;
    <E, A, G, B>(self: TaskEither<E, A>, f: (e: E) => G, g: (a: A) => B): TaskEither<G, B>;
};

// @public
const mapBoth_4: {
    <E, G, A, B>(f: (e: E) => G, g: (a: A) => B): <R>(self: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, G, B>;
    <R, E, A, G, B>(self: ReaderTaskEither<R, E, A>, f: (e: E) => G, g: (a: A) => B): ReaderTaskEither<R, G, B>;
};

// @public
const mapError: {
    <E, G>(f: (e: E) => G): <A>(self: IOEither<E, A>) => IOEither<G, A>;
    <E, A, G>(self: IOEither<E, A>, f: (e: E) => G): IOEither<G, A>;
};

// @public
const mapError_2: {
    <R, E, G>(f: (e: E) => G): <A>(self: ReaderEither<R, E, A>) => ReaderEither<R, G, A>;
    <R, E, A, G>(self: ReaderEither<R, E, A>, f: (e: E) => G): ReaderEither<R, G, A>;
};

// @public
const mapError_3: {
    <E, G>(f: (e: E) => G): <A>(self: TaskEither<E, A>) => TaskEither<G, A>;
    <E, A, G>(self: TaskEither<E, A>, f: (e: E) => G): TaskEither<G, A>;
};

// @public
const mapError_4: {
    <R, E, G>(f: (e: E) => G): <A>(self: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, G, A>;
    <R, E, A, G>(self: ReaderTaskEither<R, E, A>, f: (e: E) => G): ReaderTaskEither<R, G, A>;
};

// @public
const mapFst: <A, B>(f: (a: A) => B) => <E>(fa: readonly [A, E]) => readonly [B, E];

// @public
const mapFst_2: <A, B>(f: (a: A) => B) => <E>(fa: [A, E]) => [B, E];

// @public
const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: Separated<E, A>) => Separated<G, A>;

// @public
const mapLeft_10: <E, G>(f: (e: E) => G) => <A>(fa: readonly [A, E]) => readonly [A, G];

// @public
const mapLeft_11: <E, G>(f: (e: E) => G) => <S, R, A>(fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, G, A>;

// @public
const mapLeft_12: <E, G>(f: (e: E) => G) => <A>(fa: TaskThese<E, A>) => TaskThese<G, A>;

// @public
const mapLeft_13: <E, G>(f: (e: E) => G) => <A>(fa: These<E, A>) => These<G, A>;

// @public (undocumented)
function mapLeft_14<F extends URIS3>(F: Functor3<F>): <E, G>(f: (e: E) => G) => <R, FE, A>(fea: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<G, A>>;

// @public (undocumented)
function mapLeft_14<F extends URIS3, FE>(F: Functor3C<F, FE>): <E, G>(f: (e: E) => G) => <R, A>(fea: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<G, A>>;

// @public (undocumented)
function mapLeft_14<F extends URIS2>(F: Functor2<F>): <E, G>(f: (e: E) => G) => <FE, A>(fea: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<G, A>>;

// @public (undocumented)
function mapLeft_14<F extends URIS2, FE>(F: Functor2C<F, FE>): <E, G>(f: (e: E) => G) => <A>(fea: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<G, A>>;

// @public (undocumented)
function mapLeft_14<F extends URIS>(F: Functor1<F>): <E, G>(f: (e: E) => G) => <A>(fea: Kind<F, These<E, A>>) => Kind<F, These<G, A>>;

// @public (undocumented)
function mapLeft_14<F>(F: Functor<F>): <E, G>(f: (e: E) => G) => <A>(fea: HKT<F, These<E, A>>) => HKT<F, These<G, A>>;

// @public @deprecated
const mapLeft_15: <E, G>(f: (e: E) => G) => <A>(fa: [A, E]) => [A, G];

// @public
const mapLeft_2: <E, G>(f: (e: E) => G) => <A>(fa: Either<E, A>) => Either<G, A>;

// @public
const mapLeft_3: <E, G>(f: (e: E) => G) => <A>(fa: Const<E, A>) => Const<G, A>;

// @public (undocumented)
function mapLeft_4<F extends URIS3>(F: Functor3<F>): <E, G>(f: (e: E) => G) => <R, FE, A>(self: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<G, A>>;

// @public (undocumented)
function mapLeft_4<F extends URIS3, FE>(F: Functor3C<F, FE>): <E, G>(f: (e: E) => G) => <R, A>(self: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<G, A>>;

// @public (undocumented)
function mapLeft_4<F extends URIS2>(F: Functor2<F>): <E, G>(f: (e: E) => G) => <FE, A>(self: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<G, A>>;

// @public (undocumented)
function mapLeft_4<F extends URIS2, FE>(F: Functor2C<F, FE>): <E, G>(f: (e: E) => G) => <A>(self: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<G, A>>;

// @public (undocumented)
function mapLeft_4<F extends URIS>(F: Functor1<F>): <E, G>(f: (e: E) => G) => <A>(self: Kind<F, Either<E, A>>) => Kind<F, Either<G, A>>;

// @public (undocumented)
function mapLeft_4<F>(F: Functor<F>): <E, G>(f: (e: E) => G) => <A>(self: HKT<F, Either<E, A>>) => HKT<F, Either<G, A>>;

// @public
const mapLeft_5: <E, G>(f: (e: E) => G) => <A>(fa: IOEither<E, A>) => IOEither<G, A>;

// @public
function mapLeft_6<F extends URIS4>(F: Bifunctor4<F>): <E, G>(f: (e: E) => G) => <S, R, A>(fea: Kind4<F, S, R, E, A>) => Kind4<F, S, R, G, A>;

// @public (undocumented)
function mapLeft_6<F extends URIS3>(F: Bifunctor3<F>): <E, G>(f: (e: E) => G) => <R, A>(fea: Kind3<F, R, E, A>) => Kind3<F, R, G, A>;

// @public (undocumented)
function mapLeft_6<F extends URIS3, E>(F: Bifunctor3C<F, E>): <E, G>(f: (e: E) => G) => <R, A>(fea: Kind3<F, R, E, A>) => Kind3<F, R, G, A>;

// @public (undocumented)
function mapLeft_6<F extends URIS2>(F: Bifunctor2<F>): <E, G>(f: (e: E) => G) => <A>(fea: Kind2<F, E, A>) => Kind2<F, G, A>;

// @public (undocumented)
function mapLeft_6<F extends URIS2, E>(F: Bifunctor2C<F, E>): <E, G>(f: (e: E) => G) => <A>(fea: Kind2<F, E, A>) => Kind2<F, G, A>;

// @public (undocumented)
function mapLeft_6<F>(F: Bifunctor_3<F>): <E, G>(f: (e: E) => G) => <A>(fea: HKT2<F, E, A>) => HKT2<F, G, A>;

// @public
const mapLeft_7: <E, G>(f: (e: E) => G) => <R, A>(fa: ReaderEither<R, E, A>) => ReaderEither<R, G, A>;

// @public
const mapLeft_8: <E, G>(f: (e: E) => G) => <A>(fa: TaskEither<E, A>) => TaskEither<G, A>;

// @public
const mapLeft_9: <E, G>(f: (e: E) => G) => <R, A>(fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, G, A>;

// @public @deprecated
const mapNullable: <A, B>(f: (a: A) => B | null | undefined) => (ma: Option_2<A>) => Option_2<NonNullable<B>>;

// @public
const mapSnd: <E, G>(f: (e: E) => G) => <A>(fa: readonly [A, E]) => readonly [A, G];

// @public
const mapSnd_2: <E, G>(f: (e: E) => G) => <A>(fa: [A, E]) => [A, G];

// @public (undocumented)
const mapWithIndex: <A, B>(f: (i: number, a: A) => B) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>;

// @public
const mapWithIndex_10: <K extends string, A, B>(f: (k: K, a: A) => B) => (fa: Record<K, A>) => Record<K, B>;

// @public (undocumented)
const mapWithIndex_2: <A, B>(f: (i: number, a: A) => B) => (as: NonEmptyArray<A>) => NonEmptyArray<B>;

// @public
const mapWithIndex_3: <A, B>(f: (i: number, a: A) => B) => (fa: Array<A>) => Array<B>;

// @public
function mapWithIndex_4<F extends URIS, I, G extends URIS, J>(F: FunctorWithIndex1<F, I>, G: FunctorWithIndex1<G, J>): <A, B>(f: (ij: readonly [I, J], a: A) => B) => (fa: Kind<F, Kind<G, A>>) => Kind<F, Kind<G, B>>;

// @public (undocumented)
function mapWithIndex_4<F, I, G, J>(F: FunctorWithIndex_4<F, I>, G: FunctorWithIndex_4<G, J>): <A, B>(f: (ij: readonly [I, J], a: A) => B) => (fa: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, B>>;

// @public (undocumented)
const mapWithIndex_5: <K, A, B>(f: (k: K, a: A) => B) => (fa: Map<K, A>) => Map<K, B>;

// @public
function mapWithIndex_6<F extends URIS4, I>(F: FunctorWithIndex4<F, I>): <A, B>(f: (i: I, a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function mapWithIndex_6<F extends URIS3, I>(F: FunctorWithIndex3<F, I>): <A, B>(f: (i: I, a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function mapWithIndex_6<F extends URIS3, I, E>(F: FunctorWithIndex3C<F, I, E>): <A, B>(f: (i: I, a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;

// @public (undocumented)
function mapWithIndex_6<F extends URIS2, I>(F: FunctorWithIndex2<F, I>): <A, B>(f: (i: I, a: A) => B) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function mapWithIndex_6<F extends URIS2, I, E>(F: FunctorWithIndex2C<F, I, E>): <A, B>(f: (i: I, a: A) => B) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>;

// @public (undocumented)
function mapWithIndex_6<F extends URIS, I>(F: FunctorWithIndex1<F, I>): <A, B>(f: (i: I, a: A) => B) => (fa: Kind<F, A>) => Kind<F, B>;

// @public (undocumented)
function mapWithIndex_6<F, I>(F: FunctorWithIndex_4<F, I>): <A, B>(f: (i: I, a: A) => B) => (fa: HKT<F, A>) => HKT<F, B>;

// @public (undocumented)
const mapWithIndex_7: <A, B>(f: (i: number, a: A) => B) => (fa: ReadonlyArray<A>) => ReadonlyArray<B>;

// @public (undocumented)
const mapWithIndex_8: <K, A, B>(f: (k: K, a: A) => B) => (fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B>;

// @public
function mapWithIndex_9<K extends string, A, B>(f: (k: K, a: A) => B): (fa: ReadonlyRecord<K, A>) => ReadonlyRecord<K, B>;

// @public
const match: <B, A>(onEmpty: LazyArg<B>, onNonEmpty: (as: NonEmptyArray<A>) => B) => (as: Array<A>) => B;

// @public (undocumented)
const match_10: <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => <R>(ma: ReaderEither<R, E, A>) => Reader<R, B>;

// @public (undocumented)
const match_11: <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTask<R, B>;

// @public (undocumented)
const match_12: <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: TaskEither<E, A>) => Task<B>;

// @public (undocumented)
const match_13: <B, A>(onEmpty: LazyArg<B>, onNonEmpty: (as: ReadonlyNonEmptyArray<A>) => B) => (as: ReadonlyArray<A>) => B;

// @public (undocumented)
const match_14: <B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: TaskOption<A>) => Task<B>;

// @public (undocumented)
const match_15: <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => (fa: TaskThese<E, A>) => Task<B>;

// @public (undocumented)
const match_16: <E, A, B>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => (fa: These<E, A>) => B;

// @public (undocumented)
function match_17<F extends URIS3>(F: Functor3<F>): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => <S, R>(ma: Kind3<F, S, R, These<E, A>>) => Kind3<F, S, R, B>;

// @public (undocumented)
function match_17<F extends URIS3, R>(F: Functor3C<F, R>): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => <S>(ma: Kind3<F, S, R, These<E, A>>) => Kind3<F, S, R, B>;

// @public (undocumented)
function match_17<F extends URIS2>(F: Functor2<F>): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => <R>(ma: Kind2<F, R, These<E, A>>) => Kind2<F, R, B>;

// @public (undocumented)
function match_17<M extends URIS2, R>(F: Functor2C<M, R>): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => (ma: Kind2<M, R, These<E, A>>) => Kind2<M, R, B>;

// @public (undocumented)
function match_17<F extends URIS>(F: Functor1<F>): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => (ma: Kind<F, These<E, A>>) => Kind<F, B>;

// @public (undocumented)
function match_17<F>(F: Functor<F>): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => (ma: HKT<F, These<E, A>>) => HKT<F, B>;

// @public
const match_2: <A, B>(onNone: LazyArg<B>, onSome: (a: A) => B) => (ma: Option_2<A>) => B;

// @public
const match_3: <E, A, B>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: Either<E, A>) => B;

// @public
const match_4: <A>(onFalse: LazyArg<A>, onTrue: LazyArg<A>) => (value: boolean) => A;

// @public (undocumented)
function match_5<F extends URIS3>(F: Functor3<F>): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => <R, ME>(ma: Kind3<F, R, ME, Either<E, A>>) => Kind3<F, R, ME, B>;

// @public (undocumented)
function match_5<F extends URIS3, FE>(F: Functor3C<F, FE>): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => <R>(ma: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, B>;

// @public (undocumented)
function match_5<F extends URIS2>(F: Functor2<F>): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => <FE>(ma: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, B>;

// @public (undocumented)
function match_5<F extends URIS2, FE>(F: Functor2C<F, FE>): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, B>;

// @public (undocumented)
function match_5<F extends URIS>(F: Functor1<F>): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: Kind<F, Either<E, A>>) => Kind<F, B>;

// @public (undocumented)
function match_5<F>(F: Functor<F>): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: HKT<F, Either<E, A>>) => HKT<F, B>;

// @public (undocumented)
const match_6: <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: IOEither<E, A>) => IO<B>;

// @public (undocumented)
const match_7: <B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: IOOption<A>) => IO<B>;

// @public (undocumented)
function match_8<F extends URIS4>(F: Functor4<F>): <B, A>(onNone: () => B, onSome: (a: A) => B) => <S, R, E>(ma: Kind4<F, S, R, E, Option_2<A>>) => Kind4<F, S, R, E, B>;

// @public (undocumented)
function match_8<F extends URIS3>(F: Functor3<F>): <B, A>(onNone: () => B, onSome: (a: A) => B) => <R, E>(ma: Kind3<F, R, E, Option_2<A>>) => Kind3<F, R, E, B>;

// @public (undocumented)
function match_8<F extends URIS3, E>(F: Functor3C<F, E>): <B, A>(onNone: () => B, onSome: (a: A) => B) => <R>(ma: Kind3<F, R, E, Option_2<A>>) => Kind3<F, R, E, B>;

// @public (undocumented)
function match_8<F extends URIS2>(F: Functor2<F>): <B, A>(onNone: () => B, onSome: (a: A) => B) => <E>(ma: Kind2<F, E, Option_2<A>>) => Kind2<F, E, B>;

// @public (undocumented)
function match_8<F extends URIS2, E>(F: Functor2C<F, E>): <B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: Kind2<F, E, Option_2<A>>) => Kind2<F, E, B>;

// @public (undocumented)
function match_8<F extends URIS>(F: Functor1<F>): <B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: Kind<F, Option_2<A>>) => Kind<F, B>;

// @public (undocumented)
function match_8<F>(F: Functor<F>): <B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: HKT<F, Option_2<A>>) => HKT<F, B>;

// @public (undocumented)
const match_9: <A>(onLessThan: () => A, onEqual: () => A, onGreaterThan: () => A) => (o: Ordering) => A;

// @public (undocumented)
function matchE<M extends URIS3>(M: Chain3<M>): <E, R, FE, B, A>(onLeft: (e: E) => Kind3<M, R, FE, B>, onRight: (a: A) => Kind3<M, R, FE, B>) => (ma: Kind3<M, R, FE, Either<E, A>>) => Kind3<M, R, FE, B>;

// @public (undocumented)
function matchE<M extends URIS3, FE>(M: Chain3C<M, FE>): <E, R, B, A>(onLeft: (e: E) => Kind3<M, R, FE, B>, onRight: (a: A) => Kind3<M, R, FE, B>) => (ma: Kind3<M, R, FE, Either<E, A>>) => Kind3<M, R, FE, B>;

// @public (undocumented)
function matchE<M extends URIS2>(M: Chain2<M>): <E, FE, B, A>(onLeft: (e: E) => Kind2<M, FE, B>, onRight: (a: A) => Kind2<M, FE, B>) => (ma: Kind2<M, FE, Either<E, A>>) => Kind2<M, FE, B>;

// @public (undocumented)
function matchE<M extends URIS2, FE>(M: Chain2C<M, FE>): <E, B, A>(onLeft: (e: E) => Kind2<M, FE, B>, onRight: (a: A) => Kind2<M, FE, B>) => (ma: Kind2<M, FE, Either<E, A>>) => Kind2<M, FE, B>;

// @public (undocumented)
function matchE<M extends URIS>(M: Chain1<M>): <E, B, A>(onLeft: (e: E) => Kind<M, B>, onRight: (a: A) => Kind<M, B>) => (ma: Kind<M, Either<E, A>>) => Kind<M, B>;

// @public (undocumented)
function matchE<M>(M: Chain_5<M>): <E, B, A>(onLeft: (e: E) => HKT<M, B>, onRight: (a: A) => HKT<M, B>) => (ma: HKT<M, Either<E, A>>) => HKT<M, B>;

// @public (undocumented)
function matchE_10<M extends URIS3>(M: Chain3<M>): <E, R, ME, B, A>(onLeft: (e: E) => Kind3<M, R, ME, B>, onRight: (a: A) => Kind3<M, R, ME, B>, onBoth: (e: E, a: A) => Kind3<M, R, ME, B>) => (ma: Kind3<M, R, ME, These<E, A>>) => Kind3<M, R, ME, B>;

// @public (undocumented)
function matchE_10<M extends URIS3, ME>(M: Chain3C<M, ME>): <E, R, B, A>(onLeft: (e: E) => Kind3<M, R, ME, B>, onRight: (a: A) => Kind3<M, R, ME, B>, onBoth: (e: E, a: A) => Kind3<M, R, ME, B>) => (ma: Kind3<M, R, ME, These<E, A>>) => Kind3<M, R, ME, B>;

// @public (undocumented)
function matchE_10<M extends URIS2>(M: Chain2<M>): <E, ME, B, A>(onLeft: (e: E) => Kind2<M, ME, B>, onRight: (a: A) => Kind2<M, ME, B>, onBoth: (e: E, a: A) => Kind2<M, ME, B>) => (ma: Kind2<M, ME, These<E, A>>) => Kind2<M, ME, B>;

// @public (undocumented)
function matchE_10<M extends URIS2, ME>(M: Chain2C<M, ME>): <E, B, A>(onLeft: (e: E) => Kind2<M, ME, B>, onRight: (a: A) => Kind2<M, ME, B>, onBoth: (e: E, a: A) => Kind2<M, ME, B>) => (ma: Kind2<M, ME, These<E, A>>) => Kind2<M, ME, B>;

// @public (undocumented)
function matchE_10<M extends URIS>(M: Chain1<M>): <E, B, A>(onLeft: (e: E) => Kind<M, B>, onRight: (a: A) => Kind<M, B>, onBoth: (e: E, a: A) => Kind<M, B>) => (ma: Kind<M, These<E, A>>) => Kind<M, B>;

// @public (undocumented)
function matchE_10<M>(M: Chain_5<M>): <E, B, A>(onLeft: (e: E) => HKT<M, B>, onRight: (a: A) => HKT<M, B>, onBoth: (e: E, a: A) => HKT<M, B>) => (ma: HKT<M, These<E, A>>) => HKT<M, B>;

// @public
const matchE_2: <E, A, B>(onLeft: (e: E) => IO<B>, onRight: (a: A) => IO<B>) => (ma: IOEither<E, A>) => IO<B>;

// @public
const matchE_3: <B, A>(onNone: () => IO<B>, onSome: (a: A) => IO<B>) => (ma: IOOption<A>) => IO<B>;

// @public (undocumented)
function matchE_4<M extends URIS4>(M: Chain4<M>): <S, R, E, B, A>(onNone: () => Kind4<M, S, R, E, B>, onSome: (a: A) => Kind4<M, S, R, E, B>) => (ma: Kind4<M, S, R, E, Option_2<A>>) => Kind4<M, S, R, E, B>;

// @public (undocumented)
function matchE_4<M extends URIS3>(M: Chain3<M>): <R, E, B, A>(onNone: () => Kind3<M, R, E, B>, onSome: (a: A) => Kind3<M, R, E, B>) => (ma: Kind3<M, R, E, Option_2<A>>) => Kind3<M, R, E, B>;

// @public (undocumented)
function matchE_4<M extends URIS3, E>(M: Chain3C<M, E>): <R, B, A>(onNone: () => Kind3<M, R, E, B>, onSome: (a: A) => Kind3<M, R, E, B>) => (ma: Kind3<M, R, E, Option_2<A>>) => Kind3<M, R, E, B>;

// @public (undocumented)
function matchE_4<M extends URIS2>(M: Chain2<M>): <E, B, A>(onNone: () => Kind2<M, E, B>, onSome: (a: A) => Kind2<M, E, B>) => (ma: Kind2<M, E, Option_2<A>>) => Kind2<M, E, B>;

// @public (undocumented)
function matchE_4<M extends URIS2, E>(M: Chain2C<M, E>): <B, A>(onNone: () => Kind2<M, E, B>, onSome: (a: A) => Kind2<M, E, B>) => (ma: Kind2<M, E, Option_2<A>>) => Kind2<M, E, B>;

// @public (undocumented)
function matchE_4<M extends URIS>(M: Chain1<M>): <B, A>(onNone: () => Kind<M, B>, onSome: (a: A) => Kind<M, B>) => (ma: Kind<M, Option_2<A>>) => Kind<M, B>;

// @public (undocumented)
function matchE_4<M>(M: Chain_5<M>): <B, A>(onNone: () => HKT<M, B>, onSome: (a: A) => HKT<M, B>) => (ma: HKT<M, Option_2<A>>) => HKT<M, B>;

// @public
const matchE_5: <R, E, A, B>(onLeft: (e: E) => Reader<R, B>, onRight: (a: A) => Reader<R, B>) => (ma: ReaderEither<R, E, A>) => Reader<R, B>;

// @public
const matchE_6: <R, E, A, B>(onLeft: (e: E) => ReaderTask<R, B>, onRight: (a: A) => ReaderTask<R, B>) => (ma: ReaderTaskEither<R, E, A>) => ReaderTask<R, B>;

// @public
const matchE_7: <E, A, B>(onLeft: (e: E) => Task<B>, onRight: (a: A) => Task<B>) => (ma: TaskEither<E, A>) => Task<B>;

// @public
const matchE_8: <B, A>(onNone: () => Task<B>, onSome: (a: A) => Task<B>) => (ma: TaskOption<A>) => Task<B>;

// @public
const matchE_9: <E, B, A>(onLeft: (e: E) => Task<B>, onRight: (a: A) => Task<B>, onBoth: (e: E, a: A) => Task<B>) => (fa: TaskThese<E, A>) => Task<B>;

// @public
const matchEW: <E, B, A, C>(onLeft: (e: E) => IO<B>, onRight: (a: A) => IO<C>) => (ma: IOEither<E, A>) => IO<B | C>;

// @public
const matchEW_2: <B, C, A>(onNone: () => IO<B>, onSome: (a: A) => IO<C>) => (ma: IOOption<A>) => IO<B | C>;

// @public
const matchEW_3: <E, R2, B, A, R3, C>(onLeft: (e: E) => Reader<R2, B>, onRight: (a: A) => Reader<R3, C>) => <R1>(ma: ReaderEither<R1, E, A>) => Reader<R1 & R2 & R3, B | C>;

// @public
const matchEW_4: <E, R2, B, A, R3, C>(onLeft: (e: E) => ReaderTask<R2, B>, onRight: (a: A) => ReaderTask<R3, C>) => <R1>(ma: ReaderTaskEither<R1, E, A>) => ReaderTask<R1 & R2 & R3, B | C>;

// @public
const matchEW_5: <E, B, A, C>(onLeft: (e: E) => Task<B>, onRight: (a: A) => Task<C>) => (ma: TaskEither<E, A>) => Task<B | C>;

// @public
const matchEW_6: <B, C, A>(onNone: () => Task<B>, onSome: (a: A) => Task<C>) => (ma: TaskOption<A>) => Task<B | C>;

// @public
const matchEW_7: <E, B, A, C, D>(onLeft: (e: E) => Task<B>, onRight: (a: A) => Task<C>, onBoth: (e: E, a: A) => Task<D>) => (fa: TaskThese<E, A>) => Task<B | C | D>;

// @public
const matchLeft: <A, B>(f: (head: A, tail: readonly A[]) => B) => (as: ReadonlyNonEmptyArray<A>) => B;

// @public
const matchLeft_2: <A, B>(f: (head: A, tail: A[]) => B) => (as: NonEmptyArray<A>) => B;

// @public
const matchLeft_3: <B, A>(onEmpty: LazyArg<B>, onNonEmpty: (head: A, tail: Array<A>) => B) => (as: Array<A>) => B;

// @public
const matchLeft_4: <B, A>(onEmpty: LazyArg<B>, onNonEmpty: (head: A, tail: ReadonlyArray<A>) => B) => (as: ReadonlyArray<A>) => B;

// @public
const matchLeftW: <B, A, C>(onEmpty: LazyArg<B>, onNonEmpty: (head: A, tail: A[]) => C) => (as: A[]) => B | C;

// @public
const matchLeftW_2: <B, A, C>(onEmpty: LazyArg<B>, onNonEmpty: (head: A, tail: readonly A[]) => C) => (as: readonly A[]) => B | C;

// @public
const matchRight: <A, B>(f: (init: readonly A[], last: A) => B) => (as: ReadonlyNonEmptyArray<A>) => B;

// @public
const matchRight_2: <A, B>(f: (init: A[], last: A) => B) => (as: NonEmptyArray<A>) => B;

// @public
const matchRight_3: <B, A>(onEmpty: LazyArg<B>, onNonEmpty: (init: Array<A>, last: A) => B) => (as: Array<A>) => B;

// @public
const matchRight_4: <B, A>(onEmpty: LazyArg<B>, onNonEmpty: (init: ReadonlyArray<A>, last: A) => B) => (as: ReadonlyArray<A>) => B;

// @public
const matchRightW: <B, A, C>(onEmpty: LazyArg<B>, onNonEmpty: (init: A[], last: A) => C) => (as: A[]) => B | C;

// @public
const matchRightW_2: <B, A, C>(onEmpty: LazyArg<B>, onNonEmpty: (init: readonly A[], last: A) => C) => (as: readonly A[]) => B | C;

// @public
const matchW: <B, A, C>(onEmpty: LazyArg<B>, onNonEmpty: (as: nonEmptyArray.NonEmptyArray<A>) => C) => (as: A[]) => B | C;

// @public
const matchW_10: <E, B, A, C>(onLeft: (e: E) => B, onRight: (a: A) => C) => (ma: TaskEither<E, A>) => Task<B | C>;

// @public
const matchW_11: <B, A, C>(onEmpty: LazyArg<B>, onNonEmpty: (as: readonlyNonEmptyArray.ReadonlyNonEmptyArray<A>) => C) => (as: readonly A[]) => B | C;

// @public
const matchW_12: <B, A, C>(onNone: () => B, onSome: (a: A) => C) => (ma: TaskOption<A>) => Task<B | C>;

// @public
const matchW_13: <E, B, A, C, D>(onLeft: (e: E) => B, onRight: (a: A) => C, onBoth: (e: E, a: A) => D) => (ma: TaskThese<E, A>) => task.Task<B | C | D>;

// @public
const matchW_14: <E, B, A, C, D>(onLeft: (e: E) => B, onRight: (a: A) => C, onBoth: (e: E, a: A) => D) => (fa: These<E, A>) => B | C | D;

// @public
const matchW_2: <B, A, C>(onNone: LazyArg<B>, onSome: (a: A) => C) => (ma: Option_2<A>) => B | C;

// @public
const matchW_3: <E, B, A, C>(onLeft: (e: E) => B, onRight: (a: A) => C) => (ma: Either<E, A>) => B | C;

// @public
const matchW_4: <A, B>(onFalse: LazyArg<A>, onTrue: LazyArg<B>) => (value: boolean) => A | B;

// @public
const matchW_5: <E, B, A, C>(onLeft: (e: E) => B, onRight: (a: A) => C) => (ma: IOEither<E, A>) => IO<B | C>;

// @public
const matchW_6: <B, A, C>(onNone: () => B, onSome: (a: A) => C) => (ma: IOOption<A>) => IO<B | C>;

// @public
const matchW_7: <A, B, C>(onLessThan: () => A, onEqual: () => B, onGreaterThan: () => C) => (o: Ordering) => A | B | C;

// @public
const matchW_8: <E, B, A, C>(onLeft: (e: E) => B, onRight: (a: A) => C) => <R>(ma: Reader<R, Either<E, A>>) => Reader<R, B | C>;

// @public
const matchW_9: <E, B, A, C>(onLeft: (e: E) => B, onRight: (a: A) => C) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTask<R, B | C>;

// @public
const max: <A>(O: Ord<A>) => (first: A, second: A) => A;

// @public
const max_2: <A>(O: ord.Ord<A>) => Semigroup<A>;

// @public (undocumented)
const max_3: <A>(O: Ord<A>) => (as: ReadonlyNonEmptyArray<A>) => A;

// @public (undocumented)
const max_4: <A>(ord: Ord<A>) => (nea: NonEmptyArray<A>) => A;

// @public
const max_5: <A>(B: Bounded<A>) => Monoid<A>;

// @public (undocumented)
interface MeetSemilattice<A> {
    // (undocumented)
    readonly meet: (x: A, y: A) => A;
}

declare namespace meetSemilattice {
    export {
        MeetSemilattice
    }
}
export { meetSemilattice }

// @public
const member: <K>(E: Eq<K>) => {
    (k: K): <A>(m: Map<K, A>) => boolean;
    <A>(k: K, m: Map<K, A>): boolean;
};

// @public
function member_2<K>(E: Eq<K>): {
    (k: K): <A>(m: ReadonlyMap<K, A>) => boolean;
    <A>(k: K, m: ReadonlyMap<K, A>): boolean;
};

// @public
const min: <A>(O: ord.Ord<A>) => Semigroup<A>;

// @public
const min_2: <A>(O: Ord<A>) => (first: A, second: A) => A;

// @public (undocumented)
const min_3: <A>(O: Ord<A>) => (as: ReadonlyNonEmptyArray<A>) => A;

// @public (undocumented)
const min_4: <A>(ord: Ord<A>) => (nea: NonEmptyArray<A>) => A;

// @public
const min_5: <A>(B: Bounded<A>) => Monoid<A>;

// @public (undocumented)
function modify<F extends URIS4>(F: FromState4<F>): <S, R, E>(f: Endomorphism<S>) => Kind4<F, S, R, E, void>;

// @public (undocumented)
function modify<F extends URIS3>(F: FromState3<F>): <S, E>(f: Endomorphism<S>) => Kind3<F, S, E, void>;

// @public (undocumented)
function modify<F extends URIS3, E>(F: FromState3C<F, E>): <S>(f: Endomorphism<S>) => Kind3<F, S, E, void>;

// @public (undocumented)
function modify<F extends URIS2>(F: FromState2<F>): <S>(f: Endomorphism<S>) => Kind2<F, S, void>;

// @public (undocumented)
function modify<F>(F: FromState<F>): <S>(f: Endomorphism<S>) => HKT2<F, S, void>;

// @public
const modify_2: <S>(f: (s: S) => S) => State<S, void>;

// @public
const modify_3: <S, R, E = never>(f: Endomorphism<S>) => StateReaderTaskEither<S, R, E, void>;

// @public (undocumented)
const modifyAt: <A>(i: number, f: (a: A) => A) => (as: ReadonlyNonEmptyArray<A>) => Option_2<ReadonlyNonEmptyArray<A>>;

// @public (undocumented)
const modifyAt_2: <A>(i: number, f: (a: A) => A) => (as: NonEmptyArray<A>) => Option_2<NonEmptyArray<A>>;

// @public
const modifyAt_3: <A>(i: number, f: (a: A) => A) => (as: A[]) => Option_2<A[]>;

// @public (undocumented)
const modifyAt_4: <K>(E: Eq<K>) => <A>(k: K, f: (a: A) => A) => (m: Map<K, A>) => option.Option<Map<K, A>>;

// @public
const modifyAt_5: <A>(i: number, f: (a: A) => A) => (as: readonly A[]) => Option_2<readonly A[]>;

// @public (undocumented)
const modifyAt_6: <K>(E: Eq<K>) => <A>(k: K, f: (a: A) => A) => (m: ReadonlyMap<K, A>) => option.Option<ReadonlyMap<K, A>>;

// @public
const modifyAt_7: <A>(k: string, f: (a: A) => A) => <K extends string>(r: Readonly<Record<K, A>>) => Option_2<Readonly<Record<K, A>>>;

// @public
const modifyAt_8: <A>(k: string, f: (a: A) => A) => <K extends string>(r: Record<K, A>) => Option_2<Record<K, A>>;

// @public
const modifyHead: <A>(f: Endomorphism<A>) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public
const modifyHead_2: <A>(f: Endomorphism<A>) => (as: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public
const modifyLast: <A>(f: Endomorphism<A>) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public
const modifyLast_2: <A>(f: Endomorphism<A>) => (as: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public (undocumented)
const Monad: Monad1<URI_2>;

declare namespace monad {
    export {
        Monad_6 as Monad,
        Monad1,
        Monad2,
        Monad2C,
        Monad3,
        Monad3C,
        Monad4
    }
}
export { monad }

// @public (undocumented)
interface Monad1<F extends URIS> extends Applicative1<F>, Chain1<F> {
}

// @public (undocumented)
interface Monad2<M extends URIS2> extends Applicative2<M>, Chain2<M> {
}

// @public (undocumented)
interface Monad2C<M extends URIS2, L> extends Applicative2C<M, L>, Chain2C<M, L> {
}

// @public (undocumented)
interface Monad3<M extends URIS3> extends Applicative3<M>, Chain3<M> {
}

// @public (undocumented)
interface Monad3C<M extends URIS3, E> extends Applicative3C<M, E>, Chain3C<M, E> {
}

// @public (undocumented)
interface Monad4<M extends URIS4> extends Applicative4<M>, Chain4<M> {
}

// @public (undocumented)
const Monad_10: Monad1<URI_14>;

// @public (undocumented)
const Monad_11: Monad2<URI_17>;

// @public (undocumented)
const Monad_12: Monad3<URI_18>;

// @public (undocumented)
const Monad_13: Monad2<URI_19>;

// @public (undocumented)
const Monad_14: Monad2<URI_20>;

// @public (undocumented)
const Monad_15: Monad1<URI_21>;

// @public (undocumented)
const Monad_16: Monad2<URI_23>;

// @public (undocumented)
const Monad_17: Monad3<URI_22>;

// @public (undocumented)
const Monad_18: Monad1<URI_24>;

// @public (undocumented)
const Monad_19: Monad2<URI_30>;

// @public (undocumented)
const Monad_2: Monad1<URI_3>;

// @public (undocumented)
const Monad_20: Monad4<URI_31>;

// @public (undocumented)
const Monad_21: Monad1<URI_33>;

// @public (undocumented)
const Monad_22: Monad1<URI_37>;

// @public (undocumented)
const Monad_3: Monad1<URI_4>;

// @public (undocumented)
const Monad_4: Monad1<URI_7>;

// @public (undocumented)
const Monad_5: Monad2<URI_6>;

// @public (undocumented)
interface Monad_6<F> extends Applicative<F>, Chain_5<F> {
}

// @public (undocumented)
const Monad_7: Monad1<URI_11>;

// @public (undocumented)
const Monad_8: Monad1<URI_12>;

// @public (undocumented)
const Monad_9: Monad2<URI_13>;

// @public (undocumented)
const MonadIO: MonadIO1<URI_12>;

declare namespace monadIO {
    export {
        MonadIO_4 as MonadIO,
        MonadIO1,
        MonadIO2,
        MonadIO2C,
        MonadIO3,
        MonadIO3C,
        MonadIO4
    }
}
export { monadIO }

// @public (undocumented)
interface MonadIO1<M extends URIS> extends Monad1<M>, FromIO1<M> {
}

// @public (undocumented)
interface MonadIO2<M extends URIS2> extends Monad2<M>, FromIO2<M> {
}

// @public (undocumented)
interface MonadIO2C<M extends URIS2, E> extends Monad2C<M, E>, FromIO2C<M, E> {
}

// @public (undocumented)
interface MonadIO3<M extends URIS3> extends Monad3<M>, FromIO3<M> {
}

// @public (undocumented)
interface MonadIO3C<M extends URIS3, E> extends Monad3C<M, E>, FromIO3C<M, E> {
}

// @public (undocumented)
interface MonadIO4<M extends URIS4> extends Monad4<M>, FromIO4<M> {
}

// @public (undocumented)
const MonadIO_10: MonadIO4<URI_31>;

// @public (undocumented)
const MonadIO_11: MonadIO1<URI_33>;

// @public (undocumented)
const MonadIO_2: MonadIO2<URI_13>;

// @public (undocumented)
const MonadIO_3: MonadIO1<URI_14>;

// @public (undocumented)
interface MonadIO_4<M> extends Monad_6<M>, FromIO<M> {
}

// @public (undocumented)
const MonadIO_5: MonadIO2<URI_19>;

// @public (undocumented)
const MonadIO_6: MonadIO2<URI_20>;

// @public (undocumented)
const MonadIO_7: MonadIO1<URI_21>;

// @public (undocumented)
const MonadIO_8: MonadIO2<URI_23>;

// @public (undocumented)
const MonadIO_9: MonadIO3<URI_22>;

// @public (undocumented)
interface MonadTask<M> extends MonadIO_4<M>, FromTask<M> {
}

declare namespace monadTask {
    export {
        MonadTask,
        MonadTask1,
        MonadTask2,
        MonadTask2C,
        MonadTask3,
        MonadTask3C,
        MonadTask4
    }
}
export { monadTask }

// @public (undocumented)
interface MonadTask1<M extends URIS> extends MonadIO1<M>, FromTask1<M> {
}

// @public (undocumented)
interface MonadTask2<M extends URIS2> extends MonadIO2<M>, FromTask2<M> {
}

// @public (undocumented)
interface MonadTask2C<M extends URIS2, E> extends MonadIO2C<M, E>, FromTask2C<M, E> {
}

// @public (undocumented)
interface MonadTask3<M extends URIS3> extends MonadIO3<M>, FromTask3<M> {
}

// @public (undocumented)
interface MonadTask3C<M extends URIS3, E> extends MonadIO3C<M, E>, FromTask3C<M, E> {
}

// @public (undocumented)
interface MonadTask4<M extends URIS4> extends MonadIO4<M>, FromTask4<M> {
}

// @public (undocumented)
const MonadTask_2: MonadTask2<URI_20>;

// @public (undocumented)
const MonadTask_3: MonadTask1<URI_21>;

// @public (undocumented)
const MonadTask_4: MonadTask2<URI_23>;

// @public (undocumented)
const MonadTask_5: MonadTask3<URI_22>;

// @public (undocumented)
const MonadTask_6: MonadTask4<URI_31>;

// @public (undocumented)
const MonadTask_7: MonadTask1<URI_33>;

// @public (undocumented)
const MonadThrow: MonadThrow1<URI_7>;

declare namespace monadThrow {
    export {
        MonadThrow_5 as MonadThrow,
        MonadThrow1,
        MonadThrow2,
        MonadThrow2C,
        MonadThrow3,
        MonadThrow3C,
        MonadThrow4
    }
}
export { monadThrow }

// @public (undocumented)
interface MonadThrow1<M extends URIS> extends Monad1<M> {
    // (undocumented)
    readonly throwError: <E, A>(e: E) => Kind<M, A>;
}

// @public (undocumented)
interface MonadThrow2<M extends URIS2> extends Monad2<M> {
    // (undocumented)
    readonly throwError: <E, A>(e: E) => Kind2<M, E, A>;
}

// @public (undocumented)
interface MonadThrow2C<M extends URIS2, E> extends Monad2C<M, E> {
    // (undocumented)
    readonly throwError: <A>(e: E) => Kind2<M, E, A>;
}

// @public (undocumented)
interface MonadThrow3<M extends URIS3> extends Monad3<M> {
    // (undocumented)
    readonly throwError: <R, E, A>(e: E) => Kind3<M, R, E, A>;
}

// @public (undocumented)
interface MonadThrow3C<M extends URIS3, E> extends Monad3C<M, E> {
    // (undocumented)
    readonly throwError: <R, A>(e: E) => Kind3<M, R, E, A>;
}

// @public (undocumented)
interface MonadThrow4<M extends URIS4> extends Monad4<M> {
    // (undocumented)
    readonly throwError: <S, R, E, A>(e: E) => Kind4<M, S, R, E, A>;
}

// @public (undocumented)
const MonadThrow_10: MonadThrow1<URI_33>;

// @public (undocumented)
const MonadThrow_2: MonadThrow2<URI_6>;

// @public (undocumented)
const MonadThrow_3: MonadThrow2<URI_13>;

// @public (undocumented)
const MonadThrow_4: MonadThrow1<URI_14>;

// @public (undocumented)
interface MonadThrow_5<M> extends Monad_6<M> {
    // (undocumented)
    readonly throwError: <E, A>(e: E) => HKT<M, A>;
}

// @public (undocumented)
const MonadThrow_6: MonadThrow3<URI_18>;

// @public (undocumented)
const MonadThrow_7: MonadThrow2<URI_23>;

// @public (undocumented)
const MonadThrow_8: MonadThrow3<URI_22>;

// @public (undocumented)
const MonadThrow_9: MonadThrow4<URI_31>;

// @public (undocumented)
interface Monoid<A> extends semigroup.Semigroup<A> {
    // (undocumented)
    readonly empty: A;
}

declare namespace monoid {
    export {
        Monoid,
        min_5 as min,
        max_5 as max,
        reverse_6 as reverse,
        struct_3 as struct,
        tuple_4 as tuple,
        concatAll_4 as concatAll,
        monoidVoid,
        getTupleMonoid,
        getStructMonoid,
        getDualMonoid,
        getJoinMonoid,
        getMeetMonoid,
        fold_4 as fold,
        monoidAll,
        monoidAny,
        getFunctionMonoid,
        getEndomorphismMonoid,
        monoidString,
        monoidSum,
        monoidProduct
    }
}
export { monoid }

// @public (undocumented)
const Monoid_2: monoid.Monoid<Ordering>;

// @public
const Monoid_3: monoid.Monoid<string>;

// @public (undocumented)
const Monoid_4: monoid.Monoid<void>;

// @public
const MonoidAll: Monoid<boolean>;

// @public @deprecated
const monoidAll: Monoid<boolean>;

// @public
const MonoidAny: Monoid<boolean>;

// @public @deprecated
const monoidAny: Monoid<boolean>;

// @public @deprecated
const monoidOrdering: monoid.Monoid<Ordering>;

// @public
const MonoidProduct: Monoid<number>;

// @public @deprecated
const monoidProduct: Monoid<number>;

// @public @deprecated
const monoidString: Monoid<string>;

// @public
const MonoidSum: Monoid<number>;

// @public @deprecated
const monoidSum: Monoid<number>;

// @public @deprecated
const monoidVoid: Monoid<void>;

// @public (undocumented)
interface NaturalTransformation<F, G> {
    // (undocumented)
    <A>(fa: HKT<F, A>): HKT<G, A>;
}

declare namespace naturalTransformation {
    export {
        NaturalTransformation,
        NaturalTransformation11,
        NaturalTransformation12,
        NaturalTransformation12C,
        NaturalTransformation13,
        NaturalTransformation13C,
        NaturalTransformation14,
        NaturalTransformation14C,
        NaturalTransformation21,
        NaturalTransformation22,
        NaturalTransformation22C,
        NaturalTransformation23,
        NaturalTransformation23C,
        NaturalTransformation24,
        NaturalTransformation23R,
        NaturalTransformation23RC,
        NaturalTransformation24R,
        NaturalTransformation24S,
        NaturalTransformation33,
        NaturalTransformation34
    }
}
export { naturalTransformation }

// @public (undocumented)
interface NaturalTransformation11<F extends URIS, G extends URIS> {
    // (undocumented)
    <A>(fa: Kind<F, A>): Kind<G, A>;
}

// @public (undocumented)
interface NaturalTransformation12<F extends URIS, G extends URIS2> {
    // (undocumented)
    <A, E>(fa: Kind<F, A>): Kind2<G, E, A>;
}

// @public (undocumented)
interface NaturalTransformation12C<F extends URIS, G extends URIS2, E> {
    // (undocumented)
    <A>(fa: Kind<F, A>): Kind2<G, E, A>;
}

// @public (undocumented)
interface NaturalTransformation13<F extends URIS, G extends URIS3> {
    // (undocumented)
    <A, R, E>(fa: Kind<F, A>): Kind3<G, R, E, A>;
}

// @public (undocumented)
interface NaturalTransformation13C<F extends URIS, G extends URIS3, E> {
    // (undocumented)
    <A, R>(fa: Kind<F, A>): Kind3<G, R, E, A>;
}

// @public (undocumented)
interface NaturalTransformation14<F extends URIS, G extends URIS4> {
    // (undocumented)
    <A, S, R, E>(fa: Kind<F, A>): Kind4<G, S, R, E, A>;
}

// @public (undocumented)
interface NaturalTransformation14C<F extends URIS, G extends URIS4, E> {
    // (undocumented)
    <A, S, R>(fa: Kind<F, A>): Kind4<G, S, R, E, A>;
}

// @public (undocumented)
interface NaturalTransformation21<F extends URIS2, G extends URIS> {
    // (undocumented)
    <A>(fa: Kind2<F, unknown, A>): Kind<G, A>;
}

// @public (undocumented)
interface NaturalTransformation22<F extends URIS2, G extends URIS2> {
    // (undocumented)
    <E, A>(fa: Kind2<F, E, A>): Kind2<G, E, A>;
}

// @public (undocumented)
interface NaturalTransformation22C<F extends URIS2, G extends URIS2, E> {
    // (undocumented)
    <A>(fa: Kind2<F, E, A>): Kind2<G, E, A>;
}

// @public (undocumented)
interface NaturalTransformation23<F extends URIS2, G extends URIS3> {
    // (undocumented)
    <E, A, R>(fa: Kind2<F, E, A>): Kind3<G, R, E, A>;
}

// @public (undocumented)
interface NaturalTransformation23C<F extends URIS2, G extends URIS3, E> {
    // (undocumented)
    <A, R>(fa: Kind2<F, E, A>): Kind3<G, R, E, A>;
}

// @public (undocumented)
interface NaturalTransformation23R<F extends URIS2, G extends URIS3> {
    // (undocumented)
    <R, A, E>(fa: Kind2<F, R, A>): Kind3<G, R, E, A>;
}

// @public (undocumented)
interface NaturalTransformation23RC<F extends URIS2, G extends URIS3, E> {
    // (undocumented)
    <R, A>(fa: Kind2<F, R, A>): Kind3<G, R, E, A>;
}

// @public (undocumented)
interface NaturalTransformation24<F extends URIS2, G extends URIS4> {
    // (undocumented)
    <E, A, S, R>(fa: Kind2<F, E, A>): Kind4<G, S, R, E, A>;
}

// @public (undocumented)
interface NaturalTransformation24R<F extends URIS2, G extends URIS4> {
    // (undocumented)
    <R, A, S, E>(fa: Kind2<F, R, A>): Kind4<G, S, R, E, A>;
}

// @public (undocumented)
interface NaturalTransformation24S<F extends URIS2, G extends URIS4> {
    // (undocumented)
    <S, A, R, E>(fa: Kind2<F, S, A>): Kind4<G, S, R, E, A>;
}

// @public (undocumented)
interface NaturalTransformation33<F extends URIS3, G extends URIS3> {
    // (undocumented)
    <R, E, A>(fa: Kind3<F, R, E, A>): Kind3<G, R, E, A>;
}

// @public (undocumented)
interface NaturalTransformation34<F extends URIS3, G extends URIS4> {
    // (undocumented)
    <R, E, A, S>(fa: Kind3<F, R, E, A>): Kind4<G, S, R, E, A>;
}

// @public
const negate: <A>(R: Ring<A>) => (a: A) => A;

// @public
const never: Task<never>;

// @public (undocumented)
function newIORef<A>(a: A): IO<IORef<A>>;

// @public (undocumented)
interface None {
    // (undocumented)
    readonly _tag: 'None';
}

// @public
const none: Option_2<never>;

// @public (undocumented)
const none_2: IOOption<never>;

// @public (undocumented)
const none_3: TaskOption<never>;

// @public (undocumented)
interface NonEmptyArray<A> extends Array<A> {
    // (undocumented)
    0: A;
}

declare namespace nonEmptyArray {
    export {
        concatW,
        concat,
        group_2 as group,
        zip_2 as zip,
        groupSort,
        filter,
        cons,
        NonEmptyArray,
        uniq,
        sortBy,
        union_2 as union,
        rotate,
        fromReadonlyNonEmptyArray,
        fromArray,
        makeBy,
        replicate,
        range_2 as range,
        unprepend_2 as unprepend,
        unappend_2 as unappend,
        reverse_4 as reverse,
        groupBy_2 as groupBy,
        sort_2 as sort,
        insertAt_2 as insertAt,
        updateAt_2 as updateAt,
        modifyAt_2 as modifyAt,
        copy,
        of_2 as of,
        zipWith_2 as zipWith,
        unzip_2 as unzip,
        prependAll_2 as prependAll,
        intersperse_2 as intersperse,
        foldMapWithIndex_2 as foldMapWithIndex,
        foldMap_2 as foldMap,
        chainWithIndex_2 as chainWithIndex,
        chop_2 as chop,
        splitAt_2 as splitAt,
        chunksOf_2 as chunksOf,
        altW_2 as altW,
        alt_3 as alt,
        ap_3 as ap,
        flatMap_2 as flatMap,
        extend_3 as extend,
        duplicate_2 as duplicate,
        flatten_2 as flatten,
        map_3 as map,
        mapWithIndex_2 as mapWithIndex,
        reduce_2 as reduce,
        reduceWithIndex_2 as reduceWithIndex,
        reduceRight_2 as reduceRight,
        reduceRightWithIndex_2 as reduceRightWithIndex,
        traverse_2 as traverse,
        sequence_2 as sequence,
        traverseWithIndex_2 as traverseWithIndex,
        extract_2 as extract,
        URI_3 as URI,
        getShow_2 as getShow,
        getSemigroup_3 as getSemigroup,
        getEq_2 as getEq,
        getUnionSemigroup_2 as getUnionSemigroup,
        Functor_3 as Functor,
        flap_2 as flap,
        Pointed_3 as Pointed,
        FunctorWithIndex_2 as FunctorWithIndex,
        Apply_3 as Apply,
        apFirst_3 as apFirst,
        apSecond_3 as apSecond,
        Applicative_3 as Applicative,
        Chain_2 as Chain,
        chainFirst_2 as chainFirst,
        Monad_2 as Monad,
        Foldable_2 as Foldable,
        FoldableWithIndex_2 as FoldableWithIndex,
        Traversable_2 as Traversable,
        TraversableWithIndex_2 as TraversableWithIndex,
        Alt_3 as Alt,
        Comonad_2 as Comonad,
        Do_2 as Do,
        bindTo_2 as bindTo,
        let__2 as let,
        bind_2 as bind,
        apS_3 as apS,
        head_2 as head,
        tail_2 as tail,
        last_3 as last,
        init_2 as init,
        min_4 as min,
        max_4 as max,
        concatAll_3 as concatAll,
        matchLeft_2 as matchLeft,
        matchRight_2 as matchRight,
        modifyHead_2 as modifyHead,
        updateHead_2 as updateHead,
        modifyLast_2 as modifyLast,
        updateLast_2 as updateLast,
        intercalate_3 as intercalate,
        chain_3 as chain,
        filterWithIndex_2 as filterWithIndex,
        uncons_2 as uncons,
        unsnoc_2 as unsnoc,
        snoc_2 as snoc,
        prependToAll_2 as prependToAll,
        fold_3 as fold,
        nonEmptyArray_2 as nonEmptyArray
    }
}
export { nonEmptyArray }

// @public @deprecated
const nonEmptyArray_2: Monad1<URI_3> & Comonad1<URI_3> & TraversableWithIndex1<URI_3, number> & FunctorWithIndex1<URI_3, number> & FoldableWithIndex1<URI_3, number> & Alt1<URI_3>;

// @public @deprecated
function not<A>(predicate: Predicate_2<A>): Predicate_2<A>;

// @public (undocumented)
const not_2: <A>(predicate: Predicate<A>) => Predicate<A>;

// @public (undocumented)
const not_3: <A, B extends A>(refinement: Refinement<A, B>) => Refinement<A, Exclude<A, B>>;

// @public
const now: IO<number>;

declare namespace number {
    export {
        isNumber,
        Eq_4 as Eq,
        Ord_4 as Ord,
        Bounded_2 as Bounded,
        Show_3 as Show,
        MagmaSub,
        SemigroupSum,
        SemigroupProduct,
        MonoidSum,
        MonoidProduct,
        Field_2 as Field
    }
}
export { number }

// @public (undocumented)
const of: <A>(a: A) => ReadonlyNonEmptyArray<A>;

// @public (undocumented)
const of_10: <R = unknown, A = never>(a: A) => Reader<R, A>;

// @public (undocumented)
const of_11: <R = unknown, E = never, A = never>(a: A) => ReaderEither<R, E, A>;

// @public (undocumented)
const of_12: <R = unknown, A = never>(a: A) => ReaderIO<R, A>;

// @public (undocumented)
function of_13<F extends URIS4>(F: Pointed4<F>): <A, R, S, FR, FE>(a: A) => Reader<R, Kind4<F, S, FR, FE, A>>;

// @public (undocumented)
function of_13<F extends URIS3>(F: Pointed3<F>): <A, R, FR, FE>(a: A) => Reader<R, Kind3<F, FR, FE, A>>;

// @public (undocumented)
function of_13<F extends URIS3, FE>(F: Pointed3C<F, FE>): <A, R, FR>(a: A) => Reader<R, Kind3<F, FR, FE, A>>;

// @public (undocumented)
function of_13<F extends URIS2>(F: Pointed2<F>): <A, R, FE>(a: A) => Reader<R, Kind2<F, FE, A>>;

// @public (undocumented)
function of_13<F extends URIS2, FE>(F: Pointed2C<F, FE>): <A, R>(a: A) => Reader<R, Kind2<F, FE, A>>;

// @public (undocumented)
function of_13<F extends URIS>(F: Pointed1<F>): <A, R>(a: A) => Reader<R, Kind<F, A>>;

// @public (undocumented)
function of_13<F>(F: Pointed<F>): <A, R>(a: A) => Reader<R, HKT<F, A>>;

// @public (undocumented)
const of_14: <R = unknown, A = never>(a: A) => ReaderTask<R, A>;

// @public (undocumented)
const of_15: <A>(a: A) => Task<A>;

// @public (undocumented)
const of_16: <E = never, A = never>(a: A) => TaskEither<E, A>;

// @public (undocumented)
const of_17: <R = unknown, E = never, A = never>(a: A) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const of_18: <A>(a: A) => ReadonlyArray<A>;

// @public (undocumented)
const of_19: <S, A>(a: A) => State<S, A>;

// @public (undocumented)
const of_2: <A>(a: A) => NonEmptyArray<A>;

// @public (undocumented)
const of_20: <S, R = unknown, E = never, A = never>(a: A) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
function of_21<F extends URIS3>(F: Pointed3<F>): <A, S, R, E>(a: A) => StateT3<F, S, R, E, A>;

// @public (undocumented)
function of_21<F extends URIS3, E>(F: Pointed3C<F, E>): <A, S, R>(a: A) => StateT3<F, S, R, E, A>;

// @public (undocumented)
function of_21<F extends URIS2>(F: Pointed2<F>): <A, S, E>(a: A) => StateT2<F, S, E, A>;

// @public (undocumented)
function of_21<F extends URIS2, E>(F: Pointed2C<F, E>): <A, S>(a: A) => StateT2<F, S, E, A>;

// @public (undocumented)
function of_21<F extends URIS>(F: Pointed1<F>): <A, S>(a: A) => StateT1<F, S, A>;

// @public (undocumented)
function of_21<F>(F: Pointed<F>): <A, S>(a: A) => StateT<F, S, A>;

// @public (undocumented)
const of_22: <A>(a: A) => TaskOption<A>;

// @public (undocumented)
const of_23: <E = never, A = never>(a: A) => TaskThese<E, A>;

// @public (undocumented)
const of_24: <E = never, A = never>(right: A) => These<E, A>;

// @public (undocumented)
const of_25: <A>(a: A) => Tree<A>;

// @public
const of_3: <A>(a: A) => Array<A>;

// @public (undocumented)
const of_4: <A>(a: A) => Option_2<A>;

// @public (undocumented)
const of_5: <E = never, A = never>(a: A) => Either<E, A>;

// @public (undocumented)
const of_6: <A>(a: A) => Identity<A>;

// @public (undocumented)
const of_7: <A>(a: A) => IO<A>;

// @public (undocumented)
const of_8: <E = never, A = never>(a: A) => IOEither<E, A>;

// @public (undocumented)
const of_9: <A>(a: A) => IOOption<A>;

declare namespace option {
    export {
        fromPredicate_2 as fromPredicate,
        elem_3 as elem,
        getRefinement,
        None,
        Some,
        Option_2 as Option,
        none,
        some,
        getLeft,
        getRight,
        URI_7 as URI,
        getShow_4 as getShow,
        getEq_4 as getEq,
        getOrd_2 as getOrd,
        getMonoid_3 as getMonoid,
        map_6 as map,
        Functor_6 as Functor,
        as,
        asUnit,
        of_4 as of,
        Pointed_5 as Pointed,
        ap_5 as ap,
        Apply_5 as Apply,
        Applicative_5 as Applicative,
        flatMap_4 as flatMap,
        Chain_4 as Chain,
        chainRec_2 as chainRec,
        ChainRec,
        Monad_4 as Monad,
        reduce_4 as reduce,
        foldMap_4 as foldMap,
        reduceRight_4 as reduceRight,
        Foldable_4 as Foldable,
        orElse,
        altW_4 as altW,
        alt_5 as alt,
        Alt_5 as Alt,
        zero_3 as zero,
        Zero_3 as Zero,
        guard_2 as guard,
        Alternative_3 as Alternative,
        extend_5 as extend,
        Extend_2 as Extend,
        compact_2 as compact,
        separate_2 as separate,
        Compactable_2 as Compactable,
        filter_4 as filter,
        filterMap_2 as filterMap,
        partition_2 as partition,
        partitionMap_2 as partitionMap,
        Filterable_2 as Filterable,
        traverse_4 as traverse,
        sequence_4 as sequence,
        Traversable_4 as Traversable,
        wither_2 as wither,
        wilt_2 as wilt,
        Witherable_2 as Witherable,
        throwError,
        MonadThrow,
        fromEither_3 as fromEither,
        FromEither,
        isSome,
        isNone,
        matchW_2 as matchW,
        foldW,
        match_2 as match,
        fold_5 as fold,
        getOrElseW,
        getOrElse,
        flap_5 as flap,
        apFirst_5 as apFirst,
        apSecond_5 as apSecond,
        flatten_4 as flatten,
        tap,
        tapEither,
        duplicate_4 as duplicate,
        fromEitherK,
        chainEitherK,
        chainFirstEitherK,
        fromNullable,
        tryCatch,
        tryCatchK,
        fromNullableK,
        chainNullableK,
        toNullable,
        toUndefined,
        exists,
        Do_3 as Do,
        bindTo_3 as bindTo,
        let__3 as let,
        bind_4 as bind,
        apS_4 as apS,
        ApT,
        do_ as do,
        traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex,
        traverseArrayWithIndex,
        traverseArray,
        sequenceArray,
        chain_4 as chain,
        chainFirst_5 as chainFirst,
        mapNullable,
        option_2 as option,
        getApplySemigroup_2 as getApplySemigroup,
        getApplyMonoid,
        getFirstMonoid,
        getLastMonoid
    }
}
export { option }

// @public (undocumented)
type Option_2<A> = None | Some<A>;

// @public @deprecated
const option_2: Monad1<URI_7> & Foldable1<URI_7> & Alternative1<URI_7> & Extend1<URI_7> & Witherable1<URI_7> & MonadThrow1<URI_7>;

// @public @deprecated (undocumented)
interface OptionM<M> extends ApplicativeCompositionHKT1<M, option.URI> {
    // (undocumented)
    readonly alt: <A>(fa: OptionT<M, A>, that: LazyArg<OptionT<M, A>>) => OptionT<M, A>;
    // (undocumented)
    readonly chain: <A, B>(ma: OptionT<M, A>, f: (a: A) => OptionT<M, B>) => OptionT<M, B>;
    // (undocumented)
    readonly fold: <A, R>(ma: OptionT<M, A>, onNone: LazyArg<HKT<M, R>>, onSome: (a: A) => HKT<M, R>) => HKT<M, R>;
    // (undocumented)
    readonly fromM: <A>(ma: HKT<M, A>) => OptionT<M, A>;
    // (undocumented)
    readonly getOrElse: <A>(ma: OptionT<M, A>, onNone: LazyArg<HKT<M, A>>) => HKT<M, A>;
    // (undocumented)
    readonly none: <A = never>() => OptionT<M, A>;
}

// @public @deprecated (undocumented)
interface OptionM1<M extends URIS> extends ApplicativeComposition11<M, option.URI> {
    // (undocumented)
    readonly alt: <A>(fa: OptionT1<M, A>, that: LazyArg<OptionT1<M, A>>) => OptionT1<M, A>;
    // (undocumented)
    readonly chain: <A, B>(ma: OptionT1<M, A>, f: (a: A) => OptionT1<M, B>) => OptionT1<M, B>;
    // (undocumented)
    readonly fold: <A, R>(ma: OptionT1<M, A>, onNone: LazyArg<Kind<M, R>>, onSome: (a: A) => Kind<M, R>) => Kind<M, R>;
    // (undocumented)
    readonly fromM: <A>(ma: Kind<M, A>) => OptionT1<M, A>;
    // (undocumented)
    readonly getOrElse: <A>(ma: OptionT1<M, A>, onNone: LazyArg<Kind<M, A>>) => Kind<M, A>;
    // (undocumented)
    readonly none: <A = never>() => OptionT1<M, A>;
}

// @public @deprecated (undocumented)
interface OptionM2<M extends URIS2> extends ApplicativeComposition21<M, option.URI> {
    // (undocumented)
    readonly alt: <E, A>(fa: OptionT2<M, E, A>, that: LazyArg<OptionT2<M, E, A>>) => OptionT2<M, E, A>;
    // (undocumented)
    readonly chain: <E, A, B>(ma: OptionT2<M, E, A>, f: (a: A) => OptionT2<M, E, B>) => OptionT2<M, E, B>;
    // (undocumented)
    readonly fold: <E, A, R>(ma: OptionT2<M, E, A>, onNone: LazyArg<Kind2<M, E, R>>, onSome: (a: A) => Kind2<M, E, R>) => Kind2<M, E, R>;
    // (undocumented)
    readonly fromM: <E, A>(ma: Kind2<M, E, A>) => OptionT2<M, E, A>;
    // (undocumented)
    readonly getOrElse: <E, A>(ma: OptionT2<M, E, A>, onNone: LazyArg<Kind2<M, E, A>>) => Kind2<M, E, A>;
    // (undocumented)
    readonly none: <E = never, A = never>() => OptionT2<M, E, A>;
}

// @public @deprecated (undocumented)
interface OptionM2C<M extends URIS2, E> extends ApplicativeComposition2C1<M, option.URI, E> {
    // (undocumented)
    readonly alt: <A>(fa: OptionT2<M, E, A>, that: LazyArg<OptionT2<M, E, A>>) => OptionT2<M, E, A>;
    // (undocumented)
    readonly chain: <A, B>(ma: OptionT2<M, E, A>, f: (a: A) => OptionT2<M, E, B>) => OptionT2<M, E, B>;
    // (undocumented)
    readonly fold: <A, R>(ma: OptionT2<M, E, A>, onNone: LazyArg<Kind2<M, E, R>>, onSome: (a: A) => Kind2<M, E, R>) => Kind2<M, E, R>;
    // (undocumented)
    readonly fromM: <A>(ma: Kind2<M, E, A>) => OptionT2<M, E, A>;
    // (undocumented)
    readonly getOrElse: <A>(ma: OptionT2<M, E, A>, onNone: LazyArg<Kind2<M, E, A>>) => Kind2<M, E, A>;
    // (undocumented)
    readonly none: <A = never>() => OptionT2<M, E, A>;
}

// @public @deprecated (undocumented)
interface OptionT<M, A> extends HKT<M, Option_2<A>> {
}

declare namespace optionT {
    export {
        some_4 as some,
        zero_5 as zero,
        fromF,
        fromNullable_5 as fromNullable,
        fromNullableK_5 as fromNullableK,
        chainNullableK_5 as chainNullableK,
        fromOptionK_6 as fromOptionK,
        chainOptionK_5 as chainOptionK,
        fromPredicate_7 as fromPredicate,
        fromEither_6 as fromEither,
        match_8 as match,
        matchE_4 as matchE,
        getOrElse_6 as getOrElse,
        map_16 as map,
        ap_12 as ap,
        chain_12 as chain,
        alt_11 as alt,
        getOptionM,
        OptionT,
        OptionM,
        OptionT1,
        OptionM1,
        OptionT2,
        OptionM2,
        OptionM2C
    }
}
export { optionT }

// @public @deprecated (undocumented)
type OptionT1<M extends URIS, A> = Kind<M, Option_2<A>>;

// @public @deprecated (undocumented)
type OptionT2<M extends URIS2, E, A> = Kind2<M, E, Option_2<A>>;

// @public (undocumented)
const or: <A>(second: Predicate<A>) => (first: Predicate<A>) => Predicate<A>;

// @public (undocumented)
const or_2: <A, C extends A>(second: Refinement<A, C>) => <B extends A>(first: Refinement<A, B>) => Refinement<A, C | B>;

// @public (undocumented)
interface Ord<A> extends Eq<A> {
    // (undocumented)
    readonly compare: (first: A, second: A) => Ordering;
}

declare namespace ord {
    export {
        Ord,
        equalsDefault,
        fromCompare,
        tuple_2 as tuple,
        reverse,
        contramap,
        URI,
        getSemigroup,
        getMonoid,
        Contravariant,
        trivial,
        equals,
        lt,
        gt,
        leq,
        geq,
        min_2 as min,
        max,
        clamp,
        between,
        getTupleOrd,
        getDualOrd,
        ord_2 as ord,
        ordBoolean,
        ordString,
        ordNumber,
        ordDate
    }
}
export { ord }

// @public (undocumented)
const Ord_2: ord.Ord<boolean>;

// @public @deprecated
const ord_2: Contravariant1<URI>;

// @public (undocumented)
const Ord_3: ord.Ord<Date>;

// @public (undocumented)
const Ord_4: ord.Ord<number>;

// @public (undocumented)
const Ord_5: ord.Ord<string>;

// @public @deprecated
const ordBoolean: Ord<boolean>;

// @public @deprecated
const ordDate: Ord<Date>;

// @public (undocumented)
type Ordering = -1 | 0 | 1;

declare namespace ordering {
    export {
        Ordering,
        matchW_7 as matchW,
        match_9 as match,
        reverse_10 as reverse,
        Eq_5 as Eq,
        Semigroup_2 as Semigroup,
        Monoid_2 as Monoid,
        sign,
        invert,
        semigroupOrdering,
        eqOrdering,
        monoidOrdering
    }
}
export { ordering }

// @public @deprecated
const ordNumber: Ord<number>;

// @public @deprecated
const ordString: Ord<string>;

// @public
const orElse: {
    <B>(that: LazyArg<Option_2<B>>): <A>(self: Option_2<A>) => Option_2<A | B>;
    <A, B>(self: Option_2<A>, that: LazyArg<Option_2<B>>): Option_2<A | B>;
};

// @public
const orElse_2: <E1, A, E2>(onLeft: (e: E1) => Either<E2, A>) => (ma: Either<E1, A>) => Either<E2, A>;

// @public (undocumented)
function orElse_3<M extends URIS3>(M: Monad3<M>): <E1, R, ME, E2, A>(onLeft: (e: E1) => Kind3<M, R, ME, Either<E2, A>>) => (ma: Kind3<M, R, ME, Either<E1, A>>) => Kind3<M, R, ME, Either<E2, A>>;

// @public (undocumented)
function orElse_3<M extends URIS3, ME>(M: Monad3C<M, ME>): <E1, R, E2, A>(onLeft: (e: E1) => Kind3<M, R, ME, Either<E2, A>>) => (ma: Kind3<M, R, ME, Either<E1, A>>) => Kind3<M, R, ME, Either<E2, A>>;

// @public (undocumented)
function orElse_3<M extends URIS2>(M: Monad2<M>): <E1, ME, E2, A>(onLeft: (e: E1) => Kind2<M, ME, Either<E2, A>>) => (ma: Kind2<M, ME, Either<E1, A>>) => Kind2<M, ME, Either<E2, A>>;

// @public (undocumented)
function orElse_3<M extends URIS2, ME>(M: Monad2C<M, ME>): <E1, E2, A>(onLeft: (e: E1) => Kind2<M, ME, Either<E2, A>>) => (ma: Kind2<M, ME, Either<E1, A>>) => Kind2<M, ME, Either<E2, A>>;

// @public (undocumented)
function orElse_3<M extends URIS>(M: Monad1<M>): <E1, E2, A>(onLeft: (e: E1) => Kind<M, Either<E2, A>>) => (ma: Kind<M, Either<E1, A>>) => Kind<M, Either<E2, A>>;

// @public (undocumented)
function orElse_3<M>(M: Monad_6<M>): <E1, E2, A>(onLeft: (e: E1) => HKT<M, Either<E2, A>>) => (ma: HKT<M, Either<E1, A>>) => HKT<M, Either<E2, A>>;

// @public (undocumented)
const orElse_4: <E1, A, E2>(onLeft: (e: E1) => IOEither<E2, A>) => (ma: IOEither<E1, A>) => IOEither<E2, A>;

// @public (undocumented)
const orElse_5: <E1, R, E2, A>(onLeft: (e: E1) => ReaderEither<R, E2, A>) => (ma: ReaderEither<R, E1, A>) => ReaderEither<R, E2, A>;

// @public (undocumented)
const orElse_6: <R, E1, A, E2>(onLeft: (e: E1) => ReaderTaskEither<R, E2, A>) => (ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2, A>;

// @public
const orElse_7: <E1, A, E2>(onLeft: (e: E1) => TaskEither<E2, A>) => (ma: TaskEither<E1, A>) => TaskEither<E2, A>;

// @public (undocumented)
function orElseFirst<M extends URIS3>(M: Monad3<M>): <E, R, ME, B>(onLeft: (e: E) => Kind3<M, R, ME, Either<E, B>>) => <A>(ma: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, A>>;

// @public (undocumented)
function orElseFirst<M extends URIS3, ME>(M: Monad3C<M, ME>): <E, R, B>(onLeft: (e: E) => Kind3<M, R, ME, Either<E, B>>) => <A>(ma: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, A>>;

// @public (undocumented)
function orElseFirst<M extends URIS2>(M: Monad2<M>): <E, ME, B>(onLeft: (e: E) => Kind2<M, ME, Either<E, B>>) => <A>(ma: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, A>>;

// @public (undocumented)
function orElseFirst<M extends URIS2, ME>(M: Monad2C<M, ME>): <E, B>(onLeft: (e: E) => Kind2<M, ME, Either<E, B>>) => <A>(ma: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, A>>;

// @public (undocumented)
function orElseFirst<M extends URIS>(M: Monad1<M>): <E, B>(onLeft: (e: E) => Kind<M, Either<E, B>>) => <A>(ma: Kind<M, Either<E, A>>) => Kind<M, Either<E, A>>;

// @public (undocumented)
function orElseFirst<M>(M: Monad_6<M>): <E, B>(onLeft: (e: E) => HKT<M, Either<E, B>>) => <A>(ma: HKT<M, Either<E, A>>) => HKT<M, Either<E, A>>;

// @public
const orElseFirst_2: <E, B>(onLeft: (e: E) => IOEither<E, B>) => <A>(ma: IOEither<E, A>) => IOEither<E, A>;

// @public
const orElseFirst_3: <E, R, B>(onLeft: (e: E) => ReaderEither<R, E, B>) => <A>(ma: ReaderEither<R, E, A>) => ReaderEither<R, E, A>;

// @public
const orElseFirst_4: <E, B>(onLeft: (e: E) => TaskEither<E, B>) => <A>(ma: TaskEither<E, A>) => TaskEither<E, A>;

// @public
const orElseFirst_5: <E, R, B>(onLeft: (e: E) => ReaderTaskEither<R, E, B>) => <A>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const orElseFirstIOK: <E, B>(onLeft: (e: E) => IO<B>) => <A>(ma: IOEither<E, A>) => IOEither<E, A>;

// @public (undocumented)
const orElseFirstIOK_2: <E, B>(onLeft: (e: E) => IO<B>) => <A>(ma: TaskEither<E, A>) => TaskEither<E, A>;

// @public (undocumented)
const orElseFirstTaskK: <E, B>(onLeft: (e: E) => Task<B>) => <A>(ma: TaskEither<E, A>) => TaskEither<E, A>;

// @public
const orElseFirstW: <E1, E2, B>(onLeft: (e: E1) => IOEither<E2, B>) => <A>(ma: IOEither<E1, A>) => IOEither<E1 | E2, A>;

// @public
const orElseFirstW_2: <E1, R2, E2, B>(onLeft: (e: E1) => ReaderEither<R2, E2, B>) => <R1, A>(ma: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E1 | E2, A>;

// @public
const orElseFirstW_3: <E1, E2, B>(onLeft: (e: E1) => TaskEither<E2, B>) => <A>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, A>;

// @public
const orElseFirstW_4: <E1, R2, E2, B>(onLeft: (e: E1) => ReaderTaskEither<R2, E2, B>) => <R1, A>(ma: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, A>;

// @public
const orElseW: <E1, E2, B>(onLeft: (e: E1) => Either<E2, B>) => <A>(ma: Either<E1, A>) => Either<E2, B | A>;

// @public
const orElseW_2: <E1, E2, B>(onLeft: (e: E1) => IOEither<E2, B>) => <A>(ma: IOEither<E1, A>) => IOEither<E2, A | B>;

// @public
const orElseW_3: <E1, R1, E2, B>(onLeft: (e: E1) => ReaderEither<R1, E2, B>) => <R2, A>(ma: ReaderEither<R2, E1, A>) => ReaderEither<R1 & R2, E2, A | B>;

// @public
const orElseW_4: <E1, R1, E2, B>(onLeft: (e: E1) => ReaderTaskEither<R1, E2, B>) => <R2, A>(ma: ReaderTaskEither<R2, E1, A>) => ReaderTaskEither<R1 & R2, E2, A | B>;

// @public
const orElseW_5: <E1, E2, B>(onLeft: (e: E1) => TaskEither<E2, B>) => <A>(ma: TaskEither<E1, A>) => TaskEither<E2, A | B>;

// @public (undocumented)
function orLeft<M extends URIS3>(M: Monad3<M>): <E1, R, ME, E2>(onLeft: (e: E1) => Kind3<M, R, ME, E2>) => <A>(fa: Kind3<M, R, ME, Either<E1, A>>) => Kind3<M, R, ME, Either<E2, A>>;

// @public (undocumented)
function orLeft<M extends URIS3, ME>(M: Monad3C<M, ME>): <E1, R, E2>(onLeft: (e: E1) => Kind3<M, R, ME, E2>) => <A>(fa: Kind3<M, R, ME, Either<E1, A>>) => Kind3<M, R, ME, Either<E2, A>>;

// @public (undocumented)
function orLeft<M extends URIS2>(M: Monad2<M>): <E1, ME, E2>(onLeft: (e: E1) => Kind2<M, ME, E2>) => <A>(fa: Kind2<M, ME, Either<E1, A>>) => Kind2<M, ME, Either<E2, A>>;

// @public (undocumented)
function orLeft<M extends URIS2, ME>(M: Monad2C<M, ME>): <E1, E2>(onLeft: (e: E1) => Kind2<M, ME, E2>) => <A>(fa: Kind2<M, ME, Either<E1, A>>) => Kind2<M, ME, Either<E2, A>>;

// @public (undocumented)
function orLeft<M extends URIS>(M: Monad1<M>): <E1, E2>(onLeft: (e: E1) => Kind<M, E2>) => <A>(fa: Kind<M, Either<E1, A>>) => Kind<M, Either<E2, A>>;

// @public (undocumented)
function orLeft<M>(M: Monad_6<M>): <E1, E2>(onLeft: (e: E1) => HKT<M, E2>) => <A>(fa: HKT<M, Either<E1, A>>) => HKT<M, Either<E2, A>>;

// @public (undocumented)
const orLeft_2: <E1, E2>(onLeft: (e: E1) => IO<E2>) => <A>(fa: IOEither<E1, A>) => IOEither<E2, A>;

// @public (undocumented)
const orLeft_3: <E1, R, E2>(onLeft: (e: E1) => Reader<R, E2>) => <A>(fa: ReaderEither<R, E1, A>) => ReaderEither<R, E2, A>;

// @public (undocumented)
const orLeft_4: <E1, R, E2>(onLeft: (e: E1) => ReaderTask<R, E2>) => <A>(fa: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2, A>;

// @public (undocumented)
const orLeft_5: <E1, E2>(onLeft: (e: E1) => Task<E2>) => <A>(fa: TaskEither<E1, A>) => TaskEither<E2, A>;

// @public
const parse: (s: string) => Either<unknown, Json_2>;

// @public @deprecated
function parseJSON<E>(s: string, onError: (reason: unknown) => E): Either<E, Json>;

// @public (undocumented)
interface Partition<F> {
    // (undocumented)
    <A, B extends A>(fa: HKT<F, A>, refinement: Refinement<A, B>): Separated<HKT<F, A>, HKT<F, B>>;
    // (undocumented)
    <A>(fa: HKT<F, A>, predicate: Predicate<A>): Separated<HKT<F, A>, HKT<F, A>>;
}

// @public
const partition: {
    <A, B extends A>(refinement: Refinement<A, B>): (as: Array<A>) => Separated<Array<A>, Array<B>>;
    <A>(predicate: Predicate<A>): <B extends A>(bs: Array<B>) => Separated<Array<B>, Array<B>>;
    <A>(predicate: Predicate<A>): (as: Array<A>) => Separated<Array<A>, Array<A>>;
};

// @public (undocumented)
interface Partition1<F extends URIS> {
    // (undocumented)
    <A, B extends A>(fa: Kind<F, A>, refinement: Refinement<A, B>): Separated<Kind<F, A>, Kind<F, B>>;
    // (undocumented)
    <A>(fa: Kind<F, A>, predicate: Predicate<A>): Separated<Kind<F, A>, Kind<F, A>>;
}

// @public (undocumented)
interface Partition2<F extends URIS2> {
    // (undocumented)
    <E, A, B extends A>(fa: Kind2<F, E, A>, refinement: Refinement<A, B>): Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
    // (undocumented)
    <E, A>(fa: Kind2<F, E, A>, predicate: Predicate<A>): Separated<Kind2<F, E, A>, Kind2<F, E, A>>;
}

// @public (undocumented)
interface Partition2C<F extends URIS2, E> {
    // (undocumented)
    <A, B extends A>(fa: Kind2<F, E, A>, refinement: Refinement<A, B>): Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
    // (undocumented)
    <A>(fa: Kind2<F, E, A>, predicate: Predicate<A>): Separated<Kind2<F, E, A>, Kind2<F, E, A>>;
}

// @public (undocumented)
interface Partition3<F extends URIS3> {
    // (undocumented)
    <R, E, A, B extends A>(fa: Kind3<F, R, E, A>, refinement: Refinement<A, B>): Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
    // (undocumented)
    <R, E, A>(fa: Kind3<F, R, E, A>, predicate: Predicate<A>): Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>;
}

// @public (undocumented)
interface Partition3C<F extends URIS3, E> {
    // (undocumented)
    <R, A, B extends A>(fa: Kind3<F, R, E, A>, refinement: Refinement<A, B>): Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
    // (undocumented)
    <R, A>(fa: Kind3<F, R, E, A>, predicate: Predicate<A>): Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>;
}

// @public (undocumented)
interface Partition4<F extends URIS4> {
    // (undocumented)
    <S, R, E, A, B extends A>(fa: Kind4<F, S, R, E, A>, refinement: Refinement<A, B>): Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, B>>;
    // (undocumented)
    <S, R, E, A>(fa: Kind4<F, S, R, E, A>, predicate: Predicate<A>): Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, A>>;
}

// @public (undocumented)
function partition_10<A, B extends A>(refinement: Refinement<A, B>): (set: ReadonlySet<A>) => Separated<ReadonlySet<A>, ReadonlySet<B>>;

// @public (undocumented)
function partition_10<A>(predicate: Predicate<A>): <B extends A>(set: ReadonlySet<B>) => Separated<ReadonlySet<B>, ReadonlySet<B>>;

// @public (undocumented)
function partition_10<A>(predicate: Predicate<A>): (set: ReadonlySet<A>) => Separated<ReadonlySet<A>, ReadonlySet<A>>;

// @public
const partition_11: {
    <A, B extends A>(refinement: Refinement<A, B>): (fa: Record<string, A>) => Separated<Record<string, A>, Record<string, B>>;
    <A>(predicate: Predicate<A>): <B extends A>(fb: Record<string, B>) => Separated<Record<string, B>, Record<string, B>>;
    <A>(predicate: Predicate<A>): (fa: Record<string, A>) => Separated<Record<string, A>, Record<string, A>>;
};

// @public (undocumented)
function partition_12<A, B extends A>(refinement: Refinement<A, B>): (set: Set<A>) => Separated<Set<A>, Set<B>>;

// @public (undocumented)
function partition_12<A>(predicate: Predicate<A>): <B extends A>(set: Set<B>) => Separated<Set<B>, Set<B>>;

// @public (undocumented)
function partition_12<A>(predicate: Predicate<A>): (set: Set<A>) => Separated<Set<A>, Set<A>>;

// @public (undocumented)
const partition_13: {
    <A, B extends A>(refinement: Refinement<A, B>): (fb: TaskOption<A>) => Separated<TaskOption<A>, TaskOption<B>>;
    <A>(predicate: Predicate<A>): <B extends A>(fb: TaskOption<B>) => Separated<TaskOption<B>, TaskOption<B>>;
    <A>(predicate: Predicate<A>): (fa: TaskOption<A>) => Separated<TaskOption<A>, TaskOption<A>>;
};

// @public (undocumented)
const partition_2: {
    <A, B extends A>(refinement: Refinement<A, B>): (fa: Option_2<A>) => Separated<Option_2<A>, Option_2<B>>;
    <A>(predicate: Predicate<A>): <B extends A>(fb: Option_2<B>) => Separated<Option_2<B>, Option_2<B>>;
    <A>(predicate: Predicate<A>): (fa: Option_2<A>) => Separated<Option_2<A>, Option_2<A>>;
};

// @public
function partition_3<F extends URIS2, G extends URIS2, E>(F: Functor2<F>, G: Filterable2C<G, E>): {
    <A, B extends A>(refinement: Refinement<A, B>): <R>(fga: Kind2<F, R, Kind2<G, E, A>>) => Separated<Kind2<F, R, Kind2<G, E, A>>, Kind2<F, R, Kind2<G, E, B>>>;
    <A>(predicate: Predicate<A>): <R, B extends A>(fgb: Kind2<F, R, Kind2<G, E, B>>) => Separated<Kind2<F, R, Kind2<G, E, B>>, Kind2<F, R, Kind2<G, E, B>>>;
    <A>(predicate: Predicate<A>): <R>(fga: Kind2<F, R, Kind2<G, E, A>>) => Separated<Kind2<F, R, Kind2<G, E, A>>, Kind2<F, R, Kind2<G, E, A>>>;
};

// @public (undocumented)
function partition_3<F extends URIS, G extends URIS2, E>(F: Functor1<F>, G: Filterable2C<G, E>): {
    <A, B extends A>(refinement: Refinement<A, B>): (fga: Kind<F, Kind2<G, E, A>>) => Separated<Kind<F, Kind2<G, E, A>>, Kind<F, Kind2<G, E, B>>>;
    <A>(predicate: Predicate<A>): <B extends A>(fgb: Kind<F, Kind2<G, E, B>>) => Separated<Kind<F, Kind2<G, E, B>>, Kind<F, Kind2<G, E, B>>>;
    <A>(predicate: Predicate<A>): (fga: Kind<F, Kind2<G, E, A>>) => Separated<Kind<F, Kind2<G, E, A>>, Kind<F, Kind2<G, E, A>>>;
};

// @public (undocumented)
function partition_3<F extends URIS, G extends URIS>(F: Functor1<F>, G: Filterable1<G>): {
    <A, B extends A>(refinement: Refinement<A, B>): (fga: Kind<F, Kind<G, A>>) => Separated<Kind<F, Kind<G, A>>, Kind<F, Kind<G, B>>>;
    <A>(predicate: Predicate<A>): <B extends A>(fgb: Kind<F, Kind<G, B>>) => Separated<Kind<F, Kind<G, B>>, Kind<F, Kind<G, B>>>;
    <A>(predicate: Predicate<A>): (fga: Kind<F, Kind<G, A>>) => Separated<Kind<F, Kind<G, A>>, Kind<F, Kind<G, A>>>;
};

// @public (undocumented)
function partition_3<F, G>(F: Functor<F>, G: Filterable_3<G>): {
    <A, B extends A>(refinement: Refinement<A, B>): (fga: HKT<F, HKT<G, A>>) => Separated<HKT<F, HKT<G, A>>, HKT<F, HKT<G, B>>>;
    <A>(predicate: Predicate<A>): <B extends A>(fgb: HKT<F, HKT<G, B>>) => Separated<HKT<F, HKT<G, B>>, HKT<F, HKT<G, B>>>;
    <A>(predicate: Predicate<A>): (fga: HKT<F, HKT<G, A>>) => Separated<HKT<F, HKT<G, A>>, HKT<F, HKT<G, A>>>;
};

// @public (undocumented)
const partition_4: {
    <A, B extends A>(refinement: Refinement<A, B>): (fb: IOOption<A>) => Separated<IOOption<A>, IOOption<B>>;
    <A>(predicate: Predicate<A>): <B extends A>(fb: IOOption<B>) => Separated<IOOption<B>, IOOption<B>>;
    <A>(predicate: Predicate<A>): (fa: IOOption<A>) => Separated<IOOption<A>, IOOption<A>>;
};

// @public (undocumented)
const partition_5: {
    <A, B extends A>(refinement: Refinement<A, B>): <K>(fa: Map<K, A>) => Separated<Map<K, A>, Map<K, B>>;
    <A>(predicate: Predicate<A>): <K, B extends A>(fb: Map<K, B>) => Separated<Map<K, B>, Map<K, B>>;
    <A>(predicate: Predicate<A>): <K>(fa: Map<K, A>) => Separated<Map<K, A>, Map<K, A>>;
};

// @public
function partition_6<F extends URIS4>(F: Filterable4<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, B>>;
    <A>(predicate: Predicate<A>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, A>>;
};

// @public (undocumented)
function partition_6<F extends URIS3>(F: Filterable3<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
    <A>(predicate: Predicate<A>): <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>;
};

// @public (undocumented)
function partition_6<F extends URIS3, E>(F: Filterable3C<F, E>): {
    <A, B extends A>(refinement: Refinement<A, B>): <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
    <A>(predicate: Predicate<A>): <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>;
};

// @public (undocumented)
function partition_6<F extends URIS2>(F: Filterable2<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
    <A>(predicate: Predicate<A>): <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>;
};

// @public (undocumented)
function partition_6<F extends URIS2, E>(F: Filterable2C<F, E>): {
    <A, B extends A>(refinement: Refinement<A, B>): (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
    <A>(predicate: Predicate<A>): (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>;
};

// @public (undocumented)
function partition_6<F extends URIS>(F: Filterable1<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, B>>;
    <A>(predicate: Predicate<A>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, A>>;
};

// @public (undocumented)
function partition_6<F>(F: Filterable_3<F>): {
    <A, B extends A>(refinement: Refinement<A, B>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, B>>;
    <A>(predicate: Predicate<A>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, A>>;
};

// @public (undocumented)
const partition_7: {
    <A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => Separated<ReadonlyArray<A>, ReadonlyArray<B>>;
    <A>(predicate: Predicate<A>): <B extends A>(bs: ReadonlyArray<B>) => Separated<ReadonlyArray<B>, ReadonlyArray<B>>;
    <A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Separated<ReadonlyArray<A>, ReadonlyArray<A>>;
};

// @public (undocumented)
const partition_8: {
    <A, B extends A>(refinement: Refinement<A, B>): <K>(fa: ReadonlyMap<K, A>) => Separated<ReadonlyMap<K, A>, ReadonlyMap<K, B>>;
    <A>(predicate: Predicate<A>): <K, B extends A>(fb: ReadonlyMap<K, B>) => Separated<ReadonlyMap<K, B>, ReadonlyMap<K, B>>;
    <A>(predicate: Predicate<A>): <K>(fa: ReadonlyMap<K, A>) => Separated<ReadonlyMap<K, A>, ReadonlyMap<K, A>>;
};

// @public
const partition_9: {
    <A, B extends A>(refinement: Refinement<A, B>): (fa: ReadonlyRecord<string, A>) => Separated<ReadonlyRecord<string, A>, ReadonlyRecord<string, B>>;
    <A>(predicate: Predicate<A>): <B extends A>(fb: ReadonlyRecord<string, B>) => Separated<ReadonlyRecord<string, B>, ReadonlyRecord<string, B>>;
    <A>(predicate: Predicate<A>): (fa: ReadonlyRecord<string, A>) => Separated<ReadonlyRecord<string, A>, ReadonlyRecord<string, A>>;
};

// @public
const partitionMap: <A, B, C>(f: (a: A) => Either<B, C>) => (fa: Array<A>) => Separated<Array<B>, Array<C>>;

// @public (undocumented)
function partitionMap_10<B, C>(EB: Eq<B>, EC: Eq<C>): <A>(f: (a: A) => Either<B, C>) => (set: ReadonlySet<A>) => Separated<ReadonlySet<B>, ReadonlySet<C>>;

// @public
const partitionMap_11: <A, B, C>(f: (a: A) => Either<B, C>) => (fa: Record<string, A>) => Separated<Record<string, B>, Record<string, C>>;

// @public (undocumented)
function partitionMap_12<B, C>(EB: Eq<B>, EC: Eq<C>): <A>(f: (a: A) => Either<B, C>) => (set: Set<A>) => Separated<Set<B>, Set<C>>;

// @public (undocumented)
const partitionMap_13: <A, B, C>(f: (a: A) => Either<B, C>) => (fa: TaskOption<A>) => Separated<TaskOption<B>, TaskOption<C>>;

// @public (undocumented)
const partitionMap_2: <A, B, C>(f: (a: A) => Either<B, C>) => (fa: Option_2<A>) => Separated<Option_2<B>, Option_2<C>>;

// @public
function partitionMap_3<F extends URIS2, G extends URIS2, E>(F: Functor2<F>, G: Filterable2C<G, E>): <A, B, C>(f: (a: A) => Either<B, C>) => <FE>(fa: Kind2<F, FE, Kind2<G, E, A>>) => Separated<Kind2<F, FE, Kind2<G, E, B>>, Kind2<F, FE, Kind2<G, E, C>>>;

// @public (undocumented)
function partitionMap_3<F extends URIS, G extends URIS2, E>(F: Functor1<F>, G: Filterable2C<G, E>): <A, B, C>(f: (a: A) => Either<B, C>) => (fa: Kind<F, Kind2<G, E, A>>) => Separated<Kind<F, Kind2<G, E, B>>, Kind<F, Kind2<G, E, C>>>;

// @public (undocumented)
function partitionMap_3<F extends URIS, G extends URIS>(F: Functor1<F>, G: Filterable1<G>): <A, B, C>(f: (a: A) => Either<B, C>) => (fa: Kind<F, Kind<G, A>>) => Separated<Kind<F, Kind<G, B>>, Kind<F, Kind<G, C>>>;

// @public (undocumented)
function partitionMap_3<F, G>(F: Functor<F>, G: Filterable_3<G>): <A, B, C>(f: (a: A) => Either<B, C>) => (fa: HKT<F, HKT<G, A>>) => Separated<HKT<F, HKT<G, B>>, HKT<F, HKT<G, C>>>;

// @public (undocumented)
const partitionMap_4: <A, B, C>(f: (a: A) => Either<B, C>) => (fa: IOOption<A>) => Separated<IOOption<B>, IOOption<C>>;

// @public (undocumented)
const partitionMap_5: <A, B, C>(f: (a: A) => Either<B, C>) => <K>(fa: Map<K, A>) => Separated<Map<K, B>, Map<K, C>>;

// @public
function partitionMap_6<F extends URIS4>(F: Filterable4<F>): <A, B, C>(f: (a: A) => Either<B, C>) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, B>, Kind4<F, S, R, E, C>>;

// @public (undocumented)
function partitionMap_6<F extends URIS3>(F: Filterable3<F>): <A, B, C>(f: (a: A) => Either<B, C>) => <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>;

// @public (undocumented)
function partitionMap_6<F extends URIS3, E>(F: Filterable3C<F, E>): <A, B, C>(f: (a: A) => Either<B, C>) => <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>;

// @public (undocumented)
function partitionMap_6<F extends URIS2>(F: Filterable2<F>): <A, B, C>(f: (a: A) => Either<B, C>) => <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>;

// @public (undocumented)
function partitionMap_6<F extends URIS2, E>(F: Filterable2C<F, E>): <A, B, C>(f: (a: A) => Either<B, C>) => (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>;

// @public (undocumented)
function partitionMap_6<F extends URIS>(F: Filterable1<F>): <A, B, C>(f: (a: A) => Either<B, C>) => (fa: Kind<F, A>) => Separated<Kind<F, B>, Kind<F, C>>;

// @public (undocumented)
function partitionMap_6<F>(F: Filterable_3<F>): <A, B, C>(f: (a: A) => Either<B, C>) => (fa: HKT<F, A>) => Separated<HKT<F, B>, HKT<F, C>>;

// @public (undocumented)
const partitionMap_7: <A, B, C>(f: (a: A) => Either<B, C>) => (fa: ReadonlyArray<A>) => Separated<ReadonlyArray<B>, ReadonlyArray<C>>;

// @public (undocumented)
const partitionMap_8: <A, B, C>(f: (a: A) => Either<B, C>) => <K>(fa: ReadonlyMap<K, A>) => Separated<ReadonlyMap<K, B>, ReadonlyMap<K, C>>;

// @public
const partitionMap_9: <A, B, C>(f: (a: A) => Either<B, C>) => (fa: ReadonlyRecord<string, A>) => Separated<ReadonlyRecord<string, B>, ReadonlyRecord<string, C>>;

// @public
const partitionMapWithIndex: <A, B, C>(f: (i: number, a: A) => Either<B, C>) => (fa: A[]) => Separated<B[], C[]>;

// @public (undocumented)
const partitionMapWithIndex_2: <K, A, B, C>(f: (k: K, a: A) => Either<B, C>) => (fa: Map<K, A>) => Separated<Map<K, B>, Map<K, C>>;

// @public
function partitionMapWithIndex_3<F extends URIS4, I>(F: FilterableWithIndex4<F, I>): <A, B, C>(f: (i: I, a: A) => Either<B, C>) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, B>, Kind4<F, S, R, E, C>>;

// @public (undocumented)
function partitionMapWithIndex_3<F extends URIS3, I>(F: FilterableWithIndex3<F, I>): <A, B, C>(f: (i: I, a: A) => Either<B, C>) => <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>;

// @public (undocumented)
function partitionMapWithIndex_3<F extends URIS3, I, E>(F: FilterableWithIndex3C<F, I, E>): <A, B, C>(f: (i: I, a: A) => Either<B, C>) => <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>;

// @public (undocumented)
function partitionMapWithIndex_3<F extends URIS2, I>(F: FilterableWithIndex2<F, I>): <A, B, C>(f: (i: I, a: A) => Either<B, C>) => <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>;

// @public (undocumented)
function partitionMapWithIndex_3<F extends URIS2, I, E>(F: FilterableWithIndex2C<F, I, E>): <A, B, C>(f: (i: I, a: A) => Either<B, C>) => (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>;

// @public (undocumented)
function partitionMapWithIndex_3<F extends URIS, I>(F: FilterableWithIndex1<F, I>): <A, B, C>(f: (i: I, a: A) => Either<B, C>) => (fa: Kind<F, A>) => Separated<Kind<F, B>, Kind<F, C>>;

// @public (undocumented)
function partitionMapWithIndex_3<F, I>(F: FilterableWithIndex_2<F, I>): <A, B, C>(f: (i: I, a: A) => Either<B, C>) => (fa: HKT<F, A>) => Separated<HKT<F, B>, HKT<F, C>>;

// @public (undocumented)
const partitionMapWithIndex_4: <A, B, C>(f: (i: number, a: A) => Either<B, C>) => (fa: readonly A[]) => Separated<readonly B[], readonly C[]>;

// @public (undocumented)
const partitionMapWithIndex_5: <K, A, B, C>(f: (k: K, a: A) => Either<B, C>) => (fa: ReadonlyMap<K, A>) => Separated<ReadonlyMap<K, B>, ReadonlyMap<K, C>>;

// @public
function partitionMapWithIndex_6<K extends string, A, B, C>(f: (key: K, a: A) => Either<B, C>): (fa: ReadonlyRecord<K, A>) => Separated<ReadonlyRecord<string, B>, ReadonlyRecord<string, C>>;

// @public
const partitionMapWithIndex_7: <K extends string, A, B, C>(f: (key: K, a: A) => Either<B, C>) => (fa: Record<K, A>) => Separated<Record<string, B>, Record<string, C>>;

// @public (undocumented)
interface PartitionWithIndex<F, I> {
    // (undocumented)
    <A, B extends A>(fa: HKT<F, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Separated<HKT<F, A>, HKT<F, B>>;
    // (undocumented)
    <A>(fa: HKT<F, A>, predicateWithIndex: PredicateWithIndex<I, A>): Separated<HKT<F, A>, HKT<F, A>>;
}

// @public
const partitionWithIndex: {
    <A, B extends A>(refinementWithIndex: RefinementWithIndex<number, A, B>): (as: Array<A>) => Separated<Array<A>, Array<B>>;
    <A>(predicateWithIndex: PredicateWithIndex<number, A>): <B extends A>(bs: Array<B>) => Separated<Array<B>, Array<B>>;
    <A>(predicateWithIndex: PredicateWithIndex<number, A>): (as: Array<A>) => Separated<Array<A>, Array<A>>;
};

// @public (undocumented)
interface PartitionWithIndex1<F extends URIS, I> {
    // (undocumented)
    <A, B extends A>(fa: Kind<F, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Separated<Kind<F, A>, Kind<F, B>>;
    // (undocumented)
    <A>(fa: Kind<F, A>, predicateWithIndex: PredicateWithIndex<I, A>): Separated<Kind<F, A>, Kind<F, A>>;
}

// @public (undocumented)
interface PartitionWithIndex2<F extends URIS2, I> {
    // (undocumented)
    <E, A, B extends A>(fa: Kind2<F, E, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
    // (undocumented)
    <E, A>(fa: Kind2<F, E, A>, predicateWithIndex: PredicateWithIndex<I, A>): Separated<Kind2<F, E, A>, Kind2<F, E, A>>;
}

// @public (undocumented)
interface PartitionWithIndex2C<F extends URIS2, I, E> {
    // (undocumented)
    <A, B extends A>(fa: Kind2<F, E, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
    // (undocumented)
    <A>(fa: Kind2<F, E, A>, predicateWithIndex: PredicateWithIndex<I, A>): Separated<Kind2<F, E, A>, Kind2<F, E, A>>;
}

// @public (undocumented)
interface PartitionWithIndex3<F extends URIS3, I> {
    // (undocumented)
    <R, E, A, B extends A>(fa: Kind3<F, R, E, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
    // (undocumented)
    <R, E, A>(fa: Kind3<F, R, E, A>, predicateWithIndex: PredicateWithIndex<I, A>): Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>;
}

// @public (undocumented)
interface PartitionWithIndex3C<F extends URIS3, I, E> {
    // (undocumented)
    <R, A, B extends A>(fa: Kind3<F, R, E, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
    // (undocumented)
    <R, A>(fa: Kind3<F, R, E, A>, predicateWithIndex: PredicateWithIndex<I, A>): Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>;
}

// @public (undocumented)
interface PartitionWithIndex4<F extends URIS4, I> {
    // (undocumented)
    <S, R, E, A, B extends A>(fa: Kind4<F, S, R, E, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, B>>;
    // (undocumented)
    <S, R, E, A>(fa: Kind4<F, S, R, E, A>, predicateWithIndex: PredicateWithIndex<I, A>): Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, A>>;
}

// @public (undocumented)
function partitionWithIndex_2<K, A, B extends A>(predicateWithIndex: (k: K, a: A) => a is B): (fa: Map<K, A>) => Separated<Map<K, A>, Map<K, B>>;

// @public (undocumented)
function partitionWithIndex_2<K, A>(predicateWithIndex: (k: K, a: A) => boolean): <B extends A>(fb: Map<K, B>) => Separated<Map<K, B>, Map<K, B>>;

// @public (undocumented)
function partitionWithIndex_2<K, A>(predicateWithIndex: (k: K, a: A) => boolean): (fa: Map<K, A>) => Separated<Map<K, A>, Map<K, A>>;

// @public
function partitionWithIndex_3<F extends URIS4, I>(F: FilterableWithIndex4<F, I>): {
    <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, B>>;
    <A>(predicate: PredicateWithIndex<I, A>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, A>>;
};

// @public (undocumented)
function partitionWithIndex_3<F extends URIS3, I>(F: FilterableWithIndex3<F, I>): {
    <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
    <A>(predicate: PredicateWithIndex<I, A>): <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>;
};

// @public (undocumented)
function partitionWithIndex_3<F extends URIS3, I, E>(F: FilterableWithIndex3C<F, I, E>): {
    <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
    <A>(predicate: PredicateWithIndex<I, A>): <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>;
};

// @public (undocumented)
function partitionWithIndex_3<F extends URIS2, I>(F: FilterableWithIndex2<F, I>): {
    <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
    <A>(predicate: PredicateWithIndex<I, A>): <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>;
};

// @public (undocumented)
function partitionWithIndex_3<F extends URIS2, I, E>(F: FilterableWithIndex2C<F, I, E>): {
    <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
    <A>(predicate: PredicateWithIndex<I, A>): (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>;
};

// @public (undocumented)
function partitionWithIndex_3<F extends URIS, I>(F: FilterableWithIndex1<F, I>): {
    <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, B>>;
    <A>(predicate: PredicateWithIndex<I, A>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, A>>;
};

// @public (undocumented)
function partitionWithIndex_3<F, I>(F: FilterableWithIndex_2<F, I>): {
    <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, B>>;
    <A>(predicate: PredicateWithIndex<I, A>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, A>>;
};

// @public (undocumented)
const partitionWithIndex_4: {
    <A, B extends A>(refinementWithIndex: RefinementWithIndex<number, A, B>): (as: ReadonlyArray<A>) => Separated<ReadonlyArray<A>, ReadonlyArray<B>>;
    <A>(predicateWithIndex: PredicateWithIndex<number, A>): <B extends A>(bs: ReadonlyArray<B>) => Separated<ReadonlyArray<B>, ReadonlyArray<B>>;
    <A>(predicateWithIndex: PredicateWithIndex<number, A>): (as: ReadonlyArray<A>) => Separated<ReadonlyArray<A>, ReadonlyArray<A>>;
};

// @public (undocumented)
function partitionWithIndex_5<K, A, B extends A>(predicateWithIndex: (k: K, a: A) => a is B): (m: ReadonlyMap<K, A>) => Separated<ReadonlyMap<K, A>, ReadonlyMap<K, B>>;

// @public (undocumented)
function partitionWithIndex_5<K, A>(predicateWithIndex: (k: K, a: A) => boolean): <B extends A>(m: ReadonlyMap<K, B>) => Separated<ReadonlyMap<K, B>, ReadonlyMap<K, B>>;

// @public (undocumented)
function partitionWithIndex_5<K, A>(predicateWithIndex: (k: K, a: A) => boolean): (m: ReadonlyMap<K, A>) => Separated<ReadonlyMap<K, A>, ReadonlyMap<K, A>>;

// @public
function partitionWithIndex_6<K extends string, A, B extends A>(refinementWithIndex: RefinementWithIndex<K, A, B>): (fa: ReadonlyRecord<K, A>) => Separated<ReadonlyRecord<string, A>, ReadonlyRecord<string, B>>;

// @public (undocumented)
function partitionWithIndex_6<K extends string, A>(predicateWithIndex: PredicateWithIndex<K, A>): <B extends A>(fb: ReadonlyRecord<K, B>) => Separated<ReadonlyRecord<string, B>, ReadonlyRecord<string, B>>;

// @public (undocumented)
function partitionWithIndex_6<K extends string, A>(predicateWithIndex: PredicateWithIndex<K, A>): (fa: ReadonlyRecord<K, A>) => Separated<ReadonlyRecord<string, A>, ReadonlyRecord<string, A>>;

// @public
function partitionWithIndex_7<K extends string, A, B extends A>(refinementWithIndex: RefinementWithIndex<K, A, B>): (fa: Record<K, A>) => Separated<Record<string, A>, Record<string, B>>;

// @public (undocumented)
function partitionWithIndex_7<K extends string, A>(predicateWithIndex: PredicateWithIndex<K, A>): <B extends A>(fb: Record<K, B>) => Separated<Record<string, B>, Record<string, B>>;

// @public (undocumented)
function partitionWithIndex_7<K extends string, A>(predicateWithIndex: PredicateWithIndex<K, A>): (fa: Record<K, A>) => Separated<Record<string, A>, Record<string, A>>;

// @public
const pass: <W, A>(fa: Writer<W, [A, (w: W) => W]>) => Writer<W, A>;

// @public
function peeks<S>(f: Endomorphism<S>): <A>(wa: Store<S, A>) => A;

// @public
function pipe<A>(a: A): A;

// @public (undocumented)
function pipe<A, B>(a: A, ab: (a: A) => B): B;

// @public (undocumented)
function pipe<A, B, C>(a: A, ab: (a: A) => B, bc: (b: B) => C): C;

// @public (undocumented)
function pipe<A, B, C, D>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D): D;

// @public (undocumented)
function pipe<A, B, C, D, E>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E): E;

// @public (undocumented)
function pipe<A, B, C, D, E, F>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F): F;

// @public (undocumented)
function pipe<A, B, C, D, E, F, G>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G): G;

// @public (undocumented)
function pipe<A, B, C, D, E, F, G, H>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H): H;

// @public (undocumented)
function pipe<A, B, C, D, E, F, G, H, I>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I): I;

// @public (undocumented)
function pipe<A, B, C, D, E, F, G, H, I, J>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J): J;

// @public (undocumented)
function pipe<A, B, C, D, E, F, G, H, I, J, K>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K): K;

// @public (undocumented)
function pipe<A, B, C, D, E, F, G, H, I, J, K, L>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L): L;

// @public (undocumented)
function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M): M;

// @public (undocumented)
function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N): N;

// @public (undocumented)
function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O): O;

// @public (undocumented)
function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P): P;

// @public (undocumented)
function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q): Q;

// @public (undocumented)
function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R): R;

// @public (undocumented)
function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R, rs: (r: R) => S): S;

// @public (undocumented)
function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R, rs: (r: R) => S, st: (s: S) => T): T;

// @public @deprecated
const pipe_2: typeof pipe;

declare namespace pipeable {
    export {
        map_17 as map,
        contramap_4 as contramap,
        mapWithIndex_6 as mapWithIndex,
        ap_13 as ap,
        chain_13 as chain,
        bimap_6 as bimap,
        mapLeft_6 as mapLeft,
        extend_8 as extend,
        reduce_9 as reduce,
        foldMap_9 as foldMap,
        reduceRight_9 as reduceRight,
        reduceWithIndex_6 as reduceWithIndex,
        foldMapWithIndex_6 as foldMapWithIndex,
        reduceRightWithIndex_6 as reduceRightWithIndex,
        alt_12 as alt,
        filter_8 as filter,
        filterMap_6 as filterMap,
        partition_6 as partition,
        partitionMap_6 as partitionMap,
        filterWithIndex_5 as filterWithIndex,
        filterMapWithIndex_3 as filterMapWithIndex,
        partitionWithIndex_3 as partitionWithIndex,
        partitionMapWithIndex_3 as partitionMapWithIndex,
        promap,
        compose,
        pipeable_2 as pipeable,
        PipeableFunctor,
        PipeableFunctor1,
        PipeableFunctor2,
        PipeableFunctor2C,
        PipeableFunctor3,
        PipeableFunctor3C,
        PipeableFunctor4,
        PipeableContravariant,
        PipeableContravariant1,
        PipeableContravariant2,
        PipeableContravariant2C,
        PipeableContravariant3,
        PipeableContravariant3C,
        PipeableContravariant4,
        PipeableFunctorWithIndex,
        PipeableFunctorWithIndex1,
        PipeableFunctorWithIndex2,
        PipeableFunctorWithIndex2C,
        PipeableFunctorWithIndex3,
        PipeableFunctorWithIndex3C,
        PipeableFunctorWithIndex4,
        PipeableApply,
        PipeableApply1,
        PipeableApply2,
        PipeableApply2C,
        PipeableApply3,
        PipeableApply3C,
        PipeableApply4,
        PipeableChain,
        PipeableChain1,
        PipeableChain2,
        PipeableChain2C,
        PipeableChain3,
        PipeableChain3C,
        PipeableChain4,
        PipeableExtend,
        PipeableExtend1,
        PipeableExtend2,
        PipeableExtend2C,
        PipeableExtend3,
        PipeableExtend3C,
        PipeableExtend4,
        PipeableBifunctor,
        PipeableBifunctor2,
        PipeableBifunctor3,
        PipeableBifunctor3C,
        PipeableBifunctor4,
        PipeableFoldable,
        PipeableFoldable1,
        PipeableFoldable2,
        PipeableFoldable2C,
        PipeableFoldable3,
        PipeableFoldable3C,
        PipeableFoldable4,
        PipeableFoldableWithIndex,
        PipeableFoldableWithIndex1,
        PipeableFoldableWithIndex2,
        PipeableFoldableWithIndex2C,
        PipeableFoldableWithIndex3,
        PipeableFoldableWithIndex3C,
        PipeableFoldableWithIndex4,
        PipeableAlt,
        PipeableAlt1,
        PipeableAlt2,
        PipeableAlt2C,
        PipeableAlt3,
        PipeableAlt3C,
        PipeableAlt4,
        PipeableCompactable,
        PipeableCompactable1,
        PipeableCompactable2,
        PipeableCompactable2C,
        PipeableCompactable3,
        PipeableCompactable3C,
        PipeableCompactable4,
        PipeableFilterable,
        PipeableFilterable1,
        PipeableFilterable2,
        PipeableFilterable2C,
        PipeableFilterable3,
        PipeableFilterable3C,
        PipeableFilterable4,
        PipeableFilterableWithIndex,
        PipeableFilterableWithIndex1,
        PipeableFilterableWithIndex2,
        PipeableFilterableWithIndex2C,
        PipeableFilterableWithIndex3,
        PipeableFilterableWithIndex3C,
        PipeableFilterableWithIndex4,
        PipeableProfunctor,
        PipeableProfunctor2,
        PipeableProfunctor2C,
        PipeableProfunctor3,
        PipeableProfunctor3C,
        PipeableProfunctor4,
        PipeableSemigroupoid,
        PipeableSemigroupoid2,
        PipeableSemigroupoid2C,
        PipeableSemigroupoid3,
        PipeableSemigroupoid3C,
        PipeableSemigroupoid4,
        PipeableMonadThrow,
        PipeableMonadThrow1,
        PipeableMonadThrow2,
        PipeableMonadThrow2C,
        PipeableMonadThrow3,
        PipeableMonadThrow3C,
        PipeableMonadThrow4,
        pipe_2 as pipe
    }
}
export { pipeable }

// @public @deprecated (undocumented)
function pipeable_2<F extends URIS4, I>(I: {
    readonly URI: F;
} & I): (I extends Chain4<F> ? PipeableChain4<F> : I extends Apply4<F> ? PipeableApply4<F> : I extends Functor4<F> ? PipeableFunctor4<F> : {}) & (I extends Contravariant4<F> ? PipeableContravariant4<F> : {}) & (I extends FunctorWithIndex4<F, infer Ix> ? PipeableFunctorWithIndex4<F, Ix> : {}) & (I extends Bifunctor4<F> ? PipeableBifunctor4<F> : {}) & (I extends Extend4<F> ? PipeableExtend4<F> : {}) & (I extends FoldableWithIndex4<F, infer Ix> ? PipeableFoldableWithIndex4<F, Ix> : I extends Foldable4<F> ? PipeableFoldable4<F> : {}) & (I extends Alt4<F> ? PipeableAlt4<F> : {}) & (I extends FilterableWithIndex4<F, infer Ix> ? PipeableFilterableWithIndex4<F, Ix> : I extends Filterable4<F> ? PipeableFilterable4<F> : I extends Compactable4<F> ? PipeableCompactable4<F> : {}) & (I extends Profunctor4<F> ? PipeableProfunctor4<F> : {}) & (I extends Semigroupoid4<F> ? PipeableSemigroupoid4<F> : {}) & (I extends MonadThrow4<F> ? PipeableMonadThrow4<F> : {});

// @public @deprecated (undocumented)
function pipeable_2<F extends URIS3, I>(I: {
    readonly URI: F;
} & I): (I extends Chain3<F> ? PipeableChain3<F> : I extends Apply3<F> ? PipeableApply3<F> : I extends Functor3<F> ? PipeableFunctor3<F> : {}) & (I extends Contravariant3<F> ? PipeableContravariant3<F> : {}) & (I extends FunctorWithIndex3<F, infer Ix> ? PipeableFunctorWithIndex3<F, Ix> : {}) & (I extends Bifunctor3<F> ? PipeableBifunctor3<F> : {}) & (I extends Extend3<F> ? PipeableExtend3<F> : {}) & (I extends FoldableWithIndex3<F, infer Ix> ? PipeableFoldableWithIndex3<F, Ix> : I extends Foldable3<F> ? PipeableFoldable3<F> : {}) & (I extends Alt3<F> ? PipeableAlt3<F> : {}) & (I extends FilterableWithIndex3<F, infer Ix> ? PipeableFilterableWithIndex3<F, Ix> : I extends Filterable3<F> ? PipeableFilterable3<F> : I extends Compactable3<F> ? PipeableCompactable3<F> : {}) & (I extends Profunctor3<F> ? PipeableProfunctor3<F> : {}) & (I extends Semigroupoid3<F> ? PipeableSemigroupoid3<F> : {}) & (I extends MonadThrow3<F> ? PipeableMonadThrow3<F> : {});

// @public @deprecated (undocumented)
function pipeable_2<F extends URIS3, I, E>(I: {
    readonly URI: F;
} & I): (I extends Chain3C<F, E> ? PipeableChain3C<F, E> : I extends Apply3C<F, E> ? PipeableApply3C<F, E> : I extends Functor3C<F, E> ? PipeableFunctor3C<F, E> : {}) & (I extends Contravariant3C<F, E> ? PipeableContravariant3C<F, E> : {}) & (I extends FunctorWithIndex3C<F, infer Ix, E> ? PipeableFunctorWithIndex3C<F, Ix, E> : {}) & (I extends Bifunctor3C<F, E> ? PipeableBifunctor3C<F, E> : {}) & (I extends Extend3C<F, E> ? PipeableExtend3C<F, E> : {}) & (I extends FoldableWithIndex3C<F, infer Ix, E> ? PipeableFoldableWithIndex3C<F, Ix, E> : I extends Foldable3C<F, E> ? PipeableFoldable3C<F, E> : {}) & (I extends Alt3C<F, E> ? PipeableAlt3C<F, E> : {}) & (I extends FilterableWithIndex3C<F, infer Ix, E> ? PipeableFilterableWithIndex3C<F, Ix, E> : I extends Filterable3C<F, E> ? PipeableFilterable3C<F, E> : I extends Compactable3C<F, E> ? PipeableCompactable3C<F, E> : {}) & (I extends Profunctor3C<F, E> ? PipeableProfunctor3C<F, E> : {}) & (I extends Semigroupoid3C<F, E> ? PipeableSemigroupoid3C<F, E> : {}) & (I extends MonadThrow3C<F, E> ? PipeableMonadThrow3C<F, E> : {});

// @public @deprecated (undocumented)
function pipeable_2<F extends URIS2, I, E>(I: {
    readonly URI: F;
    readonly _E: E;
} & I): (I extends Chain2C<F, E> ? PipeableChain2C<F, E> : I extends Apply2C<F, E> ? PipeableApply2C<F, E> : I extends Functor2C<F, E> ? PipeableFunctor2C<F, E> : {}) & (I extends Contravariant2C<F, E> ? PipeableContravariant2C<F, E> : {}) & (I extends FunctorWithIndex2C<F, infer Ix, E> ? PipeableFunctorWithIndex2C<F, Ix, E> : {}) & (I extends Extend2C<F, E> ? PipeableExtend2C<F, E> : {}) & (I extends FoldableWithIndex2C<F, infer Ix, E> ? PipeableFoldableWithIndex2C<F, Ix, E> : I extends Foldable2C<F, E> ? PipeableFoldable2C<F, E> : {}) & (I extends Alt2C<F, E> ? PipeableAlt2C<F, E> : {}) & (I extends FilterableWithIndex2C<F, infer Ix, E> ? PipeableFilterableWithIndex2C<F, Ix, E> : I extends Filterable2C<F, E> ? PipeableFilterable2C<F, E> : I extends Compactable2C<F, E> ? PipeableCompactable2C<F, E> : {}) & (I extends Profunctor2C<F, E> ? PipeableProfunctor2C<F, E> : {}) & (I extends Semigroupoid2C<F, E> ? PipeableSemigroupoid2C<F, E> : {}) & (I extends MonadThrow2C<F, E> ? PipeableMonadThrow2C<F, E> : {});

// @public @deprecated (undocumented)
function pipeable_2<F extends URIS2, I>(I: {
    readonly URI: F;
} & I): (I extends Chain2<F> ? PipeableChain2<F> : I extends Apply2<F> ? PipeableApply2<F> : I extends Functor2<F> ? PipeableFunctor2<F> : {}) & (I extends Contravariant2<F> ? PipeableContravariant2<F> : {}) & (I extends FunctorWithIndex2<F, infer Ix> ? PipeableFunctorWithIndex2<F, Ix> : {}) & (I extends Bifunctor2<F> ? PipeableBifunctor2<F> : {}) & (I extends Extend2<F> ? PipeableExtend2<F> : {}) & (I extends FoldableWithIndex2<F, infer Ix> ? PipeableFoldableWithIndex2<F, Ix> : I extends Foldable2<F> ? PipeableFoldable2<F> : {}) & (I extends Alt2<F> ? PipeableAlt2<F> : {}) & (I extends FilterableWithIndex2<F, infer Ix> ? PipeableFilterableWithIndex2<F, Ix> : I extends Filterable2<F> ? PipeableFilterable2<F> : I extends Compactable2<F> ? PipeableCompactable2<F> : {}) & (I extends Profunctor2<F> ? PipeableProfunctor2<F> : {}) & (I extends Semigroupoid2<F> ? PipeableSemigroupoid2<F> : {}) & (I extends MonadThrow2<F> ? PipeableMonadThrow2<F> : {});

// @public @deprecated (undocumented)
function pipeable_2<F extends URIS, I>(I: {
    readonly URI: F;
} & I): (I extends Chain1<F> ? PipeableChain1<F> : I extends Apply1<F> ? PipeableApply1<F> : I extends Functor1<F> ? PipeableFunctor1<F> : {}) & (I extends Contravariant1<F> ? PipeableContravariant1<F> : {}) & (I extends FunctorWithIndex1<F, infer Ix> ? PipeableFunctorWithIndex1<F, Ix> : {}) & (I extends Extend1<F> ? PipeableExtend1<F> : {}) & (I extends FoldableWithIndex1<F, infer Ix> ? PipeableFoldableWithIndex1<F, Ix> : I extends Foldable1<F> ? PipeableFoldable1<F> : {}) & (I extends Alt1<F> ? PipeableAlt1<F> : {}) & (I extends FilterableWithIndex1<F, infer Ix> ? PipeableFilterableWithIndex1<F, Ix> : I extends Filterable1<F> ? PipeableFilterable1<F> : I extends Compactable1<F> ? PipeableCompactable1<F> : {}) & (I extends MonadThrow1<F> ? PipeableMonadThrow1<F> : {});

// @public @deprecated (undocumented)
function pipeable_2<F, I>(I: {
    readonly URI: F;
} & I): (I extends Chain_5<F> ? PipeableChain<F> : I extends Apply<F> ? PipeableApply<F> : I extends Functor<F> ? PipeableFunctor<F> : {}) & (I extends Contravariant_4<F> ? PipeableContravariant<F> : {}) & (I extends FunctorWithIndex_4<F, infer Ix> ? PipeableFunctorWithIndex<F, Ix> : {}) & (I extends Bifunctor_3<F> ? PipeableBifunctor<F> : {}) & (I extends Extend_4<F> ? PipeableExtend<F> : {}) & (I extends FoldableWithIndex_4<F, infer Ix> ? PipeableFoldableWithIndex<F, Ix> : I extends Foldable_6<F> ? PipeableFoldable<F> : {}) & (I extends Alt<F> ? PipeableAlt<F> : {}) & (I extends FilterableWithIndex_2<F, infer Ix> ? PipeableFilterableWithIndex<F, Ix> : I extends Filterable_3<F> ? PipeableFilterable<F> : I extends Compactable_3<F> ? PipeableCompactable<F> : {}) & (I extends Profunctor<F> ? PipeableProfunctor<F> : {}) & (I extends Semigroupoid<F> ? PipeableSemigroupoid<F> : {}) & (I extends MonadThrow_5<F> ? PipeableMonadThrow<F> : {});

// @public @deprecated (undocumented)
interface PipeableAlt<F> {
    // (undocumented)
    readonly alt: <A>(that: LazyArg<HKT<F, A>>) => (fa: HKT<F, A>) => HKT<F, A>;
}

// @public @deprecated (undocumented)
interface PipeableAlt1<F extends URIS> {
    // (undocumented)
    readonly alt: <A>(that: LazyArg<Kind<F, A>>) => (fa: Kind<F, A>) => Kind<F, A>;
}

// @public @deprecated (undocumented)
interface PipeableAlt2<F extends URIS2> {
    // (undocumented)
    readonly alt: <E, A>(that: LazyArg<Kind2<F, E, A>>) => (fa: Kind2<F, E, A>) => Kind2<F, E, A>;
}

// @public @deprecated (undocumented)
interface PipeableAlt2C<F extends URIS2, E> {
    // (undocumented)
    readonly alt: <A>(that: LazyArg<Kind2<F, E, A>>) => (fa: Kind2<F, E, A>) => Kind2<F, E, A>;
}

// @public @deprecated (undocumented)
interface PipeableAlt3<F extends URIS3> {
    // (undocumented)
    readonly alt: <R, E, A>(that: LazyArg<Kind3<F, R, E, A>>) => (fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
}

// @public @deprecated (undocumented)
interface PipeableAlt3C<F extends URIS3, E> {
    // (undocumented)
    readonly alt: <R, A>(that: LazyArg<Kind3<F, R, E, A>>) => (fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
}

// @public @deprecated (undocumented)
interface PipeableAlt4<F extends URIS4> {
    // (undocumented)
    readonly alt: <S, R, E, A>(that: LazyArg<Kind4<F, S, R, E, A>>) => (fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>;
}

// @public @deprecated (undocumented)
interface PipeableApply<F> extends PipeableFunctor<F> {
    // (undocumented)
    readonly ap: <A>(fa: HKT<F, A>) => <B>(fab: HKT<F, (a: A) => B>) => HKT<F, B>;
    // (undocumented)
    readonly apFirst: <B>(fb: HKT<F, B>) => <A>(fa: HKT<F, A>) => HKT<F, A>;
    // (undocumented)
    readonly apSecond: <B>(fb: HKT<F, B>) => <A>(fa: HKT<F, A>) => HKT<F, B>;
}

// @public @deprecated (undocumented)
interface PipeableApply1<F extends URIS> extends PipeableFunctor1<F> {
    // (undocumented)
    readonly ap: <A>(fa: Kind<F, A>) => <B>(fab: Kind<F, (a: A) => B>) => Kind<F, B>;
    // (undocumented)
    readonly apFirst: <B>(fb: Kind<F, B>) => <A>(fa: Kind<F, A>) => Kind<F, A>;
    // (undocumented)
    readonly apSecond: <B>(fb: Kind<F, B>) => <A>(fa: Kind<F, A>) => Kind<F, B>;
}

// @public @deprecated (undocumented)
interface PipeableApply2<F extends URIS2> extends PipeableFunctor2<F> {
    // (undocumented)
    readonly ap: <E, A>(fa: Kind2<F, E, A>) => <B>(fab: Kind2<F, E, (a: A) => B>) => Kind2<F, E, B>;
    // (undocumented)
    readonly apFirst: <E, B>(fb: Kind2<F, E, B>) => <A>(fa: Kind2<F, E, A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly apSecond: <E, B>(fb: Kind2<F, E, B>) => <A>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableApply2C<F extends URIS2, E> extends PipeableFunctor2C<F, E> {
    // (undocumented)
    readonly ap: <A>(fa: Kind2<F, E, A>) => <B>(fab: Kind2<F, E, (a: A) => B>) => Kind2<F, E, B>;
    // (undocumented)
    readonly apFirst: <B>(fb: Kind2<F, E, B>) => <A>(fa: Kind2<F, E, A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly apSecond: <B>(fb: Kind2<F, E, B>) => <A>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableApply3<F extends URIS3> extends PipeableFunctor3<F> {
    // (undocumented)
    readonly ap: <R, E, A>(fa: Kind3<F, R, E, A>) => <B>(fab: Kind3<F, R, E, (a: A) => B>) => Kind3<F, R, E, B>;
    // (undocumented)
    readonly apFirst: <R, E, B>(fb: Kind3<F, R, E, B>) => <A>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly apSecond: <R, E, B>(fb: Kind3<F, R, E, B>) => <A>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableApply3C<F extends URIS3, E> extends PipeableFunctor3C<F, E> {
    // (undocumented)
    readonly ap: <R, A>(fa: Kind3<F, R, E, A>) => <B>(fab: Kind3<F, R, E, (a: A) => B>) => Kind3<F, R, E, B>;
    // (undocumented)
    readonly apFirst: <R, B>(fb: Kind3<F, R, E, B>) => <A>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly apSecond: <R, B>(fb: Kind3<F, R, E, B>) => <A>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableApply4<F extends URIS4> extends PipeableFunctor4<F> {
    // (undocumented)
    readonly ap: <S, R, E, A>(fa: Kind4<F, S, R, E, A>) => <B>(fab: Kind4<F, S, R, E, (a: A) => B>) => Kind4<F, S, R, E, B>;
    // (undocumented)
    readonly apFirst: <S, R, E, B>(fb: Kind4<F, S, R, E, B>) => <A>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly apSecond: <S, R, E, B>(fb: Kind4<F, S, R, E, B>) => <A>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableBifunctor<F> {
    // (undocumented)
    readonly bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: HKT2<F, E, A>) => HKT2<F, G, B>;
    // (undocumented)
    readonly mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: HKT2<F, E, A>) => HKT2<F, G, A>;
}

// @public @deprecated (undocumented)
interface PipeableBifunctor2<F extends URIS2> {
    // (undocumented)
    readonly bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: Kind2<F, E, A>) => Kind2<F, G, B>;
    // (undocumented)
    readonly mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: Kind2<F, E, A>) => Kind2<F, G, A>;
}

// @public @deprecated (undocumented)
interface PipeableBifunctor3<F extends URIS3> {
    // (undocumented)
    readonly bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, G, B>;
    // (undocumented)
    readonly mapLeft: <E, G>(f: (e: E) => G) => <R, A>(fa: Kind3<F, R, E, A>) => Kind3<F, R, G, A>;
}

// @public @deprecated (undocumented)
interface PipeableBifunctor3C<F extends URIS3, E> {
    // (undocumented)
    readonly bimap: <G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, G, B>;
    // (undocumented)
    readonly mapLeft: <G>(f: (e: E) => G) => <R, A>(fa: Kind3<F, R, E, A>) => Kind3<F, R, G, A>;
}

// @public @deprecated (undocumented)
interface PipeableBifunctor4<F extends URIS4> {
    // (undocumented)
    readonly bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <S, R>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, G, B>;
    // (undocumented)
    readonly mapLeft: <E, G>(f: (e: E) => G) => <S, R, A>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, G, A>;
}

// @public @deprecated (undocumented)
interface PipeableChain<F> extends PipeableApply<F> {
    // (undocumented)
    readonly chain: <A, B>(f: (a: A) => HKT<F, B>) => (ma: HKT<F, A>) => HKT<F, B>;
    // (undocumented)
    readonly chainFirst: <A, B>(f: (a: A) => HKT<F, B>) => (ma: HKT<F, A>) => HKT<F, A>;
    // (undocumented)
    readonly flatten: <A>(mma: HKT<F, HKT<F, A>>) => HKT<F, A>;
}

// @public @deprecated (undocumented)
interface PipeableChain1<F extends URIS> extends PipeableApply1<F> {
    // (undocumented)
    readonly chain: <A, B>(f: (a: A) => Kind<F, B>) => (ma: Kind<F, A>) => Kind<F, B>;
    // (undocumented)
    readonly chainFirst: <A, B>(f: (a: A) => Kind<F, B>) => (ma: Kind<F, A>) => Kind<F, A>;
    // (undocumented)
    readonly flatten: <A>(mma: Kind<F, Kind<F, A>>) => Kind<F, A>;
}

// @public @deprecated (undocumented)
interface PipeableChain2<F extends URIS2> extends PipeableApply2<F> {
    // (undocumented)
    readonly chain: <E, A, B>(f: (a: A) => Kind2<F, E, B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, B>;
    // (undocumented)
    readonly chainFirst: <E, A, B>(f: (a: A) => Kind2<F, E, B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly flatten: <E, A>(mma: Kind2<F, E, Kind2<F, E, A>>) => Kind2<F, E, A>;
}

// @public @deprecated (undocumented)
interface PipeableChain2C<F extends URIS2, E> extends PipeableApply2C<F, E> {
    // (undocumented)
    readonly chain: <A, B>(f: (a: A) => Kind2<F, E, B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, B>;
    // (undocumented)
    readonly chainFirst: <A, B>(f: (a: A) => Kind2<F, E, B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly flatten: <A>(mma: Kind2<F, E, Kind2<F, E, A>>) => Kind2<F, E, A>;
}

// @public @deprecated (undocumented)
interface PipeableChain3<F extends URIS3> extends PipeableApply3<F> {
    // (undocumented)
    readonly chain: <R, E, A, B>(f: (a: A) => Kind3<F, R, E, B>) => (ma: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
    // (undocumented)
    readonly chainFirst: <R, E, A, B>(f: (a: A) => Kind3<F, R, E, B>) => (ma: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly flatten: <R, E, A>(mma: Kind3<F, R, E, Kind3<F, R, E, A>>) => Kind3<F, R, E, A>;
}

// @public @deprecated (undocumented)
interface PipeableChain3C<F extends URIS3, E> extends PipeableApply3C<F, E> {
    // (undocumented)
    readonly chain: <R, A, B>(f: (a: A) => Kind3<F, R, E, B>) => (ma: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
    // (undocumented)
    readonly chainFirst: <R, A, B>(f: (a: A) => Kind3<F, R, E, B>) => (ma: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly flatten: <R, A>(mma: Kind3<F, R, E, Kind3<F, R, E, A>>) => Kind3<F, R, E, A>;
}

// @public @deprecated (undocumented)
interface PipeableChain4<F extends URIS4> extends PipeableApply4<F> {
    // (undocumented)
    readonly chain: <S, R, E, A, B>(f: (a: A) => Kind4<F, S, R, E, B>) => (ma: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;
    // (undocumented)
    readonly chainFirst: <S, R, E, A, B>(f: (a: A) => Kind4<F, S, R, E, B>) => (ma: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly flatten: <S, R, E, A>(mma: Kind4<F, S, R, E, Kind4<F, S, R, E, A>>) => Kind4<F, S, R, E, A>;
}

// @public @deprecated (undocumented)
interface PipeableCompactable<F> {
    // (undocumented)
    readonly compact: <A>(fa: HKT<F, Option_2<A>>) => HKT<F, A>;
    // (undocumented)
    readonly separate: <A, B>(fa: HKT<F, Either<A, B>>) => Separated<HKT<F, A>, HKT<F, B>>;
}

// @public @deprecated (undocumented)
interface PipeableCompactable1<F extends URIS> {
    // (undocumented)
    readonly compact: <A>(fa: Kind<F, Option_2<A>>) => Kind<F, A>;
    // (undocumented)
    readonly separate: <A, B>(fa: Kind<F, Either<A, B>>) => Separated<Kind<F, A>, Kind<F, B>>;
}

// @public @deprecated (undocumented)
interface PipeableCompactable2<F extends URIS2> {
    // (undocumented)
    readonly compact: <E, A>(fa: Kind2<F, E, Option_2<A>>) => Kind2<F, E, A>;
    // (undocumented)
    readonly separate: <E, A, B>(fa: Kind2<F, E, Either<A, B>>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
}

// @public @deprecated (undocumented)
interface PipeableCompactable2C<F extends URIS2, E> {
    // (undocumented)
    readonly compact: <A>(fa: Kind2<F, E, Option_2<A>>) => Kind2<F, E, A>;
    // (undocumented)
    readonly separate: <A, B>(fa: Kind2<F, E, Either<A, B>>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
}

// @public @deprecated (undocumented)
interface PipeableCompactable3<F extends URIS3> {
    // (undocumented)
    readonly compact: <R, E, A>(fa: Kind3<F, R, E, Option_2<A>>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly separate: <R, E, A, B>(fa: Kind3<F, R, E, Either<A, B>>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
}

// @public @deprecated (undocumented)
interface PipeableCompactable3C<F extends URIS3, E> {
    // (undocumented)
    readonly compact: <R, A>(fa: Kind3<F, R, E, Option_2<A>>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly separate: <R, A, B>(fa: Kind3<F, R, E, Either<A, B>>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
}

// @public @deprecated (undocumented)
interface PipeableCompactable4<F extends URIS4> {
    // (undocumented)
    readonly compact: <S, R, E, A>(fa: Kind4<F, S, R, E, Option_2<A>>) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly separate: <S, R, E, A, B>(fa: Kind4<F, S, R, E, Either<A, B>>) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, B>>;
}

// @public @deprecated (undocumented)
interface PipeableContravariant<F> {
    // (undocumented)
    readonly contramap: <A, B>(f: (b: B) => A) => (fa: HKT<F, A>) => HKT<F, B>;
}

// @public @deprecated (undocumented)
interface PipeableContravariant1<F extends URIS> {
    // (undocumented)
    readonly contramap: <A, B>(f: (b: B) => A) => (fa: Kind<F, A>) => Kind<F, B>;
}

// @public @deprecated (undocumented)
interface PipeableContravariant2<F extends URIS2> {
    // (undocumented)
    readonly contramap: <A, B>(f: (b: B) => A) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableContravariant2C<F extends URIS2, E> {
    // (undocumented)
    readonly contramap: <A, B>(f: (b: B) => A) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableContravariant3<F extends URIS3> {
    // (undocumented)
    readonly contramap: <A, B>(f: (b: B) => A) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableContravariant3C<F extends URIS3, E> {
    // (undocumented)
    readonly contramap: <A, B>(f: (b: B) => A) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableContravariant4<F extends URIS4> {
    // (undocumented)
    readonly contramap: <A, B>(f: (b: B) => A) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableExtend<F> extends PipeableFunctor<F> {
    // (undocumented)
    readonly duplicate: <A>(wa: HKT<F, A>) => HKT<F, HKT<F, A>>;
    // (undocumented)
    readonly extend: <A, B>(f: (wa: HKT<F, A>) => B) => (wa: HKT<F, A>) => HKT<F, B>;
}

// @public @deprecated (undocumented)
interface PipeableExtend1<F extends URIS> extends PipeableFunctor1<F> {
    // (undocumented)
    readonly duplicate: <A>(wa: Kind<F, A>) => Kind<F, Kind<F, A>>;
    // (undocumented)
    readonly extend: <A, B>(f: (wa: Kind<F, A>) => B) => (wa: Kind<F, A>) => Kind<F, B>;
}

// @public @deprecated (undocumented)
interface PipeableExtend2<F extends URIS2> extends PipeableFunctor2<F> {
    // (undocumented)
    readonly duplicate: <E, A>(wa: Kind2<F, E, A>) => Kind2<F, E, Kind2<F, E, A>>;
    // (undocumented)
    readonly extend: <E, A, B>(f: (wa: Kind2<F, E, A>) => B) => (wa: Kind2<F, E, A>) => Kind2<F, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableExtend2C<F extends URIS2, E> extends PipeableFunctor2C<F, E> {
    // (undocumented)
    readonly duplicate: <A>(wa: Kind2<F, E, A>) => Kind2<F, E, Kind2<F, E, A>>;
    // (undocumented)
    readonly extend: <A, B>(f: (wa: Kind2<F, E, A>) => B) => (wa: Kind2<F, E, A>) => Kind2<F, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableExtend3<F extends URIS3> extends PipeableFunctor3<F> {
    // (undocumented)
    readonly duplicate: <R, E, A>(wa: Kind3<F, R, E, A>) => Kind3<F, R, E, Kind3<F, R, E, A>>;
    // (undocumented)
    readonly extend: <R, E, A, B>(f: (wa: Kind3<F, R, E, A>) => B) => (wa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableExtend3C<F extends URIS3, E> extends PipeableFunctor3C<F, E> {
    // (undocumented)
    readonly duplicate: <R, A>(wa: Kind3<F, R, E, A>) => Kind3<F, R, E, Kind3<F, R, E, A>>;
    // (undocumented)
    readonly extend: <R, A, B>(f: (wa: Kind3<F, R, E, A>) => B) => (wa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableExtend4<F extends URIS4> extends PipeableFunctor4<F> {
    // (undocumented)
    readonly duplicate: <S, R, E, A>(wa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, Kind4<F, S, R, E, A>>;
    // (undocumented)
    readonly extend: <S, R, E, A, B>(f: (wa: Kind4<F, S, R, E, A>) => B) => (wa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableFilterable<F> extends PipeableCompactable<F> {
    // (undocumented)
    readonly filter: {
        <A, B extends A>(refinement: Refinement<A, B>): (fa: HKT<F, A>) => HKT<F, B>;
        <A>(predicate: Predicate<A>): (fa: HKT<F, A>) => HKT<F, A>;
    };
    // (undocumented)
    readonly filterMap: <A, B>(f: (a: A) => Option_2<B>) => (fa: HKT<F, A>) => HKT<F, B>;
    // (undocumented)
    readonly partition: {
        <A, B extends A>(refinement: Refinement<A, B>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, B>>;
        <A>(predicate: Predicate<A>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, A>>;
    };
    // (undocumented)
    readonly partitionMap: <A, B, C>(f: (a: A) => Either<B, C>) => (fa: HKT<F, A>) => Separated<HKT<F, B>, HKT<F, C>>;
}

// @public @deprecated (undocumented)
interface PipeableFilterable1<F extends URIS> extends PipeableCompactable1<F> {
    // (undocumented)
    readonly filter: {
        <A, B extends A>(refinement: Refinement<A, B>): (fa: Kind<F, A>) => Kind<F, B>;
        <A>(predicate: Predicate<A>): (fa: Kind<F, A>) => Kind<F, A>;
    };
    // (undocumented)
    readonly filterMap: <A, B>(f: (a: A) => Option_2<B>) => (fa: Kind<F, A>) => Kind<F, B>;
    // (undocumented)
    readonly partition: {
        <A, B extends A>(refinement: Refinement<A, B>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, B>>;
        <A>(predicate: Predicate<A>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, A>>;
    };
    // (undocumented)
    readonly partitionMap: <A, B, C>(f: (a: A) => Either<B, C>) => (fa: Kind<F, A>) => Separated<Kind<F, B>, Kind<F, C>>;
}

// @public @deprecated (undocumented)
interface PipeableFilterable2<F extends URIS2> extends PipeableCompactable2<F> {
    // (undocumented)
    readonly filter: {
        <A, B extends A>(refinement: Refinement<A, B>): <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;
        <A>(predicate: Predicate<A>): <E>(fa: Kind2<F, E, A>) => Kind2<F, E, A>;
    };
    // (undocumented)
    readonly filterMap: <A, B>(f: (a: A) => Option_2<B>) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;
    // (undocumented)
    readonly partition: {
        <A, B extends A>(refinement: Refinement<A, B>): <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
        <A>(predicate: Predicate<A>): <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>;
    };
    // (undocumented)
    readonly partitionMap: <A, B, C>(f: (a: A) => Either<B, C>) => <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>;
}

// @public @deprecated (undocumented)
interface PipeableFilterable2C<F extends URIS2, E> extends PipeableCompactable2C<F, E> {
    // (undocumented)
    readonly filter: {
        <A, B extends A>(refinement: Refinement<A, B>): (fa: Kind2<F, E, A>) => Kind2<F, E, B>;
        <A>(predicate: Predicate<A>): (fa: Kind2<F, E, A>) => Kind2<F, E, A>;
    };
    // (undocumented)
    readonly filterMap: <A, B>(f: (a: A) => Option_2<B>) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>;
    // (undocumented)
    readonly partition: {
        <A, B extends A>(refinement: Refinement<A, B>): (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
        <A>(predicate: Predicate<A>): (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>;
    };
    // (undocumented)
    readonly partitionMap: <A, B, C>(f: (a: A) => Either<B, C>) => (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>;
}

// @public @deprecated (undocumented)
interface PipeableFilterable3<F extends URIS3> extends PipeableCompactable3<F> {
    // (undocumented)
    readonly filter: {
        <A, B extends A>(refinement: Refinement<A, B>): <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
        <A>(predicate: Predicate<A>): <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
    };
    // (undocumented)
    readonly filterMap: <A, B>(f: (a: A) => Option_2<B>) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly partition: {
        <A, B extends A>(refinement: Refinement<A, B>): <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
        <A>(predicate: Predicate<A>): <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>;
    };
    // (undocumented)
    readonly partitionMap: <A, B, C>(f: (a: A) => Either<B, C>) => <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>;
}

// @public @deprecated (undocumented)
interface PipeableFilterable3C<F extends URIS3, E> extends PipeableCompactable3C<F, E> {
    // (undocumented)
    readonly filter: {
        <A, B extends A>(refinement: Refinement<A, B>): <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
        <A>(predicate: Predicate<A>): <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
    };
    // (undocumented)
    readonly filterMap: <A, B>(f: (a: A) => Option_2<B>) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly partition: {
        <A, B extends A>(refinement: Refinement<A, B>): <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
        <A>(predicate: Predicate<A>): <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>;
    };
    // (undocumented)
    readonly partitionMap: <A, B, C>(f: (a: A) => Either<B, C>) => <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>;
}

// @public @deprecated (undocumented)
interface PipeableFilterable4<F extends URIS4> extends PipeableCompactable4<F> {
    // (undocumented)
    readonly filter: {
        <A, B extends A>(refinement: Refinement<A, B>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;
        <A>(predicate: Predicate<A>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>;
    };
    // (undocumented)
    readonly filterMap: <A, B>(f: (a: A) => Option_2<B>) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly partition: {
        <A, B extends A>(refinement: Refinement<A, B>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, B>>;
        <A>(predicate: Predicate<A>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, A>>;
    };
    // (undocumented)
    readonly partitionMap: <A, B, C>(f: (a: A) => Either<B, C>) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, B>, Kind4<F, S, R, E, C>>;
}

// @public @deprecated (undocumented)
interface PipeableFilterableWithIndex<F, I> extends PipeableFilterable<F> {
    // (undocumented)
    readonly filterMapWithIndex: <A, B>(f: (i: I, a: A) => Option_2<B>) => (fa: HKT<F, A>) => HKT<F, B>;
    // (undocumented)
    readonly filterWithIndex: {
        <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): (fa: HKT<F, A>) => HKT<F, B>;
        <A>(predicateWithIndex: PredicateWithIndex<I, A>): (fa: HKT<F, A>) => HKT<F, A>;
    };
    // (undocumented)
    readonly partitionMapWithIndex: <A, B, C>(f: (i: I, a: A) => Either<B, C>) => (fa: HKT<F, A>) => Separated<HKT<F, B>, HKT<F, C>>;
    // (undocumented)
    readonly partitionWithIndex: {
        <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, B>>;
        <A>(predicateWithIndex: PredicateWithIndex<I, A>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, A>>;
    };
}

// @public @deprecated (undocumented)
interface PipeableFilterableWithIndex1<F extends URIS, I> extends PipeableFilterable1<F> {
    // (undocumented)
    readonly filterMapWithIndex: <A, B>(f: (i: I, a: A) => Option_2<B>) => (fa: Kind<F, A>) => Kind<F, B>;
    // (undocumented)
    readonly filterWithIndex: {
        <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): (fa: Kind<F, A>) => Kind<F, B>;
        <A>(predicateWithIndex: PredicateWithIndex<I, A>): (fa: Kind<F, A>) => Kind<F, A>;
    };
    // (undocumented)
    readonly partitionMapWithIndex: <A, B, C>(f: (i: I, a: A) => Either<B, C>) => (fa: Kind<F, A>) => Separated<Kind<F, B>, Kind<F, C>>;
    // (undocumented)
    readonly partitionWithIndex: {
        <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, B>>;
        <A>(predicateWithIndex: PredicateWithIndex<I, A>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, A>>;
    };
}

// @public @deprecated (undocumented)
interface PipeableFilterableWithIndex2<F extends URIS2, I> extends PipeableFilterable2<F> {
    // (undocumented)
    readonly filterMapWithIndex: <A, B>(f: (i: I, a: A) => Option_2<B>) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;
    // (undocumented)
    readonly filterWithIndex: {
        <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;
        <A>(predicateWithIndex: PredicateWithIndex<I, A>): <E>(fa: Kind2<F, E, A>) => Kind2<F, E, A>;
    };
    // (undocumented)
    readonly partitionMapWithIndex: <A, B, C>(f: (i: I, a: A) => Either<B, C>) => <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>;
    // (undocumented)
    readonly partitionWithIndex: {
        <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
        <A>(predicateWithIndex: PredicateWithIndex<I, A>): <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>;
    };
}

// @public @deprecated (undocumented)
interface PipeableFilterableWithIndex2C<F extends URIS2, I, E> extends PipeableFilterable2C<F, E> {
    // (undocumented)
    readonly filterMapWithIndex: <A, B>(f: (i: I, a: A) => Option_2<B>) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>;
    // (undocumented)
    readonly filterWithIndex: {
        <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): (fa: Kind2<F, E, A>) => Kind2<F, E, B>;
        <A>(predicateWithIndex: PredicateWithIndex<I, A>): (fa: Kind2<F, E, A>) => Kind2<F, E, A>;
    };
    // (undocumented)
    readonly partitionMapWithIndex: <A, B, C>(f: (i: I, a: A) => Either<B, C>) => (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>;
    // (undocumented)
    readonly partitionWithIndex: {
        <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>;
        <A>(predicateWithIndex: PredicateWithIndex<I, A>): (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>;
    };
}

// @public @deprecated (undocumented)
interface PipeableFilterableWithIndex3<F extends URIS3, I> extends PipeableFilterable3<F> {
    // (undocumented)
    readonly filterMapWithIndex: <A, B>(f: (i: I, a: A) => Option_2<B>) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly filterWithIndex: {
        <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
        <A>(predicateWithIndex: PredicateWithIndex<I, A>): <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
    };
    // (undocumented)
    readonly partitionMapWithIndex: <A, B, C>(f: (i: I, a: A) => Either<B, C>) => <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>;
    // (undocumented)
    readonly partitionWithIndex: {
        <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
        <A>(predicateWithIndex: PredicateWithIndex<I, A>): <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>;
    };
}

// @public @deprecated (undocumented)
interface PipeableFilterableWithIndex3C<F extends URIS3, I, E> extends PipeableFilterable3C<F, E> {
    // (undocumented)
    readonly filterMapWithIndex: <A, B>(f: (i: I, a: A) => Option_2<B>) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly filterWithIndex: {
        <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
        <A>(predicateWithIndex: PredicateWithIndex<I, A>): <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
    };
    // (undocumented)
    readonly partitionMapWithIndex: <A, B, C>(f: (i: I, a: A) => Either<B, C>) => <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>;
    // (undocumented)
    readonly partitionWithIndex: {
        <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>;
        <A>(predicateWithIndex: PredicateWithIndex<I, A>): <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>;
    };
}

// @public @deprecated (undocumented)
interface PipeableFilterableWithIndex4<F extends URIS4, I> extends PipeableFilterable4<F> {
    // (undocumented)
    readonly filterMapWithIndex: <A, B>(f: (i: I, a: A) => Option_2<B>) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly filterWithIndex: {
        <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;
        <A>(predicateWithIndex: PredicateWithIndex<I, A>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>;
    };
    // (undocumented)
    readonly partitionMapWithIndex: <A, B, C>(f: (i: I, a: A) => Either<B, C>) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, B>, Kind4<F, S, R, E, C>>;
    // (undocumented)
    readonly partitionWithIndex: {
        <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, B>>;
        <A>(predicateWithIndex: PredicateWithIndex<I, A>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, A>>;
    };
}

// @public @deprecated (undocumented)
interface PipeableFoldable<F> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: HKT<F, A>) => M;
    // (undocumented)
    readonly reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: HKT<F, A>) => B;
    // (undocumented)
    readonly reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: HKT<F, A>) => B;
}

// @public @deprecated (undocumented)
interface PipeableFoldable1<F extends URIS> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Kind<F, A>) => M;
    // (undocumented)
    readonly reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Kind<F, A>) => B;
    // (undocumented)
    readonly reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Kind<F, A>) => B;
}

// @public @deprecated (undocumented)
interface PipeableFoldable2<F extends URIS2> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: Kind2<F, E, A>) => M;
    // (undocumented)
    readonly reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: Kind2<F, E, A>) => B;
    // (undocumented)
    readonly reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: Kind2<F, E, A>) => B;
}

// @public @deprecated (undocumented)
interface PipeableFoldable2C<F extends URIS2, E> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Kind2<F, E, A>) => M;
    // (undocumented)
    readonly reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Kind2<F, E, A>) => B;
    // (undocumented)
    readonly reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Kind2<F, E, A>) => B;
}

// @public @deprecated (undocumented)
interface PipeableFoldable3<F extends URIS3> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <R, E>(fa: Kind3<F, R, E, A>) => M;
    // (undocumented)
    readonly reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B;
    // (undocumented)
    readonly reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B;
}

// @public @deprecated (undocumented)
interface PipeableFoldable3C<F extends URIS3, E> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <R>(fa: Kind3<F, R, E, A>) => M;
    // (undocumented)
    readonly reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => B;
    // (undocumented)
    readonly reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <R>(fa: Kind3<F, R, E, A>) => B;
}

// @public @deprecated (undocumented)
interface PipeableFoldable4<F extends URIS4> {
    // (undocumented)
    readonly foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => M;
    // (undocumented)
    readonly reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B;
    // (undocumented)
    readonly reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B;
}

// @public @deprecated (undocumented)
interface PipeableFoldableWithIndex<F, I> extends PipeableFoldable<F> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => (fa: HKT<F, A>) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <A, B>(b: B, f: (i: I, a: A, b: B) => B) => (fa: HKT<F, A>) => B;
    // (undocumented)
    readonly reduceWithIndex: <A, B>(b: B, f: (i: I, b: B, a: A) => B) => (fa: HKT<F, A>) => B;
}

// @public @deprecated (undocumented)
interface PipeableFoldableWithIndex1<F extends URIS, I> extends PipeableFoldable1<F> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => (fa: Kind<F, A>) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <A, B>(b: B, f: (i: I, a: A, b: B) => B) => (fa: Kind<F, A>) => B;
    // (undocumented)
    readonly reduceWithIndex: <A, B>(b: B, f: (i: I, b: B, a: A) => B) => (fa: Kind<F, A>) => B;
}

// @public @deprecated (undocumented)
interface PipeableFoldableWithIndex2<F extends URIS2, I> extends PipeableFoldable2<F> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => <E>(fa: Kind2<F, E, A>) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <E>(fa: Kind2<F, E, A>) => B;
    // (undocumented)
    readonly reduceWithIndex: <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <E>(fa: Kind2<F, E, A>) => B;
}

// @public @deprecated (undocumented)
interface PipeableFoldableWithIndex2C<F extends URIS2, I, E> extends PipeableFoldable2C<F, E> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => (fa: Kind2<F, E, A>) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <A, B>(b: B, f: (i: I, a: A, b: B) => B) => (fa: Kind2<F, E, A>) => B;
    // (undocumented)
    readonly reduceWithIndex: <A, B>(b: B, f: (i: I, b: B, a: A) => B) => (fa: Kind2<F, E, A>) => B;
}

// @public @deprecated (undocumented)
interface PipeableFoldableWithIndex3<F extends URIS3, I> extends PipeableFoldable3<F> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => <R, E>(fa: Kind3<F, R, E, A>) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B;
    // (undocumented)
    readonly reduceWithIndex: <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B;
}

// @public @deprecated (undocumented)
interface PipeableFoldableWithIndex3C<F extends URIS3, I, E> extends PipeableFoldable3C<F, E> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => <R>(fa: Kind3<F, R, E, A>) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <R>(fa: Kind3<F, R, E, A>) => B;
    // (undocumented)
    readonly reduceWithIndex: <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => B;
}

// @public @deprecated (undocumented)
interface PipeableFoldableWithIndex4<F extends URIS4, I> extends PipeableFoldable4<F> {
    // (undocumented)
    readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => M;
    // (undocumented)
    readonly reduceRightWithIndex: <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B;
    // (undocumented)
    readonly reduceWithIndex: <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B;
}

// @public @deprecated (undocumented)
interface PipeableFunctor<F> {
    // (undocumented)
    readonly map: <A, B>(f: (a: A) => B) => (fa: HKT<F, A>) => HKT<F, B>;
}

// @public @deprecated (undocumented)
interface PipeableFunctor1<F extends URIS> {
    // (undocumented)
    readonly map: <A, B>(f: (a: A) => B) => (fa: Kind<F, A>) => Kind<F, B>;
}

// @public @deprecated (undocumented)
interface PipeableFunctor2<F extends URIS2> {
    // (undocumented)
    readonly map: <A, B>(f: (a: A) => B) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableFunctor2C<F extends URIS2, E> {
    // (undocumented)
    readonly map: <A, B>(f: (a: A) => B) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableFunctor3<F extends URIS3> {
    // (undocumented)
    readonly map: <A, B>(f: (a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableFunctor3C<F extends URIS3, E> {
    // (undocumented)
    readonly map: <A, B>(f: (a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableFunctor4<F extends URIS4> {
    // (undocumented)
    readonly map: <A, B>(f: (a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableFunctorWithIndex<F, I> extends PipeableFunctor<F> {
    // (undocumented)
    readonly mapWithIndex: <A, B>(f: (i: I, a: A) => B) => (fa: HKT<F, A>) => HKT<F, B>;
}

// @public @deprecated (undocumented)
interface PipeableFunctorWithIndex1<F extends URIS, I> extends PipeableFunctor1<F> {
    // (undocumented)
    readonly mapWithIndex: <A, B>(f: (i: I, a: A) => B) => (fa: Kind<F, A>) => Kind<F, B>;
}

// @public @deprecated (undocumented)
interface PipeableFunctorWithIndex2<F extends URIS2, I> extends PipeableFunctor2<F> {
    // (undocumented)
    readonly mapWithIndex: <A, B>(f: (i: I, a: A) => B) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableFunctorWithIndex2C<F extends URIS2, I, E> extends PipeableFunctor2C<F, E> {
    // (undocumented)
    readonly mapWithIndex: <A, B>(f: (i: I, a: A) => B) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableFunctorWithIndex3<F extends URIS3, I> extends PipeableFunctor3<F> {
    // (undocumented)
    readonly mapWithIndex: <A, B>(f: (i: I, a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableFunctorWithIndex3C<F extends URIS3, I, E> extends PipeableFunctor3C<F, E> {
    // (undocumented)
    readonly mapWithIndex: <A, B>(f: (i: I, a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableFunctorWithIndex4<F extends URIS4, I> extends PipeableFunctor4<F> {
    // (undocumented)
    readonly mapWithIndex: <A, B>(f: (i: I, a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableMonadThrow<F> {
    // (undocumented)
    readonly filterOrElse: {
        <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: HKT<F, A>) => HKT<F, B>;
        <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: HKT<F, A>) => HKT<F, A>;
    };
    // (undocumented)
    readonly fromEither: <E, A>(ma: Either<E, A>) => HKT<F, A>;
    // (undocumented)
    readonly fromOption: <E>(onNone: LazyArg<E>) => <A>(ma: Option_2<A>) => HKT<F, A>;
    // (undocumented)
    readonly fromPredicate: {
        <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => HKT<F, B>;
        <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => HKT<F, A>;
    };
}

// @public @deprecated (undocumented)
interface PipeableMonadThrow1<F extends URIS> {
    // (undocumented)
    readonly filterOrElse: {
        <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: Kind<F, A>) => Kind<F, B>;
        <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Kind<F, A>) => Kind<F, A>;
    };
    // (undocumented)
    readonly fromEither: <E, A>(ma: Either<E, A>) => Kind<F, A>;
    // (undocumented)
    readonly fromOption: <E>(onNone: LazyArg<E>) => <A>(ma: Option_2<A>) => Kind<F, A>;
    // (undocumented)
    readonly fromPredicate: {
        <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Kind<F, B>;
        <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Kind<F, A>;
    };
}

// @public @deprecated (undocumented)
interface PipeableMonadThrow2<F extends URIS2> {
    // (undocumented)
    readonly filterOrElse: {
        <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: Kind2<F, E, A>) => Kind2<F, E, B>;
        <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Kind2<F, E, A>) => Kind2<F, E, A>;
    };
    // (undocumented)
    readonly fromEither: <E, A>(ma: Either<E, A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly fromOption: <E>(onNone: LazyArg<E>) => <A>(ma: Option_2<A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly fromPredicate: {
        <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, B>;
        <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, A>;
    };
}

// @public @deprecated (undocumented)
interface PipeableMonadThrow2C<F extends URIS2, E> {
    // (undocumented)
    readonly filterOrElse: {
        <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: Kind2<F, E, A>) => Kind2<F, E, B>;
        <A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Kind2<F, E, A>) => Kind2<F, E, A>;
    };
    // (undocumented)
    readonly fromEither: <A>(ma: Either<E, A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly fromOption: (onNone: LazyArg<E>) => <A>(ma: Option_2<A>) => Kind2<F, E, A>;
    // (undocumented)
    readonly fromPredicate: {
        <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, B>;
        <A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, A>;
    };
}

// @public @deprecated (undocumented)
interface PipeableMonadThrow3<F extends URIS3> {
    // (undocumented)
    readonly filterOrElse: {
        <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
        <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
    };
    // (undocumented)
    readonly fromEither: <R, E, A>(ma: Either<E, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly fromOption: <E>(onNone: LazyArg<E>) => <R, A>(ma: Option_2<A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly fromPredicate: {
        <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <U>(a: A) => Kind3<F, U, E, B>;
        <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, A>;
    };
}

// @public @deprecated (undocumented)
interface PipeableMonadThrow3C<F extends URIS3, E> {
    // (undocumented)
    readonly filterOrElse: {
        <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, B>;
        <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, A>;
    };
    // (undocumented)
    readonly fromEither: <R, A>(ma: Either<E, A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly fromOption: (onNone: LazyArg<E>) => <R, A>(ma: Option_2<A>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly fromPredicate: {
        <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <U>(a: A) => Kind3<F, U, E, B>;
        <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, A>;
    };
}

// @public @deprecated (undocumented)
interface PipeableMonadThrow4<F extends URIS4> {
    // (undocumented)
    readonly filterOrElse: {
        <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R>(ma: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>;
        <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R>(ma: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>;
    };
    // (undocumented)
    readonly fromEither: <S, R, E, A>(ma: Either<E, A>) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly fromOption: <E>(onNone: LazyArg<E>) => <S, R, A>(ma: Option_2<A>) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly fromPredicate: {
        <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R>(a: A) => Kind4<F, S, R, E, B>;
        <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R>(a: A) => Kind4<F, S, R, E, A>;
    };
}

// @public @deprecated (undocumented)
interface PipeableProfunctor<F> {
    // (undocumented)
    readonly promap: <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: HKT2<F, E, A>) => HKT2<F, D, B>;
}

// @public @deprecated (undocumented)
interface PipeableProfunctor2<F extends URIS2> extends PipeableFunctor2<F> {
    // (undocumented)
    readonly promap: <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Kind2<F, E, A>) => Kind2<F, D, B>;
}

// @public @deprecated (undocumented)
interface PipeableProfunctor2C<F extends URIS2, E> extends PipeableFunctor2C<F, E> {
    // (undocumented)
    readonly promap: <A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Kind2<F, E, A>) => Kind2<F, D, B>;
}

// @public @deprecated (undocumented)
interface PipeableProfunctor3<F extends URIS3> extends PipeableFunctor3<F> {
    // (undocumented)
    readonly promap: <R, E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Kind3<F, R, E, A>) => Kind3<F, R, D, B>;
}

// @public @deprecated (undocumented)
interface PipeableProfunctor3C<F extends URIS3, E> extends PipeableFunctor3C<F, E> {
    // (undocumented)
    readonly promap: <R, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Kind3<F, R, E, A>) => Kind3<F, R, D, B>;
}

// @public @deprecated (undocumented)
interface PipeableProfunctor4<F extends URIS4> extends PipeableFunctor4<F> {
    // (undocumented)
    readonly promap: <S, R, E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Kind4<F, S, R, E, A>) => Kind4<F, S, R, D, B>;
}

// @public @deprecated (undocumented)
interface PipeableSemigroupoid<F> {
    // (undocumented)
    readonly compose: <E, A>(la: HKT2<F, E, A>) => <B>(ab: HKT2<F, A, B>) => HKT2<F, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableSemigroupoid2<F extends URIS2> {
    // (undocumented)
    readonly compose: <E, A>(la: Kind2<F, E, A>) => <B>(ab: Kind2<F, A, B>) => Kind2<F, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableSemigroupoid2C<F extends URIS2, E> {
    // (undocumented)
    readonly compose: <A>(la: Kind2<F, E, A>) => <B>(ab: Kind2<F, A, B>) => Kind2<F, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableSemigroupoid3<F extends URIS3> {
    // (undocumented)
    readonly compose: <R, E, A>(la: Kind3<F, R, E, A>) => <B>(ab: Kind3<F, R, A, B>) => Kind3<F, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableSemigroupoid3C<F extends URIS3, E> {
    // (undocumented)
    readonly compose: <R, A>(la: Kind3<F, R, E, A>) => <B>(ab: Kind3<F, R, A, B>) => Kind3<F, R, E, B>;
}

// @public @deprecated (undocumented)
interface PipeableSemigroupoid4<F extends URIS4> {
    // (undocumented)
    readonly compose: <S, R, E, A>(la: Kind4<F, S, R, E, A>) => <B>(ab: Kind4<F, S, R, A, B>) => Kind4<F, S, R, E, B>;
}

// @public (undocumented)
interface PipeableTraverse1<T extends URIS> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, FR, FE, B>(f: (a: A) => Kind3<F, FR, FE, B>) => (ta: Kind<T, A>) => Kind3<F, FR, FE, Kind<T, B>>;
    // (undocumented)
    <F extends URIS3, FE>(F: Applicative3C<F, FE>): <A, FR, B>(f: (a: A) => Kind3<F, FR, FE, B>) => (ta: Kind<T, A>) => Kind3<F, FR, FE, Kind<T, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, FE, B>(f: (a: A) => Kind2<F, FE, B>) => (ta: Kind<T, A>) => Kind2<F, FE, Kind<T, B>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <A, B>(f: (a: A) => Kind2<F, FE, B>) => (ta: Kind<T, A>) => Kind2<F, FE, Kind<T, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(f: (a: A) => Kind<F, B>) => (ta: Kind<T, A>) => Kind<F, Kind<T, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(f: (a: A) => HKT<F, B>) => (ta: Kind<T, A>) => HKT<F, Kind<T, B>>;
}

// @public (undocumented)
interface PipeableTraverse2<T extends URIS2> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, FR, FE, B>(f: (a: A) => Kind3<F, FR, FE, B>) => <TE>(ta: Kind2<T, TE, A>) => Kind3<F, FR, FE, Kind2<T, TE, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, FE, B>(f: (a: A) => Kind2<F, FE, B>) => <TE>(ta: Kind2<T, TE, A>) => Kind2<F, FE, Kind2<T, TE, B>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <A, B>(f: (a: A) => Kind2<F, FE, B>) => <TE>(ta: Kind2<T, TE, A>) => Kind2<F, FE, Kind2<T, TE, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(f: (a: A) => Kind<F, B>) => <TE>(ta: Kind2<T, TE, A>) => Kind<F, Kind2<T, TE, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(f: (a: A) => HKT<F, B>) => <TE>(ta: Kind2<T, TE, A>) => HKT<F, Kind2<T, TE, B>>;
}

// @public (undocumented)
interface PipeableTraverseWithIndex1<T extends URIS, I> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, E, B>(f: (i: I, a: A) => Kind3<F, R, E, B>) => (ta: Kind<T, A>) => Kind3<F, R, E, Kind<T, B>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B>(f: (i: I, a: A) => Kind3<F, R, E, B>) => (ta: Kind<T, A>) => Kind3<F, R, E, Kind<T, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, E, B>(f: (i: I, a: A) => Kind2<F, E, B>) => (ta: Kind<T, A>) => Kind2<F, E, Kind<T, B>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B>(f: (i: I, a: A) => Kind2<F, E, B>) => (ta: Kind<T, A>) => Kind2<F, E, Kind<T, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(f: (i: I, a: A) => Kind<F, B>) => (ta: Kind<T, A>) => Kind<F, Kind<T, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(f: (i: I, a: A) => HKT<F, B>) => (ta: Kind<T, A>) => HKT<F, Kind<T, B>>;
}

// @public (undocumented)
interface PipeableTraverseWithIndex2<T extends URIS2, I> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, FE, B>(f: (i: I, a: A) => Kind3<F, R, FE, B>) => <TE>(ta: Kind2<T, TE, A>) => Kind3<F, R, FE, Kind2<T, TE, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, FE, B>(f: (i: I, a: A) => Kind2<F, FE, B>) => <TE>(ta: Kind2<T, TE, A>) => Kind2<F, FE, Kind2<T, TE, B>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <A, B>(f: (i: I, a: A) => Kind2<F, FE, B>) => <TE>(ta: Kind2<T, TE, A>) => Kind2<F, FE, Kind2<T, TE, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(f: (i: I, a: A) => Kind<F, B>) => <E>(ta: Kind2<T, E, A>) => Kind<F, Kind2<T, E, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(f: (i: I, a: A) => HKT<F, B>) => <E>(ta: Kind2<T, E, A>) => HKT<F, Kind2<T, E, B>>;
}

// @public (undocumented)
interface PipeableWilt<W> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, E, B, C>(f: (a: A) => Kind3<F, R, E, Either<B, C>>) => (wa: HKT<W, A>) => Kind3<F, R, E, Separated<HKT<W, B>, HKT<W, C>>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B, C>(f: (a: A) => Kind3<F, R, E, Either<B, C>>) => (wa: HKT<W, A>) => Kind3<F, R, E, Separated<HKT<W, B>, HKT<W, C>>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, E, B, C>(f: (a: A) => Kind2<F, E, Either<B, C>>) => (wa: HKT<W, A>) => Kind2<F, E, Separated<HKT<W, B>, HKT<W, C>>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B, C>(f: (a: A) => Kind2<F, E, Either<B, C>>) => (wa: HKT<W, A>) => Kind2<F, E, Separated<HKT<W, B>, HKT<W, C>>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B, C>(f: (a: A) => Kind<F, Either<B, C>>) => (wa: HKT<W, A>) => Kind<F, Separated<HKT<W, B>, HKT<W, C>>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B, C>(f: (a: A) => HKT<F, Either<B, C>>) => (wa: HKT<W, A>) => HKT<F, Separated<HKT<W, B>, HKT<W, C>>>;
}

// @public (undocumented)
interface PipeableWilt1<W extends URIS> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, E, B, C>(f: (a: A) => Kind3<F, R, E, Either<B, C>>) => (wa: Kind<W, A>) => Kind3<F, R, E, Separated<Kind<W, B>, Kind<W, C>>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B, C>(f: (a: A) => Kind3<F, R, E, Either<B, C>>) => (wa: Kind<W, A>) => Kind3<F, R, E, Separated<Kind<W, B>, Kind<W, C>>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, E, B, C>(f: (a: A) => Kind2<F, E, Either<B, C>>) => (wa: Kind<W, A>) => Kind2<F, E, Separated<Kind<W, B>, Kind<W, C>>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B, C>(f: (a: A) => Kind2<F, E, Either<B, C>>) => (wa: Kind<W, A>) => Kind2<F, E, Separated<Kind<W, B>, Kind<W, C>>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B, C>(f: (a: A) => Kind<F, Either<B, C>>) => (wa: Kind<W, A>) => Kind<F, Separated<Kind<W, B>, Kind<W, C>>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B, C>(f: (a: A) => HKT<F, Either<B, C>>) => (wa: Kind<W, A>) => HKT<F, Separated<Kind<W, B>, Kind<W, C>>>;
}

// @public (undocumented)
interface PipeableWilt2<W extends URIS2> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, FE, B, C>(f: (a: A) => Kind3<F, R, FE, Either<B, C>>) => <WE>(wa: Kind2<W, WE, A>) => Kind3<F, R, FE, Separated<Kind2<W, WE, B>, Kind2<W, WE, C>>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, FE, B, C>(f: (a: A) => Kind2<F, FE, Either<B, C>>) => <WE>(wa: Kind2<W, WE, A>) => Kind2<F, FE, Separated<Kind2<W, WE, B>, Kind2<W, WE, C>>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <A, B, C>(f: (a: A) => Kind2<F, FE, Either<B, C>>) => <WE>(wa: Kind2<W, WE, A>) => Kind2<F, FE, Separated<Kind2<W, WE, B>, Kind2<W, WE, C>>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B, C>(f: (a: A) => Kind<F, Either<B, C>>) => <WE>(wa: Kind2<W, WE, A>) => Kind<F, Separated<Kind2<W, WE, B>, Kind2<W, WE, C>>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B, C>(f: (a: A) => HKT<F, Either<B, C>>) => <WE>(wa: Kind2<W, WE, A>) => HKT<F, Separated<Kind2<W, WE, B>, Kind2<W, WE, C>>>;
}

// @public (undocumented)
interface PipeableWilt2C<W extends URIS2, WE> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, FE, B, C>(f: (a: A) => Kind3<F, R, FE, Either<B, C>>) => (wa: Kind2<W, WE, A>) => Kind3<F, R, FE, Separated<Kind2<W, WE, B>, Kind2<W, WE, C>>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, FE, B, C>(f: (a: A) => Kind2<F, FE, Either<B, C>>) => (wa: Kind2<W, WE, A>) => Kind2<F, FE, Separated<Kind2<W, WE, B>, Kind2<W, WE, C>>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <A, B, C>(f: (a: A) => Kind2<F, FE, Either<B, C>>) => (wa: Kind2<W, WE, A>) => Kind2<F, FE, Separated<Kind2<W, WE, B>, Kind2<W, WE, C>>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B, C>(f: (a: A) => Kind<F, Either<B, C>>) => (wa: Kind2<W, WE, A>) => Kind<F, Separated<Kind2<W, WE, B>, Kind2<W, WE, C>>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B, C>(f: (a: A) => HKT<F, Either<B, C>>) => (wa: Kind2<W, WE, A>) => HKT<F, Separated<Kind2<W, WE, B>, Kind2<W, WE, C>>>;
}

// @public (undocumented)
interface PipeableWilt3<W extends URIS3> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, FR, FE, B, C>(f: (a: A) => Kind3<F, FR, FE, Either<B, C>>) => <WR, WE>(wa: Kind3<W, WR, WE, A>) => Kind3<F, FR, FE, Separated<Kind3<W, WR, WE, B>, Kind3<W, WR, WE, C>>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, FE, B, C>(f: (a: A) => Kind2<F, FE, Either<B, C>>) => <WR, WE>(wa: Kind3<W, WR, WE, A>) => Kind2<F, FE, Separated<Kind3<W, WR, WE, B>, Kind3<W, WR, WE, C>>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <A, B, C>(f: (a: A) => Kind2<F, FE, Either<B, C>>) => <WR, WE>(wa: Kind3<W, WR, WE, A>) => Kind2<F, FE, Separated<Kind3<W, WR, WE, B>, Kind3<W, WR, WE, C>>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B, C>(f: (a: A) => Kind<F, Either<B, C>>) => <WR, WE>(wa: Kind3<W, WR, WE, A>) => Kind<F, Separated<Kind3<W, WR, WE, B>, Kind3<W, WR, WE, C>>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B, C>(f: (a: A) => HKT<F, Either<B, C>>) => <WR, WE>(wa: Kind3<W, WR, WE, A>) => HKT<F, Separated<Kind3<W, WR, WE, B>, Kind3<W, WR, WE, C>>>;
}

// @public (undocumented)
interface PipeableWither<W> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, E, B>(f: (a: A) => Kind3<F, R, E, Option_2<B>>) => (ta: HKT<W, A>) => Kind3<F, R, E, HKT<W, B>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B>(f: (a: A) => Kind3<F, R, E, Option_2<B>>) => (ta: HKT<W, A>) => Kind3<F, R, E, HKT<W, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, E, B>(f: (a: A) => Kind2<F, E, Option_2<B>>) => (ta: HKT<W, A>) => Kind2<F, E, HKT<W, B>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B>(f: (a: A) => Kind2<F, E, Option_2<B>>) => (ta: HKT<W, A>) => Kind2<F, E, HKT<W, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(f: (a: A) => Kind<F, Option_2<B>>) => (ta: HKT<W, A>) => Kind<F, HKT<W, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(f: (a: A) => HKT<F, Option_2<B>>) => (ta: HKT<W, A>) => HKT<F, HKT<W, B>>;
}

// @public (undocumented)
interface PipeableWither1<W extends URIS> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, E, B>(f: (a: A) => Kind3<F, R, E, Option_2<B>>) => (ta: Kind<W, A>) => Kind3<F, R, E, Kind<W, B>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B>(f: (a: A) => Kind3<F, R, E, Option_2<B>>) => (ta: Kind<W, A>) => Kind3<F, R, E, Kind<W, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, E, B>(f: (a: A) => Kind2<F, E, Option_2<B>>) => (ta: Kind<W, A>) => Kind2<F, E, Kind<W, B>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B>(f: (a: A) => Kind2<F, E, Option_2<B>>) => (ta: Kind<W, A>) => Kind2<F, E, Kind<W, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(f: (a: A) => Kind<F, Option_2<B>>) => (ta: Kind<W, A>) => Kind<F, Kind<W, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(f: (a: A) => HKT<F, Option_2<B>>) => (ta: Kind<W, A>) => HKT<F, Kind<W, B>>;
}

// @public (undocumented)
interface PipeableWither2<W extends URIS2> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, FE, B>(f: (a: A) => Kind3<F, R, FE, Option_2<B>>) => <WE>(ta: Kind2<W, WE, A>) => Kind3<F, R, FE, Kind2<W, WE, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, FE, B>(f: (a: A) => Kind2<F, FE, Option_2<B>>) => <WE>(ta: Kind2<W, WE, A>) => Kind2<F, FE, Kind2<W, WE, B>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <A, B>(f: (a: A) => Kind2<F, FE, Option_2<B>>) => <WE>(ta: Kind2<W, WE, A>) => Kind2<F, FE, Kind2<W, WE, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(f: (a: A) => Kind<F, Option_2<B>>) => <WE>(ta: Kind2<W, WE, A>) => Kind<F, Kind2<W, WE, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(f: (a: A) => HKT<F, Option_2<B>>) => <WE>(ta: Kind2<W, WE, A>) => HKT<F, Kind2<W, WE, B>>;
}

// @public (undocumented)
interface PipeableWither2C<W extends URIS2, WE> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, FE, B>(f: (a: A) => Kind3<F, R, FE, Option_2<B>>) => (ta: Kind2<W, WE, A>) => Kind3<F, R, FE, Kind2<W, WE, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, FE, B>(f: (a: A) => Kind2<F, FE, Option_2<B>>) => (ta: Kind2<W, WE, A>) => Kind2<F, FE, Kind2<W, WE, B>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <A, B>(f: (a: A) => Kind2<F, FE, Option_2<B>>) => (ta: Kind2<W, WE, A>) => Kind2<F, FE, Kind2<W, WE, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(f: (a: A) => Kind<F, Option_2<B>>) => (ta: Kind2<W, WE, A>) => Kind<F, Kind2<W, WE, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(f: (a: A) => HKT<F, Option_2<B>>) => (ta: Kind2<W, WE, A>) => HKT<F, Kind2<W, WE, B>>;
}

// @public (undocumented)
interface PipeableWither3<W extends URIS3> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, FR, FE, B>(f: (a: A) => Kind3<F, FR, FE, Option_2<B>>) => <WR, WE>(ta: Kind3<W, WR, WE, A>) => Kind3<F, FR, FE, Kind3<W, WR, WE, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, FE, B>(f: (a: A) => Kind2<F, FE, Option_2<B>>) => <WR, WE>(ta: Kind3<W, WR, WE, A>) => Kind2<F, FE, Kind3<W, WR, WE, B>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <A, B>(f: (a: A) => Kind2<F, FE, Option_2<B>>) => <WR, WE>(ta: Kind3<W, WR, WE, A>) => Kind2<F, FE, Kind3<W, WR, WE, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(f: (a: A) => Kind<F, Option_2<B>>) => <WR, WE>(ta: Kind3<W, WR, WE, A>) => Kind<F, Kind3<W, WR, WE, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(f: (a: A) => HKT<F, Option_2<B>>) => <WR, WE>(ta: Kind3<W, WR, WE, A>) => HKT<F, Kind3<W, WR, WE, B>>;
}

// @public (undocumented)
interface Pointed<F> {
    // (undocumented)
    readonly of: <A>(a: A) => HKT<F, A>;
    // (undocumented)
    readonly URI: F;
}

declare namespace pointed {
    export {
        Pointed,
        Pointed1,
        Pointed2,
        Pointed2C,
        Pointed3,
        Pointed3C,
        Pointed4
    }
}
export { pointed }

// @public (undocumented)
interface Pointed1<F extends URIS> {
    // (undocumented)
    readonly of: <A>(a: A) => Kind<F, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Pointed2<F extends URIS2> {
    // (undocumented)
    readonly of: <E, A>(a: A) => Kind2<F, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Pointed2C<F extends URIS2, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly of: <A>(a: A) => Kind2<F, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Pointed3<F extends URIS3> {
    // (undocumented)
    readonly of: <R, E, A>(a: A) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Pointed3C<F extends URIS3, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly of: <R, A>(a: A) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Pointed4<F extends URIS4> {
    // (undocumented)
    readonly of: <S, R, E, A>(a: A) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const Pointed_10: Pointed1<URI_14>;

// @public (undocumented)
const Pointed_11: Pointed2<URI_17>;

// @public (undocumented)
const Pointed_12: Pointed3<URI_18>;

// @public (undocumented)
const Pointed_13: Pointed2<URI_19>;

// @public (undocumented)
const Pointed_14: Pointed2<URI_20>;

// @public (undocumented)
const Pointed_15: Pointed1<URI_21>;

// @public (undocumented)
const Pointed_16: Pointed2<URI_23>;

// @public (undocumented)
const Pointed_17: Pointed3<URI_22>;

// @public (undocumented)
const Pointed_18: Pointed1<URI_24>;

// @public (undocumented)
const Pointed_19: Pointed2<URI_30>;

// @public (undocumented)
const Pointed_2: Pointed1<URI_2>;

// @public (undocumented)
const Pointed_20: Pointed4<URI_31>;

// @public (undocumented)
const Pointed_21: Pointed1<URI_33>;

// @public (undocumented)
const Pointed_22: Pointed2<URI_34>;

// @public (undocumented)
const Pointed_23: Pointed2<URI_35>;

// @public (undocumented)
const Pointed_24: Pointed1<URI_37>;

// @public (undocumented)
const Pointed_3: Pointed1<URI_3>;

// @public (undocumented)
const Pointed_4: Pointed1<URI_4>;

// @public (undocumented)
const Pointed_5: Pointed1<URI_7>;

// @public (undocumented)
const Pointed_6: Pointed2<URI_6>;

// @public (undocumented)
const Pointed_7: Pointed1<URI_11>;

// @public (undocumented)
const Pointed_8: Pointed1<URI_12>;

// @public (undocumented)
const Pointed_9: Pointed2<URI_13>;

// @public
function pop<K>(E: Eq<K>): (k: K) => <A>(m: Map<K, A>) => Option_2<[A, Map<K, A>]>;

// @public
function pop_2<K>(E: Eq<K>): (k: K) => <A>(m: ReadonlyMap<K, A>) => Option_2<readonly [A, ReadonlyMap<K, A>]>;

// @public
function pop_3<K extends string>(k: K): <KS extends string, A>(r: ReadonlyRecord<KS, A>) => Option_2<readonly [A, ReadonlyRecord<string extends K ? string : Exclude<KS, K>, A>]>;

// @public
function pop_4<K extends string>(k: K): <KS extends string, A>(r: Record<KS, A>) => Option_2<[A, Record<string extends K ? string : Exclude<KS, K>, A>]>;

// @public (undocumented)
interface Predicate<A> {
    // (undocumented)
    (a: A): boolean;
}

declare namespace predicate {
    export {
        Predicate,
        contramap_5 as contramap,
        URI_16 as URI,
        getSemigroupAny,
        getMonoidAny,
        getSemigroupAll,
        getMonoidAll,
        Contravariant_5 as Contravariant,
        not_2 as not,
        or,
        and
    }
}
export { predicate }

// @public @deprecated
interface Predicate_2<A> {
    // (undocumented)
    (a: A): boolean;
}

// @public (undocumented)
type PredicateWithIndex<I, A> = (i: I, a: A) => boolean;

// @public
const prepend: <A>(head: A) => (tail: Array<A>) => nonEmptyArray.NonEmptyArray<A>;

// @public
const prepend_2: <A>(head: A) => (tail: readonly A[]) => readonlyNonEmptyArray.ReadonlyNonEmptyArray<A>;

// @public
const prependAll: <A>(middle: A) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public
const prependAll_2: <A>(middle: A) => (as: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public
const prependAll_3: <A>(middle: A) => (as: A[]) => A[];

// @public
const prependAll_4: <A>(middle: A) => (as: readonly A[]) => readonly A[];

// @public @deprecated
const prependToAll: <A>(middle: A) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public @deprecated
const prependToAll_2: <A>(middle: A) => (as: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public @deprecated
const prependToAll_3: <A>(middle: A) => (as: A[]) => A[];

// @public @deprecated
const prependToAll_4: <A>(middle: A) => (as: readonly A[]) => readonly A[];

// @public
const prependW: <A, B>(head: B) => (tail: Array<A>) => nonEmptyArray.NonEmptyArray<A | B>;

// @public
const prependW_2: <B>(head: B) => <A>(tail: readonly A[]) => readonlyNonEmptyArray.ReadonlyNonEmptyArray<B | A>;

// @public (undocumented)
interface Profunctor<F> {
    // (undocumented)
    readonly map: <E, A, B>(fa: HKT2<F, E, A>, f: (a: A) => B) => HKT<F, B>;
    // (undocumented)
    readonly promap: <E, A, D, B>(fea: HKT2<F, E, A>, f: (d: D) => E, g: (a: A) => B) => HKT2<F, D, B>;
    // (undocumented)
    readonly URI: F;
}

declare namespace profunctor {
    export {
        Profunctor,
        Profunctor2,
        Profunctor2C,
        Profunctor3,
        Profunctor3C,
        Profunctor4
    }
}
export { profunctor }

// @public (undocumented)
interface Profunctor2<F extends URIS2> extends Functor2<F> {
    // (undocumented)
    readonly promap: <E, A, D, B>(fea: Kind2<F, E, A>, f: (d: D) => E, g: (a: A) => B) => Kind2<F, D, B>;
}

// @public (undocumented)
interface Profunctor2C<F extends URIS2, E> extends Functor2C<F, E> {
    // (undocumented)
    readonly promap: <A, D, B>(fea: Kind2<F, E, A>, f: (d: D) => E, g: (a: A) => B) => Kind2<F, D, B>;
}

// @public (undocumented)
interface Profunctor3<F extends URIS3> extends Functor3<F> {
    // (undocumented)
    readonly promap: <R, E, A, D, B>(fea: Kind3<F, R, E, A>, f: (d: D) => E, g: (a: A) => B) => Kind3<F, R, D, B>;
}

// @public (undocumented)
interface Profunctor3C<F extends URIS3, E> extends Functor3C<F, E> {
    // (undocumented)
    readonly promap: <R, A, D, B>(fea: Kind3<F, R, E, A>, f: (d: D) => E, g: (a: A) => B) => Kind3<F, R, D, B>;
}

// @public (undocumented)
interface Profunctor4<F extends URIS4> extends Functor4<F> {
    // (undocumented)
    readonly promap: <S, R, E, A, D, B>(fea: Kind4<F, S, R, E, A>, f: (d: D) => E, g: (a: A) => B) => Kind4<F, S, R, D, B>;
}

// @public (undocumented)
const Profunctor_2: Profunctor2<URI_17>;

// @public
function promap<F extends URIS4>(F: Profunctor4<F>): <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => <S, R>(fbc: Kind4<F, S, R, E, A>) => Kind4<F, S, R, D, B>;

// @public (undocumented)
function promap<F extends URIS3>(F: Profunctor3<F>): <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => <R>(fbc: Kind3<F, R, E, A>) => Kind3<F, R, D, B>;

// @public (undocumented)
function promap<F extends URIS3, E>(F: Profunctor3C<F, E>): <A, D, B>(f: (d: D) => E, g: (a: A) => B) => <R>(fbc: Kind3<F, R, E, A>) => Kind3<F, R, D, B>;

// @public (undocumented)
function promap<F extends URIS2>(F: Profunctor2<F>): <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Kind2<F, E, A>) => Kind2<F, D, B>;

// @public (undocumented)
function promap<F extends URIS2, E>(F: Profunctor2C<F, E>): <A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Kind2<F, E, A>) => Kind2<F, D, B>;

// @public (undocumented)
function promap<F>(F: Profunctor<F>): <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: HKT2<F, E, A>) => HKT2<F, D, B>;

// @public (undocumented)
const promap_2: <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fea: Reader<E, A>) => Reader<D, B>;

// @public (undocumented)
function put<F extends URIS4>(F: FromState4<F>): <S, R, E>(s: S) => Kind4<F, S, R, E, void>;

// @public (undocumented)
function put<F extends URIS3>(F: FromState3<F>): <S, E>(s: S) => Kind3<F, S, E, void>;

// @public (undocumented)
function put<F extends URIS3, E>(F: FromState3C<F, E>): <S>(s: S) => Kind3<F, S, E, void>;

// @public (undocumented)
function put<F extends URIS2>(F: FromState2<F>): <S>(s: S) => Kind2<F, S, void>;

// @public (undocumented)
function put<F>(F: FromState<F>): <S>(s: S) => HKT2<F, S, void>;

// @public
const put_2: <S>(s: S) => State<S, void>;

// @public
const put_3: <S, R, E = never>(s: S) => StateReaderTaskEither<S, R, E, void>;

declare namespace random {
    export {
        randomInt,
        randomRange,
        random_2 as random,
        randomBool,
        randomElem
    }
}
export { random }

// @public
const random_2: IO<number>;

// @public
const randomBool: IO<boolean>;

// @public
const randomElem: <A>(as: ReadonlyNonEmptyArray<A>) => IO<A>;

// @public
function randomInt(low: number, high: number): IO<number>;

// @public
function randomRange(min: number, max: number): IO<number>;

// @public
const range: (start: number, end: number) => ReadonlyNonEmptyArray<number>;

// @public
const range_2: (start: number, end: number) => NonEmptyArray<number>;

// @public @deprecated
const range_3: (start: number, end: number) => nonEmptyArray.NonEmptyArray<number>;

// @public @deprecated
const range_4: (start: number, end: number) => readonlyNonEmptyArray.ReadonlyNonEmptyArray<number>;

// @public (undocumented)
interface Reader<R, A> {
    // (undocumented)
    (r: R): A;
}

declare namespace reader {
    export {
        Reader,
        ask_2 as ask,
        asks_2 as asks,
        local,
        asksReaderW,
        asksReader,
        map_18 as map,
        apW_3 as apW,
        ap_14 as ap,
        of_10 as of,
        flatMap_10 as flatMap,
        flattenW_3 as flattenW,
        flatten_10 as flatten,
        compose_2 as compose,
        promap_2 as promap,
        id,
        first_2 as first,
        second,
        left_5 as left,
        right_5 as right,
        URI_17 as URI,
        Functor_14 as Functor,
        flap_14 as flap,
        Pointed_11 as Pointed,
        Apply_10 as Apply,
        apFirst_11 as apFirst,
        apFirstW_3 as apFirstW,
        apSecond_11 as apSecond,
        apSecondW_3 as apSecondW,
        Applicative_11 as Applicative,
        Chain_11 as Chain,
        chainRec_7 as chainRec,
        ChainRec_8 as ChainRec,
        Monad_11 as Monad,
        tap_6 as tap,
        Profunctor_2 as Profunctor,
        Category_2 as Category,
        Strong,
        Choice_2 as Choice,
        bindTo_11 as bindTo,
        let__11 as let,
        bind_11 as bind,
        bindW_3 as bindW,
        Do_10 as Do,
        apS_11 as apS,
        apSW_3 as apSW,
        ApT_6 as ApT,
        do__7 as do,
        traverseReadonlyNonEmptyArrayWithIndex_6 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_6 as traverseReadonlyArrayWithIndex,
        traverseArrayWithIndex_5 as traverseArrayWithIndex,
        traverseArray_5 as traverseArray,
        sequenceArray_5 as sequenceArray,
        chainW_3 as chainW,
        chain_14 as chain,
        chainFirst_11 as chainFirst,
        chainFirstW_3 as chainFirstW,
        reader_2 as reader,
        getSemigroup_12 as getSemigroup,
        getMonoid_10 as getMonoid
    }
}
export { reader }

// @public @deprecated
const reader_2: Monad2<URI_17> & Profunctor2<URI_17> & Category2<URI_17> & Strong2<URI_17> & Choice2<URI_17>;

// @public (undocumented)
interface ReaderEither<R, E, A> extends Reader<R, Either<E, A>> {
}

declare namespace readerEither {
    export {
        getFilterable_3 as getFilterable,
        getApplicativeReaderValidation,
        getAltReaderValidation,
        getReaderValidation,
        ReaderEither,
        left_6 as left,
        right_6 as right,
        rightReader,
        leftReader,
        fromEither_7 as fromEither,
        fromReader_2 as fromReader,
        match_10 as match,
        matchW_8 as matchW,
        matchE_5 as matchE,
        fold_10 as fold,
        matchEW_3 as matchEW,
        foldW_5 as foldW,
        getOrElse_7 as getOrElse,
        getOrElseW_5 as getOrElseW,
        toUnion_4 as toUnion,
        local_2 as local,
        asksReaderEitherW,
        asksReaderEither,
        orElse_5 as orElse,
        orElseW_3 as orElseW,
        tapError_2 as tapError,
        orLeft_3 as orLeft,
        swap_4 as swap,
        map_19 as map,
        mapBoth_2 as mapBoth,
        bimap_7 as bimap,
        mapError_2 as mapError,
        mapLeft_7 as mapLeft,
        ap_15 as ap,
        apW_4 as apW,
        of_11 as of,
        flatMap_11 as flatMap,
        flattenW_4 as flattenW,
        flatten_11 as flatten,
        alt_13 as alt,
        altW_9 as altW,
        throwError_5 as throwError,
        URI_18 as URI,
        getCompactable_3 as getCompactable,
        Functor_15 as Functor,
        as_6 as as,
        asUnit_6 as asUnit,
        flap_15 as flap,
        Pointed_12 as Pointed,
        Apply_11 as Apply,
        apFirst_12 as apFirst,
        apFirstW_4 as apFirstW,
        apSecond_12 as apSecond,
        apSecondW_4 as apSecondW,
        Applicative_12 as Applicative,
        Chain_12 as Chain,
        chainRec_8 as chainRec,
        ChainRec_9 as ChainRec,
        Monad_12 as Monad,
        FromEither_7 as FromEither,
        FromReader_2 as FromReader,
        tap_7 as tap,
        tapEither_4 as tapEither,
        tapReader_2 as tapReader,
        Bifunctor_6 as Bifunctor,
        Alt_10 as Alt,
        ask_3 as ask,
        asks_3 as asks,
        fromReaderK_2 as fromReaderK,
        chainFirstReaderK_2 as chainFirstReaderK,
        chainFirstReaderKW,
        MonadThrow_6 as MonadThrow,
        fromOption_6 as fromOption,
        fromOptionK_7 as fromOptionK,
        chainOptionK_6 as chainOptionK,
        chainOptionKW_3 as chainOptionKW,
        liftNullable_3 as liftNullable,
        liftOption_3 as liftOption,
        flatMapNullable_4 as flatMapNullable,
        flatMapOption_4 as flatMapOption,
        flatMapEither_3 as flatMapEither,
        flatMapReader,
        chainEitherK_5 as chainEitherK,
        chainEitherKW_2 as chainEitherKW,
        chainFirstEitherK_5 as chainFirstEitherK,
        chainFirstEitherKW_2 as chainFirstEitherKW,
        chainReaderK_2 as chainReaderK,
        chainReaderKW,
        fromPredicate_8 as fromPredicate,
        filterOrElse_4 as filterOrElse,
        filterOrElseW_3 as filterOrElseW,
        fromEitherK_6 as fromEitherK,
        Do_11 as Do,
        bindTo_12 as bindTo,
        let__12 as let,
        bind_12 as bind,
        bindW_4 as bindW,
        apS_12 as apS,
        apSW_4 as apSW,
        ApT_7 as ApT,
        do__8 as do,
        traverseReadonlyNonEmptyArrayWithIndex_7 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_7 as traverseReadonlyArrayWithIndex,
        traverseArrayWithIndex_6 as traverseArrayWithIndex,
        traverseArray_6 as traverseArray,
        sequenceArray_6 as sequenceArray,
        chain_15 as chain,
        chainW_4 as chainW,
        chainFirst_12 as chainFirst,
        chainFirstW_4 as chainFirstW,
        orElseFirst_3 as orElseFirst,
        orElseFirstW_2 as orElseFirstW,
        readerEither_2 as readerEither,
        getApplySemigroup_5 as getApplySemigroup,
        getApplyMonoid_4 as getApplyMonoid,
        getSemigroup_13 as getSemigroup
    }
}
export { readerEither }

// @public @deprecated
const readerEither_2: Monad3<URI_18> & Bifunctor3<URI_18> & Alt3<URI_18> & MonadThrow3<URI_18>;

// @public (undocumented)
interface ReaderIO<R, A> {
    // (undocumented)
    (r: R): io.IO<A>;
}

declare namespace readerIO {
    export {
        ReaderIO,
        fromReader_3 as fromReader,
        fromIO_5 as fromIO,
        local_3 as local,
        asksReaderIOW,
        asksReaderIO,
        map_20 as map,
        ap_16 as ap,
        apW_5 as apW,
        of_12 as of,
        flatMap_12 as flatMap,
        flattenW_5 as flattenW,
        flatten_12 as flatten,
        URI_19 as URI,
        Functor_16 as Functor,
        as_7 as as,
        asUnit_7 as asUnit,
        flap_16 as flap,
        Pointed_13 as Pointed,
        Apply_12 as Apply,
        apFirst_13 as apFirst,
        apSecond_13 as apSecond,
        Applicative_13 as Applicative,
        Chain_13 as Chain,
        chainRec_9 as chainRec,
        ChainRec_10 as ChainRec,
        Monad_13 as Monad,
        MonadIO_5 as MonadIO,
        FromIO_5 as FromIO,
        FromReader_3 as FromReader,
        flatMapIO_3 as flatMapIO,
        flatMapReader_2 as flatMapReader,
        tap_8 as tap,
        tapIO_3 as tapIO,
        tapReader_3 as tapReader,
        fromIOK_4 as fromIOK,
        chainIOK_4 as chainIOK,
        chainFirstIOK_4 as chainFirstIOK,
        ask_4 as ask,
        asks_4 as asks,
        fromReaderK_3 as fromReaderK,
        chainReaderK_3 as chainReaderK,
        chainReaderKW_2 as chainReaderKW,
        chainFirstReaderK_3 as chainFirstReaderK,
        chainFirstReaderKW_2 as chainFirstReaderKW,
        Do_12 as Do,
        bindTo_13 as bindTo,
        bind_13 as bind,
        bindW_5 as bindW,
        apS_13 as apS,
        apSW_5 as apSW,
        ApT_8 as ApT,
        do__9 as do,
        traverseReadonlyNonEmptyArrayWithIndex_8 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_8 as traverseReadonlyArrayWithIndex,
        traverseArrayWithIndex_7 as traverseArrayWithIndex,
        traverseArray_7 as traverseArray,
        sequenceArray_7 as sequenceArray,
        chain_16 as chain,
        chainW_5 as chainW,
        chainFirst_13 as chainFirst,
        chainFirstW_5 as chainFirstW
    }
}
export { readerIO }

// @public @deprecated (undocumented)
interface ReaderM<M> {
    // (undocumented)
    readonly ap: <R, A, B>(mab: ReaderT<M, R, (a: A) => B>, ma: ReaderT<M, R, A>) => ReaderT<M, R, B>;
    // (undocumented)
    readonly ask: <R>() => ReaderT<M, R, R>;
    // (undocumented)
    readonly asks: <R, A>(f: (r: R) => A) => ReaderT<M, R, A>;
    // (undocumented)
    readonly chain: <R, A, B>(ma: ReaderT<M, R, A>, f: (a: A) => ReaderT<M, R, B>) => ReaderT<M, R, B>;
    // (undocumented)
    readonly fromM: <R, A>(ma: HKT<M, A>) => ReaderT<M, R, A>;
    // (undocumented)
    readonly fromReader: <R, A>(ma: Reader<R, A>) => ReaderT<M, R, A>;
    // (undocumented)
    readonly local: <R1, A, R2>(ma: ReaderT<M, R1, A>, f: (d: R2) => R1) => ReaderT<M, R2, A>;
    // (undocumented)
    readonly map: <R, A, B>(ma: ReaderT<M, R, A>, f: (a: A) => B) => ReaderT<M, R, B>;
    // (undocumented)
    readonly of: <R, A>(a: A) => ReaderT<M, R, A>;
}

// @public @deprecated (undocumented)
interface ReaderM1<M extends URIS> {
    // (undocumented)
    readonly ap: <R, A, B>(mab: ReaderT1<M, R, (a: A) => B>, ma: ReaderT1<M, R, A>) => ReaderT1<M, R, B>;
    // (undocumented)
    readonly ask: <R>() => ReaderT1<M, R, R>;
    // (undocumented)
    readonly asks: <R, A>(f: (r: R) => A) => ReaderT1<M, R, A>;
    // (undocumented)
    readonly chain: <R, A, B>(ma: ReaderT1<M, R, A>, f: (a: A) => ReaderT1<M, R, B>) => ReaderT1<M, R, B>;
    // (undocumented)
    readonly fromM: <R, A>(ma: Kind<M, A>) => ReaderT1<M, R, A>;
    // (undocumented)
    readonly fromReader: <R, A>(ma: Reader<R, A>) => ReaderT1<M, R, A>;
    // (undocumented)
    readonly local: <R1, A, R2>(ma: ReaderT1<M, R1, A>, f: (d: R2) => R1) => ReaderT1<M, R2, A>;
    // (undocumented)
    readonly map: <R, A, B>(ma: ReaderT1<M, R, A>, f: (a: A) => B) => ReaderT1<M, R, B>;
    // (undocumented)
    readonly of: <R, A>(a: A) => ReaderT1<M, R, A>;
}

// @public @deprecated (undocumented)
interface ReaderM2<M extends URIS2> {
    // (undocumented)
    readonly ap: <R, E, A, B>(mab: ReaderT2<M, R, E, (a: A) => B>, ma: ReaderT2<M, R, E, A>) => ReaderT2<M, R, E, B>;
    // (undocumented)
    readonly ask: <R, E>() => ReaderT2<M, R, E, R>;
    // (undocumented)
    readonly asks: <R, E, A>(f: (r: R) => A) => ReaderT2<M, R, E, A>;
    // (undocumented)
    readonly chain: <R, E, A, B>(ma: ReaderT2<M, R, E, A>, f: (a: A) => ReaderT2<M, R, E, B>) => ReaderT2<M, R, E, B>;
    // (undocumented)
    readonly fromM: <R, E, A>(ma: Kind2<M, E, A>) => ReaderT2<M, R, E, A>;
    // (undocumented)
    readonly fromReader: <R, E, A>(ma: Reader<R, A>) => ReaderT2<M, R, E, A>;
    // (undocumented)
    readonly local: <R1, E, A, R2>(ma: ReaderT2<M, R1, E, A>, f: (d: R2) => R1) => ReaderT2<M, R2, E, A>;
    // (undocumented)
    readonly map: <R, E, A, B>(ma: ReaderT2<M, R, E, A>, f: (a: A) => B) => ReaderT2<M, R, E, B>;
    // (undocumented)
    readonly of: <R, E, A>(a: A) => ReaderT2<M, R, E, A>;
}

// @public @deprecated (undocumented)
interface ReaderM2C<M extends URIS2, E> {
    // (undocumented)
    readonly ap: <R, A, B>(mab: ReaderT2<M, R, E, (a: A) => B>, ma: ReaderT2<M, R, E, A>) => ReaderT2<M, R, E, B>;
    // (undocumented)
    readonly ask: <R>() => ReaderT2<M, R, E, R>;
    // (undocumented)
    readonly asks: <R, A>(f: (r: R) => A) => ReaderT2<M, R, E, A>;
    // (undocumented)
    readonly chain: <R, A, B>(ma: ReaderT2<M, R, E, A>, f: (a: A) => ReaderT2<M, R, E, B>) => ReaderT2<M, R, E, B>;
    // (undocumented)
    readonly fromM: <R, A>(ma: Kind2<M, E, A>) => ReaderT2<M, R, E, A>;
    // (undocumented)
    readonly fromReader: <R, A>(ma: Reader<R, A>) => ReaderT2<M, R, E, A>;
    // (undocumented)
    readonly local: <R1, A, R2>(ma: ReaderT2<M, R1, E, A>, f: (d: R2) => R1) => ReaderT2<M, R2, E, A>;
    // (undocumented)
    readonly map: <R, A, B>(ma: ReaderT2<M, R, E, A>, f: (a: A) => B) => ReaderT2<M, R, E, B>;
    // (undocumented)
    readonly of: <R, A>(a: A) => ReaderT2<M, R, E, A>;
}

// @public @deprecated (undocumented)
interface ReaderM3<M extends URIS3> {
    // (undocumented)
    readonly ap: <R, U, E, A, B>(mab: ReaderT3<M, R, U, E, (a: A) => B>, ma: ReaderT3<M, R, U, E, A>) => ReaderT3<M, R, U, E, B>;
    // (undocumented)
    readonly ask: <R, U, E>() => ReaderT3<M, R, U, E, R>;
    // (undocumented)
    readonly asks: <R, U, E, A>(f: (r: R) => A) => ReaderT3<M, R, U, E, A>;
    // (undocumented)
    readonly chain: <R, U, E, A, B>(ma: ReaderT3<M, R, U, E, A>, f: (a: A) => ReaderT3<M, R, U, E, B>) => ReaderT3<M, R, U, E, B>;
    // (undocumented)
    readonly fromM: <R, U, E, A>(ma: Kind3<M, U, E, A>) => ReaderT3<M, R, U, E, A>;
    // (undocumented)
    readonly fromReader: <R, U, E, A>(ma: Reader<R, A>) => ReaderT3<M, R, U, E, A>;
    // (undocumented)
    readonly local: <R1, U, E, A, R2>(ma: ReaderT3<M, R1, U, E, A>, f: (d: R2) => R1) => ReaderT3<M, R2, U, E, A>;
    // (undocumented)
    readonly map: <R, U, E, A, B>(ma: ReaderT3<M, R, U, E, A>, f: (a: A) => B) => ReaderT3<M, R, U, E, B>;
    // (undocumented)
    readonly of: <R, U, E, A>(a: A) => ReaderT3<M, R, U, E, A>;
}

// @public @deprecated (undocumented)
interface ReaderT<M, R, A> {
    // (undocumented)
    (r: R): HKT<M, A>;
}

declare namespace readerT {
    export {
        of_13 as of,
        map_21 as map,
        ap_17 as ap,
        chain_17 as chain,
        fromReader_4 as fromReader,
        fromNaturalTransformation,
        getReaderM,
        ReaderT,
        ReaderM,
        ReaderT1,
        ReaderM1,
        ReaderT2,
        ReaderM2,
        ReaderM2C,
        ReaderT3,
        ReaderM3
    }
}
export { readerT }

// @public @deprecated (undocumented)
interface ReaderT1<M extends URIS, R, A> {
    // (undocumented)
    (r: R): Kind<M, A>;
}

// @public @deprecated (undocumented)
interface ReaderT2<M extends URIS2, R, E, A> {
    // (undocumented)
    (r: R): Kind2<M, E, A>;
}

// @public @deprecated (undocumented)
interface ReaderT3<M extends URIS3, R, U, E, A> {
    // (undocumented)
    (r: R): Kind3<M, U, E, A>;
}

// @public (undocumented)
interface ReaderTask<R, A> {
    // (undocumented)
    (r: R): Task<A>;
}

declare namespace readerTask {
    export {
        run,
        ReaderTask,
        fromReader_5 as fromReader,
        fromTask_2 as fromTask,
        fromIO_6 as fromIO,
        fromReaderIO,
        local_4 as local,
        asksReaderTaskW,
        asksReaderTask,
        map_22 as map,
        ap_18 as ap,
        apW_6 as apW,
        of_14 as of,
        flatMap_13 as flatMap,
        flattenW_6 as flattenW,
        flatten_13 as flatten,
        URI_20 as URI,
        Functor_17 as Functor,
        as_8 as as,
        asUnit_8 as asUnit,
        flap_17 as flap,
        Pointed_14 as Pointed,
        ApplyPar_2 as ApplyPar,
        apFirst_14 as apFirst,
        apSecond_14 as apSecond,
        ApplicativePar_2 as ApplicativePar,
        ApplySeq,
        ApplicativeSeq_2 as ApplicativeSeq,
        Chain_14 as Chain,
        chainRec_10 as chainRec,
        ChainRec_11 as ChainRec,
        Monad_14 as Monad,
        MonadIO_6 as MonadIO,
        MonadTask_2 as MonadTask,
        FromIO_6 as FromIO,
        FromTask_2 as FromTask,
        FromReader_4 as FromReader,
        flatMapIO_4 as flatMapIO,
        flatMapTask,
        flatMapReader_3 as flatMapReader,
        flatMapReaderIO,
        tap_9 as tap,
        tapIO_4 as tapIO,
        tapReader_4 as tapReader,
        tapTask,
        tapReaderIO,
        fromIOK_5 as fromIOK,
        chainIOK_5 as chainIOK,
        chainFirstIOK_5 as chainFirstIOK,
        ask_5 as ask,
        asks_5 as asks,
        fromReaderK_4 as fromReaderK,
        chainReaderK_4 as chainReaderK,
        chainReaderKW_3 as chainReaderKW,
        chainFirstReaderK_4 as chainFirstReaderK,
        chainFirstReaderKW_3 as chainFirstReaderKW,
        fromReaderIOK,
        chainReaderIOKW,
        chainReaderIOK,
        chainFirstReaderIOKW,
        chainFirstReaderIOK,
        fromTaskK_2 as fromTaskK,
        chainTaskK_2 as chainTaskK,
        chainFirstTaskK_2 as chainFirstTaskK,
        Do_14 as Do,
        bindTo_15 as bindTo,
        let__14 as let,
        bind_15 as bind,
        bindW_6 as bindW,
        apS_15 as apS,
        apSW_6 as apSW,
        ApT_10 as ApT,
        do__11 as do,
        traverseReadonlyNonEmptyArrayWithIndex_10 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_10 as traverseReadonlyArrayWithIndex,
        traverseReadonlyNonEmptyArrayWithIndexSeq_3 as traverseReadonlyNonEmptyArrayWithIndexSeq,
        traverseReadonlyArrayWithIndexSeq_3 as traverseReadonlyArrayWithIndexSeq,
        traverseArrayWithIndex_9 as traverseArrayWithIndex,
        traverseArray_9 as traverseArray,
        sequenceArray_9 as sequenceArray,
        traverseSeqArrayWithIndex_3 as traverseSeqArrayWithIndex,
        traverseSeqArray_3 as traverseSeqArray,
        chain_19 as chain,
        chainW_6 as chainW,
        chainFirst_15 as chainFirst,
        chainFirstW_6 as chainFirstW,
        sequenceSeqArray_3 as sequenceSeqArray,
        readerTask_2 as readerTask,
        readerTaskSeq,
        getSemigroup_15 as getSemigroup,
        getMonoid_12 as getMonoid
    }
}
export { readerTask }

// @public @deprecated
const readerTask_2: MonadTask2<URI_20>;

// @public (undocumented)
interface ReaderTaskEither<R, E, A> {
    // (undocumented)
    (r: R): TaskEither<E, A>;
}

declare namespace readerTaskEither {
    export {
        getFilterable_4 as getFilterable,
        getApplicativeReaderTaskValidation,
        getAltReaderTaskValidation,
        bracket_2 as bracket,
        bracketW_2 as bracketW,
        getReaderTaskValidation,
        run_2 as run,
        ReaderTaskEither,
        fromTaskEither,
        left_7 as left,
        right_7 as right,
        rightTask,
        leftTask,
        rightReader_2 as rightReader,
        leftReader_2 as leftReader,
        rightReaderTask,
        leftReaderTask,
        rightIO_2 as rightIO,
        leftIO_2 as leftIO,
        rightReaderIO,
        leftReaderIO,
        fromEither_8 as fromEither,
        fromReader_6 as fromReader,
        fromIO_8 as fromIO,
        fromTask_4 as fromTask,
        fromIOEither_2 as fromIOEither,
        fromReaderEither,
        match_11 as match,
        matchW_9 as matchW,
        matchE_6 as matchE,
        fold_11 as fold,
        matchEW_4 as matchEW,
        foldW_6 as foldW,
        getOrElse_8 as getOrElse,
        getOrElseW_6 as getOrElseW,
        toUnion_5 as toUnion,
        fromNullable_6 as fromNullable,
        fromNullableK_6 as fromNullableK,
        chainNullableK_6 as chainNullableK,
        local_5 as local,
        asksReaderTaskEitherW,
        asksReaderTaskEither,
        orElse_6 as orElse,
        orElseW_4 as orElseW,
        tapError_3 as tapError,
        orLeft_4 as orLeft,
        swap_5 as swap,
        fromIOEitherK,
        fromTaskEitherK,
        fromReaderEitherK,
        map_25 as map,
        mapBoth_4 as mapBoth,
        bimap_9 as bimap,
        mapError_4 as mapError,
        mapLeft_9 as mapLeft,
        ap_21 as ap,
        apW_8 as apW,
        of_17 as of,
        flatMap_16 as flatMap,
        flattenW_8 as flattenW,
        flatten_16 as flatten,
        alt_15 as alt,
        altW_11 as altW,
        throwError_7 as throwError,
        URI_22 as URI,
        getCompactable_5 as getCompactable,
        Functor_20 as Functor,
        as_11 as as,
        asUnit_11 as asUnit,
        flap_20 as flap,
        Pointed_17 as Pointed,
        ApplyPar_5 as ApplyPar,
        apFirst_17 as apFirst,
        apFirstW_6 as apFirstW,
        apSecond_17 as apSecond,
        apSecondW_6 as apSecondW,
        ApplicativePar_5 as ApplicativePar,
        ApplySeq_4 as ApplySeq,
        ApplicativeSeq_5 as ApplicativeSeq,
        Chain_17 as Chain,
        chainRec_13 as chainRec,
        ChainRec_14 as ChainRec,
        Monad_17 as Monad,
        MonadIO_9 as MonadIO,
        MonadTask_5 as MonadTask,
        MonadThrow_8 as MonadThrow,
        FromEither_9 as FromEither,
        FromIO_9 as FromIO,
        FromTask_5 as FromTask,
        FromReader_5 as FromReader,
        tap_12 as tap,
        tapEither_6 as tapEither,
        tapIO_7 as tapIO,
        tapTask_3 as tapTask,
        tapReader_5 as tapReader,
        tapReaderEither,
        tapTaskEither,
        tapReaderTask,
        tapReaderIO_2 as tapReaderIO,
        Bifunctor_8 as Bifunctor,
        Alt_12 as Alt,
        ask_6 as ask,
        asks_6 as asks,
        fromReaderK_5 as fromReaderK,
        chainFirstReaderK_5 as chainFirstReaderK,
        chainFirstReaderKW_4 as chainFirstReaderKW,
        chainFirstReaderEitherKW,
        chainFirstReaderEitherK,
        chainFirstTaskEitherKW,
        chainFirstTaskEitherK,
        fromReaderTaskK,
        chainFirstReaderTaskKW,
        chainFirstReaderTaskK,
        fromReaderIOK_2 as fromReaderIOK,
        chainFirstReaderIOKW_2 as chainFirstReaderIOKW,
        chainFirstReaderIOK_2 as chainFirstReaderIOK,
        fromOption_8 as fromOption,
        fromOptionK_9 as fromOptionK,
        chainOptionK_8 as chainOptionK,
        chainOptionKW_5 as chainOptionKW,
        liftNullable_5 as liftNullable,
        liftOption_5 as liftOption,
        flatMapNullable_6 as flatMapNullable,
        flatMapOption_6 as flatMapOption,
        flatMapEither_5 as flatMapEither,
        flatMapTaskEither,
        flatMapReaderTask,
        flatMapIO_7 as flatMapIO,
        flatMapTask_3 as flatMapTask,
        flatMapReader_4 as flatMapReader,
        flatMapReaderIO_2 as flatMapReaderIO,
        flatMapIOEither_2 as flatMapIOEither,
        flatMapReaderEither,
        chainEitherK_7 as chainEitherK,
        chainEitherKW_4 as chainEitherKW,
        chainFirstEitherK_7 as chainFirstEitherK,
        chainFirstEitherKW_4 as chainFirstEitherKW,
        chainTaskEitherKW,
        chainTaskEitherK,
        chainReaderTaskKW,
        chainReaderTaskK,
        fromPredicate_10 as fromPredicate,
        filterOrElse_6 as filterOrElse,
        filterOrElseW_5 as filterOrElseW,
        fromEitherK_8 as fromEitherK,
        fromIOK_8 as fromIOK,
        chainIOK_8 as chainIOK,
        chainFirstIOK_8 as chainFirstIOK,
        fromTaskK_4 as fromTaskK,
        chainTaskK_4 as chainTaskK,
        chainFirstTaskK_4 as chainFirstTaskK,
        chainReaderK_5 as chainReaderK,
        chainReaderKW_4 as chainReaderKW,
        chainReaderIOKW_2 as chainReaderIOKW,
        chainReaderIOK_2 as chainReaderIOK,
        chainIOEitherKW_2 as chainIOEitherKW,
        chainIOEitherK_2 as chainIOEitherK,
        chainReaderEitherKW,
        chainReaderEitherK,
        Do_16 as Do,
        bindTo_17 as bindTo,
        let__16 as let,
        bind_17 as bind,
        bindW_8 as bindW,
        apS_17 as apS,
        apSW_8 as apSW,
        ApT_12 as ApT,
        do__13 as do,
        traverseReadonlyNonEmptyArrayWithIndex_12 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_12 as traverseReadonlyArrayWithIndex,
        traverseReadonlyNonEmptyArrayWithIndexSeq_5 as traverseReadonlyNonEmptyArrayWithIndexSeq,
        traverseReadonlyArrayWithIndexSeq_5 as traverseReadonlyArrayWithIndexSeq,
        traverseArrayWithIndex_11 as traverseArrayWithIndex,
        traverseArray_11 as traverseArray,
        sequenceArray_11 as sequenceArray,
        traverseSeqArrayWithIndex_5 as traverseSeqArrayWithIndex,
        traverseSeqArray_5 as traverseSeqArray,
        sequenceSeqArray_5 as sequenceSeqArray,
        chain_21 as chain,
        chainW_8 as chainW,
        chainFirst_17 as chainFirst,
        chainFirstW_8 as chainFirstW,
        orElseFirst_5 as orElseFirst,
        orElseFirstW_4 as orElseFirstW,
        readerTaskEither_2 as readerTaskEither,
        readerTaskEitherSeq,
        getApplySemigroup_7 as getApplySemigroup,
        getApplyMonoid_6 as getApplyMonoid,
        getSemigroup_17 as getSemigroup
    }
}
export { readerTaskEither }

// @public @deprecated
const readerTaskEither_2: Monad3<URI_22> & Bifunctor3<URI_22> & Alt3<URI_22> & MonadTask3<URI_22> & MonadThrow3<URI_22>;

// @public @deprecated
const readerTaskEitherSeq: typeof readerTaskEither_2;

// @public @deprecated
const readerTaskSeq: typeof readerTask_2;

declare namespace readonlyArray {
    export {
        fromPredicate_11 as fromPredicate,
        lookup_3 as lookup,
        takeLeftWhile_2 as takeLeftWhile,
        spanLeft_2 as spanLeft,
        dropLeftWhile_2 as dropLeftWhile,
        findFirst_2 as findFirst,
        findLast_2 as findLast,
        zip_4 as zip,
        elem_5 as elem,
        comprehension_2 as comprehension,
        union_5 as union,
        intersection_3 as intersection,
        difference_3 as difference,
        every_2 as every,
        isEmpty_3 as isEmpty,
        isNonEmpty_2 as isNonEmpty,
        prepend_2 as prepend,
        prependW_2 as prependW,
        append_2 as append,
        appendW_2 as appendW,
        makeBy_4 as makeBy,
        replicate_4 as replicate,
        fromOption_9 as fromOption,
        fromEither_10 as fromEither,
        matchW_11 as matchW,
        match_13 as match,
        matchLeftW_2 as matchLeftW,
        matchLeft_4 as matchLeft,
        foldLeft_2 as foldLeft,
        matchRightW_2 as matchRightW,
        matchRight_4 as matchRight,
        foldRight_2 as foldRight,
        chainWithIndex_4 as chainWithIndex,
        scanLeft_2 as scanLeft,
        scanRight_2 as scanRight,
        size_3 as size,
        isOutOfBound_2 as isOutOfBound,
        head_4 as head,
        last_5 as last,
        tail_4 as tail,
        init_4 as init,
        takeLeft_2 as takeLeft,
        takeRight_2 as takeRight,
        Spanned_2 as Spanned,
        dropLeft_2 as dropLeft,
        dropRight_2 as dropRight,
        findIndex_2 as findIndex,
        findFirstMap_2 as findFirstMap,
        findLastMap_2 as findLastMap,
        findLastIndex_2 as findLastIndex,
        insertAt_5 as insertAt,
        updateAt_5 as updateAt,
        deleteAt_3 as deleteAt,
        modifyAt_5 as modifyAt,
        reverse_11 as reverse,
        rights_2 as rights,
        lefts_2 as lefts,
        sort_4 as sort,
        zipWith_4 as zipWith,
        unzip_4 as unzip,
        prependAll_4 as prependAll,
        intersperse_4 as intersperse,
        rotate_4 as rotate,
        uniq_4 as uniq,
        sortBy_4 as sortBy,
        chop_4 as chop,
        splitAt_4 as splitAt,
        chunksOf_4 as chunksOf,
        fromOptionK_10 as fromOptionK,
        concatW_4 as concatW,
        concat_4 as concat,
        of_18 as of,
        zero_6 as zero,
        altW_12 as altW,
        alt_16 as alt,
        ap_22 as ap,
        flatMap_17 as flatMap,
        flatten_17 as flatten,
        map_26 as map,
        mapWithIndex_7 as mapWithIndex,
        separate_6 as separate,
        filter_9 as filter,
        filterMapWithIndex_4 as filterMapWithIndex,
        filterMap_7 as filterMap,
        compact_6 as compact,
        partition_7 as partition,
        partitionWithIndex_4 as partitionWithIndex,
        partitionMap_7 as partitionMap,
        partitionMapWithIndex_4 as partitionMapWithIndex,
        filterWithIndex_6 as filterWithIndex,
        extend_9 as extend,
        duplicate_7 as duplicate,
        foldMapWithIndex_7 as foldMapWithIndex,
        reduce_10 as reduce,
        foldMap_10 as foldMap,
        reduceWithIndex_7 as reduceWithIndex,
        reduceRight_10 as reduceRight,
        reduceRightWithIndex_7 as reduceRightWithIndex,
        traverse_7 as traverse,
        sequence_7 as sequence,
        traverseWithIndex_4 as traverseWithIndex,
        wither_3 as wither,
        wilt_3 as wilt,
        unfold_2 as unfold,
        URI_24 as URI,
        getShow_9 as getShow,
        getSemigroup_18 as getSemigroup,
        getMonoid_13 as getMonoid,
        getEq_9 as getEq,
        getOrd_4 as getOrd,
        getUnionSemigroup_5 as getUnionSemigroup,
        getUnionMonoid_3 as getUnionMonoid,
        getIntersectionSemigroup_3 as getIntersectionSemigroup,
        getDifferenceMagma_3 as getDifferenceMagma,
        Functor_21 as Functor,
        flap_21 as flap,
        Pointed_18 as Pointed,
        FunctorWithIndex_5 as FunctorWithIndex,
        Apply_13 as Apply,
        apFirst_18 as apFirst,
        apSecond_18 as apSecond,
        Applicative_14 as Applicative,
        Chain_18 as Chain,
        Monad_18 as Monad,
        chainFirst_18 as chainFirst,
        Unfoldable_3 as Unfoldable,
        Alt_13 as Alt,
        Zero_5 as Zero,
        guard_4 as guard,
        Alternative_5 as Alternative,
        Extend_5 as Extend,
        Compactable_6 as Compactable,
        Filterable_6 as Filterable,
        FilterableWithIndex_3 as FilterableWithIndex,
        Foldable_8 as Foldable,
        FoldableWithIndex_5 as FoldableWithIndex,
        Traversable_7 as Traversable,
        TraversableWithIndex_4 as TraversableWithIndex,
        chainRecDepthFirst_2 as chainRecDepthFirst,
        ChainRecDepthFirst_2 as ChainRecDepthFirst,
        chainRecBreadthFirst_2 as chainRecBreadthFirst,
        ChainRecBreadthFirst_2 as ChainRecBreadthFirst,
        Witherable_3 as Witherable,
        filterE_2 as filterE,
        FromEither_10 as FromEither,
        fromEitherK_9 as fromEitherK,
        unsafeInsertAt_2 as unsafeInsertAt,
        unsafeUpdateAt_2 as unsafeUpdateAt,
        unsafeDeleteAt_2 as unsafeDeleteAt,
        toArray_3 as toArray,
        fromArray_3 as fromArray,
        empty_3 as empty,
        some_5 as some,
        exists_4 as exists,
        intercalate_6 as intercalate,
        Do_17 as Do,
        bindTo_18 as bindTo,
        let__17 as let,
        bind_18 as bind,
        apS_18 as apS,
        chain_22 as chain,
        range_4 as range,
        cons_4 as cons,
        snoc_4 as snoc,
        prependToAll_4 as prependToAll,
        readonlyArray_2 as readonlyArray
    }
}
export { readonlyArray }

// @public @deprecated
const readonlyArray_2: FunctorWithIndex1<URI_24, number> & Monad1<URI_24> & Unfoldable1<URI_24> & Alternative1<URI_24> & Extend1<URI_24> & FilterableWithIndex1<URI_24, number> & FoldableWithIndex1<URI_24, number> & TraversableWithIndex1<URI_24, number> & Witherable1<URI_24>;

declare namespace readonlyMap {
    export {
        toMap,
        getShow_10 as getShow,
        member_2 as member,
        elem_6 as elem,
        collect_2 as collect,
        toUnfoldable_2 as toUnfoldable,
        pop_2 as pop,
        lookupWithKey_2 as lookupWithKey,
        lookup_4 as lookup,
        isSubmap_2 as isSubmap,
        getEq_10 as getEq,
        getMonoid_14 as getMonoid,
        fromFoldable_2 as fromFoldable,
        partitionWithIndex_5 as partitionWithIndex,
        filterWithIndex_7 as filterWithIndex,
        getFilterableWithIndex_2 as getFilterableWithIndex,
        getWitherable_3 as getWitherable,
        fromMap,
        size_4 as size,
        isEmpty_4 as isEmpty,
        keys_2 as keys,
        values_2 as values,
        toReadonlyArray_2 as toReadonlyArray,
        upsertAt_2 as upsertAt,
        deleteAt_4 as deleteAt,
        updateAt_6 as updateAt,
        modifyAt_6 as modifyAt,
        empty_4 as empty,
        singleton_2 as singleton,
        partitionMapWithIndex_5 as partitionMapWithIndex,
        filterMapWithIndex_5 as filterMapWithIndex,
        compact_7 as compact,
        filter_10 as filter,
        filterMap_8 as filterMap,
        map_27 as map,
        mapWithIndex_8 as mapWithIndex,
        partition_8 as partition,
        partitionMap_8 as partitionMap,
        separate_7 as separate,
        URI_25 as URI,
        getUnionSemigroup_6 as getUnionSemigroup,
        getUnionMonoid_4 as getUnionMonoid,
        getIntersectionSemigroup_4 as getIntersectionSemigroup,
        getDifferenceMagma_4 as getDifferenceMagma,
        Functor_22 as Functor,
        flap_22 as flap,
        getFunctorWithIndex,
        Compactable_7 as Compactable,
        Filterable_7 as Filterable,
        reduce_11 as reduce,
        foldMap_11 as foldMap,
        reduceRight_11 as reduceRight,
        getFoldable_2 as getFoldable,
        reduceWithIndex_8 as reduceWithIndex,
        foldMapWithIndex_8 as foldMapWithIndex,
        reduceRightWithIndex_8 as reduceRightWithIndex,
        getFoldableWithIndex_2 as getFoldableWithIndex,
        getTraversable,
        getTraversableWithIndex_2 as getTraversableWithIndex,
        union_6 as union,
        intersection_4 as intersection,
        difference_4 as difference,
        insertAt_6 as insertAt,
        readonlyMap_2 as readonlyMap
    }
}
export { readonlyMap }

// @public @deprecated
const readonlyMap_2: Filterable2<URI_25>;

// @public (undocumented)
type ReadonlyNonEmptyArray<A> = ReadonlyArray<A> & {
    readonly 0: A;
};

declare namespace readonlyNonEmptyArray {
    export {
        concatW_2 as concatW,
        concat_2 as concat,
        group_3 as group,
        zip_3 as zip,
        groupSort_2 as groupSort,
        filter_2 as filter,
        cons_2 as cons,
        ReadonlyNonEmptyArray,
        uniq_2 as uniq,
        sortBy_2 as sortBy,
        union_3 as union,
        rotate_2 as rotate,
        fromReadonlyArray,
        makeBy_2 as makeBy,
        replicate_2 as replicate,
        range,
        unprepend,
        unappend,
        fromArray_2 as fromArray,
        reverse_3 as reverse,
        groupBy,
        sort,
        updateAt,
        modifyAt,
        zipWith,
        unzip,
        prependAll,
        intersperse,
        chainWithIndex,
        chop,
        splitAt,
        chunksOf,
        of,
        altW,
        alt_2 as alt,
        ap_2 as ap,
        flatMap,
        extend_2 as extend,
        duplicate,
        flatten,
        map_2 as map,
        mapWithIndex,
        reduce,
        foldMap,
        reduceRight,
        reduceWithIndex,
        foldMapWithIndex,
        reduceRightWithIndex,
        traverse,
        sequence,
        traverseWithIndex,
        extract,
        URI_2 as URI,
        getShow,
        getSemigroup_2 as getSemigroup,
        getEq,
        getUnionSemigroup,
        Functor_2 as Functor,
        flap,
        Pointed_2 as Pointed,
        FunctorWithIndex,
        Apply_2 as Apply,
        apFirst_2 as apFirst,
        apSecond_2 as apSecond,
        Applicative_2 as Applicative,
        Chain,
        chainFirst,
        Monad,
        Foldable,
        FoldableWithIndex,
        Traversable,
        TraversableWithIndex,
        Alt_2 as Alt,
        Comonad,
        Do,
        bindTo,
        let_ as let,
        bind,
        apS_2 as apS,
        head,
        tail,
        last_2 as last,
        init,
        min_3 as min,
        max_3 as max,
        concatAll_2 as concatAll,
        matchLeft,
        matchRight,
        modifyHead,
        updateHead,
        modifyLast,
        updateLast,
        intercalate_2 as intercalate,
        chain_2 as chain,
        filterWithIndex,
        uncons,
        unsnoc,
        snoc,
        insertAt,
        prependToAll,
        fold_2 as fold,
        readonlyNonEmptyArray_2 as readonlyNonEmptyArray
    }
}
export { readonlyNonEmptyArray }

// @public @deprecated
const readonlyNonEmptyArray_2: Monad1<URI_2> & Comonad1<URI_2> & TraversableWithIndex1<URI_2, number> & FunctorWithIndex1<URI_2, number> & FoldableWithIndex1<URI_2, number> & Alt1<URI_2>;

// @public (undocumented)
type ReadonlyRecord<K extends string, T> = Readonly<Record<K, T>>;

declare namespace readonlyRecord {
    export {
        collect_3 as collect,
        toUnfoldable_3 as toUnfoldable,
        deleteAt_5 as deleteAt,
        pop_3 as pop,
        isSubrecord,
        lookup_5 as lookup,
        mapWithIndex_9 as mapWithIndex,
        map_28 as map,
        reduceWithIndex_9 as reduceWithIndex,
        foldMapWithIndex_9 as foldMapWithIndex,
        reduceRightWithIndex_9 as reduceRightWithIndex,
        traverseWithIndex_5 as traverseWithIndex,
        traverse_8 as traverse,
        sequence_8 as sequence,
        partitionMapWithIndex_6 as partitionMapWithIndex,
        partitionWithIndex_6 as partitionWithIndex,
        filterMapWithIndex_6 as filterMapWithIndex,
        filterWithIndex_8 as filterWithIndex,
        fromFoldable_3 as fromFoldable,
        fromFoldableMap,
        every_3 as every,
        some_6 as some,
        elem_7 as elem,
        reduce_12 as reduce,
        foldMap_12 as foldMap,
        reduceRight_12 as reduceRight,
        getShow_11 as getShow,
        getEq_11 as getEq,
        getMonoid_15 as getMonoid,
        hasOwnProperty,
        ReadonlyRecord,
        fromRecord,
        toRecord,
        size_5 as size,
        isEmpty_5 as isEmpty,
        keys_3 as keys,
        toReadonlyArray_3 as toReadonlyArray,
        upsertAt_3 as upsertAt,
        has,
        updateAt_7 as updateAt,
        modifyAt_7 as modifyAt,
        empty_5 as empty,
        singleton_3 as singleton,
        wither_4 as wither,
        wilt_4 as wilt,
        toEntries,
        fromEntries,
        union_7 as union,
        intersection_5 as intersection,
        difference_5 as difference,
        filter_11 as filter,
        filterMap_9 as filterMap,
        partition_9 as partition,
        partitionMap_9 as partitionMap,
        compact_8 as compact,
        separate_8 as separate,
        URI_26 as URI,
        Functor_23 as Functor,
        flap_23 as flap,
        FunctorWithIndex_6 as FunctorWithIndex,
        getFoldable_3 as getFoldable,
        getFoldableWithIndex_3 as getFoldableWithIndex,
        Compactable_8 as Compactable,
        Filterable_8 as Filterable,
        FilterableWithIndex_4 as FilterableWithIndex,
        getTraversable_2 as getTraversable,
        getTraversableWithIndex_3 as getTraversableWithIndex,
        getWitherable_4 as getWitherable,
        getUnionSemigroup_7 as getUnionSemigroup,
        getUnionMonoid_5 as getUnionMonoid,
        getIntersectionSemigroup_5 as getIntersectionSemigroup,
        getDifferenceMagma_5 as getDifferenceMagma,
        Foldable_9 as Foldable,
        FoldableWithIndex_6 as FoldableWithIndex,
        Traversable_8 as Traversable,
        TraversableWithIndex_5 as TraversableWithIndex,
        Witherable_4 as Witherable,
        insertAt_7 as insertAt,
        readonlyRecord_2 as readonlyRecord
    }
}
export { readonlyRecord }

// @public @deprecated
const readonlyRecord_2: FunctorWithIndex1<URI_26, string> & FoldableWithIndex1<URI_26, string> & FilterableWithIndex1<URI_26, string> & TraversableWithIndex1<URI_26, string> & Witherable1<URI_26>;

declare namespace readonlySet {
    export {
        toSet,
        map_29 as map,
        chain_23 as chain,
        filter_12 as filter,
        partition_10 as partition,
        union_8 as union,
        intersection_6 as intersection,
        partitionMap_10 as partitionMap,
        difference_6 as difference,
        reduce_13 as reduce,
        foldMap_13 as foldMap,
        insert,
        separate_9 as separate,
        filterMap_10 as filterMap,
        every_4 as every,
        isSubset,
        elem_8 as elem,
        getShow_12 as getShow,
        getEq_12 as getEq,
        fromSet,
        singleton_4 as singleton,
        fromReadonlyArray_2 as fromReadonlyArray,
        reduceRight_13 as reduceRight,
        remove,
        toggle,
        compact_9 as compact,
        empty_6 as empty,
        isEmpty_6 as isEmpty,
        size_6 as size,
        some_7 as some,
        toReadonlyArray_4 as toReadonlyArray,
        URI_27 as URI,
        getUnionSemigroup_8 as getUnionSemigroup,
        getUnionMonoid_6 as getUnionMonoid,
        getIntersectionSemigroup_6 as getIntersectionSemigroup,
        getDifferenceMagma_6 as getDifferenceMagma,
        fromArray_4 as fromArray
    }
}
export { readonlySet }

declare namespace readonlyTuple {
    export {
        fst,
        snd,
        getApply_2 as getApply,
        getApplicative_2 as getApplicative,
        getChain,
        getMonad,
        getChainRec,
        swap_7 as swap,
        bimap_10 as bimap,
        mapFst,
        mapSnd,
        compose_3 as compose,
        extend_10 as extend,
        extract_4 as extract,
        duplicate_8 as duplicate,
        reduce_14 as reduce,
        foldMap_14 as foldMap,
        reduceRight_14 as reduceRight,
        traverse_9 as traverse,
        sequence_9 as sequence,
        URI_28 as URI,
        Functor_24 as Functor,
        flap_24 as flap,
        map_30 as map,
        mapLeft_10 as mapLeft,
        Bifunctor_9 as Bifunctor,
        Semigroupoid_2 as Semigroupoid,
        Comonad_5 as Comonad,
        Foldable_10 as Foldable,
        Traversable_9 as Traversable,
        readonlyTuple_2 as readonlyTuple
    }
}
export { readonlyTuple }

// @public @deprecated
const readonlyTuple_2: Semigroupoid2<URI_28> & Bifunctor2<URI_28> & Comonad2<URI_28> & Foldable2<URI_28> & Traversable2<URI_28>;

declare namespace record {
    export {
        collect_4 as collect,
        toUnfoldable_4 as toUnfoldable,
        deleteAt_6 as deleteAt,
        pop_4 as pop,
        reduceWithIndex_10 as reduceWithIndex,
        foldMapWithIndex_10 as foldMapWithIndex,
        reduceRightWithIndex_10 as reduceRightWithIndex,
        traverseWithIndex_6 as traverseWithIndex,
        traverse_10 as traverse,
        sequence_10 as sequence,
        partitionWithIndex_7 as partitionWithIndex,
        filterWithIndex_9 as filterWithIndex,
        fromFoldable_4 as fromFoldable,
        fromFoldableMap_2 as fromFoldableMap,
        reduce_15 as reduce,
        foldMap_15 as foldMap,
        reduceRight_15 as reduceRight,
        getShow_13 as getShow,
        size_7 as size,
        isEmpty_7 as isEmpty,
        keys_4 as keys,
        toArray_4 as toArray,
        upsertAt_4 as upsertAt,
        has_2 as has,
        updateAt_8 as updateAt,
        modifyAt_8 as modifyAt,
        isSubrecord_2 as isSubrecord,
        lookup_6 as lookup,
        mapWithIndex_10 as mapWithIndex,
        map_31 as map,
        singleton_5 as singleton,
        wither_5 as wither,
        wilt_5 as wilt,
        partitionMapWithIndex_7 as partitionMapWithIndex,
        filterMapWithIndex_7 as filterMapWithIndex,
        toEntries_2 as toEntries,
        fromEntries_2 as fromEntries,
        every_5 as every,
        some_8 as some,
        elem_9 as elem,
        union_9 as union,
        intersection_7 as intersection,
        difference_7 as difference,
        filter_13 as filter,
        filterMap_11 as filterMap,
        partition_11 as partition,
        partitionMap_11 as partitionMap,
        compact_10 as compact,
        separate_10 as separate,
        URI_29 as URI,
        getEq_13 as getEq,
        getMonoid_16 as getMonoid,
        Functor_25 as Functor,
        flap_25 as flap,
        FunctorWithIndex_7 as FunctorWithIndex,
        getFoldable_4 as getFoldable,
        getFoldableWithIndex_4 as getFoldableWithIndex,
        Compactable_9 as Compactable,
        Filterable_9 as Filterable,
        FilterableWithIndex_5 as FilterableWithIndex,
        getTraversable_3 as getTraversable,
        getTraversableWithIndex_4 as getTraversableWithIndex,
        getWitherable_5 as getWitherable,
        getUnionSemigroup_9 as getUnionSemigroup,
        getUnionMonoid_7 as getUnionMonoid,
        getIntersectionSemigroup_7 as getIntersectionSemigroup,
        getDifferenceMagma_7 as getDifferenceMagma,
        Foldable_11 as Foldable,
        FoldableWithIndex_7 as FoldableWithIndex,
        Traversable_10 as Traversable,
        TraversableWithIndex_6 as TraversableWithIndex,
        Witherable_5 as Witherable,
        empty_7 as empty,
        insertAt_8 as insertAt,
        hasOwnProperty_2 as hasOwnProperty,
        record_2 as record
    }
}
export { record }

// @public @deprecated
const record_2: FunctorWithIndex1<URI_29, string> & FoldableWithIndex1<URI_29, string> & FilterableWithIndex1<URI_29, string> & TraversableWithIndex1<URI_29, string> & Witherable1<URI_29>;

// @public (undocumented)
const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (as: ReadonlyNonEmptyArray<A>) => B;

// @public (undocumented)
const reduce_10: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: ReadonlyArray<A>) => B;

// @public (undocumented)
const reduce_11: <K>(O: Ord<K>) => <B, A>(b: B, f: (b: B, a: A) => B) => (m: ReadonlyMap<K, A>) => B;

// @public
function reduce_12(O: Ord<string>): <A, B>(b: B, f: (b: B, a: A) => B) => (fa: ReadonlyRecord<string, A>) => B;

// @public @deprecated
function reduce_12<A, B>(b: B, f: (b: B, a: A) => B): (fa: ReadonlyRecord<string, A>) => B;

// @public (undocumented)
function reduce_13<A>(O: Ord<A>): <B>(b: B, f: (b: B, a: A) => B) => (fa: ReadonlySet<A>) => B;

// @public (undocumented)
const reduce_14: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: readonly [A, E]) => B;

// @public
function reduce_15(O: Ord<string>): <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Record<string, A>) => B;

// @public @deprecated
function reduce_15<A, B>(b: B, f: (b: B, a: A) => B): (fa: Record<string, A>) => B;

// @public (undocumented)
const reduce_16: <A>(O: Ord<A>) => <B>(b: B, f: (b: B, a: A) => B) => (fa: Set<A>) => B;

// @public (undocumented)
const reduce_17: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: These<E, A>) => B;

// @public (undocumented)
const reduce_18: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Tree<A>) => B;

// @public (undocumented)
const reduce_19: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: [A, E]) => B;

// @public (undocumented)
const reduce_2: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: NonEmptyArray<A>) => B;

// @public
const reduce_3: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Array<A>) => B;

// @public (undocumented)
const reduce_4: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Option_2<A>) => B;

// @public
const reduce_5: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: Either<E, A>) => B;

// @public
function reduce_6<F extends URIS, G extends URIS>(F: Foldable1<F>, G: Foldable1<G>): <B, A>(b: B, f: (b: B, a: A) => B) => (fga: Kind<F, Kind<G, A>>) => B;

// @public (undocumented)
function reduce_6<F, G>(F: Foldable_6<F>, G: Foldable_6<G>): <B, A>(b: B, f: (b: B, a: A) => B) => (fga: HKT<F, HKT<G, A>>) => B;

// @public (undocumented)
const reduce_7: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Identity<A>) => B;

// @public (undocumented)
const reduce_8: <K>(O: Ord<K>) => <B, A>(b: B, f: (b: B, a: A) => B) => (m: Map<K, A>) => B;

// @public
function reduce_9<F extends URIS4>(F: Foldable4<F>): <A, B>(b: B, f: (b: B, a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B;

// @public (undocumented)
function reduce_9<F extends URIS3>(F: Foldable3<F>): <A, B>(b: B, f: (b: B, a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B;

// @public (undocumented)
function reduce_9<F extends URIS3, E>(F: Foldable3C<F, E>): <A, B>(b: B, f: (b: B, a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => B;

// @public (undocumented)
function reduce_9<F extends URIS2>(F: Foldable2<F>): <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: Kind2<F, E, A>) => B;

// @public (undocumented)
function reduce_9<F extends URIS2, E>(F: Foldable2C<F, E>): <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Kind2<F, E, A>) => B;

// @public (undocumented)
function reduce_9<F extends URIS>(F: Foldable1<F>): <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Kind<F, A>) => B;

// @public (undocumented)
function reduce_9<F>(F: Foldable_6<F>): <A, B>(b: B, f: (b: B, a: A) => B) => (fa: HKT<F, A>) => B;

// @public
function reduceM<M extends URIS3, F extends URIS>(M: Monad3<M>, F: Foldable1<F>): <B, A, R, E>(b: B, f: (b: B, a: A) => Kind3<M, R, E, B>) => (fa: Kind<F, A>) => Kind3<M, R, E, B>;

// @public (undocumented)
function reduceM<M extends URIS3, F extends URIS, E>(M: Monad3C<M, E>, F: Foldable1<F>): <B, A, R>(b: B, f: (b: B, a: A) => Kind3<M, R, E, B>) => (fa: Kind<F, A>) => Kind3<M, R, E, B>;

// @public (undocumented)
function reduceM<M extends URIS2, F extends URIS>(M: Monad2<M>, F: Foldable1<F>): <B, A, E>(b: B, f: (b: B, a: A) => Kind2<M, E, B>) => (fa: Kind<F, A>) => Kind2<M, E, B>;

// @public (undocumented)
function reduceM<M extends URIS2, F extends URIS, E>(M: Monad2C<M, E>, F: Foldable1<F>): <B, A>(b: B, f: (b: B, a: A) => Kind2<M, E, B>) => (fa: Kind<F, A>) => Kind2<M, E, B>;

// @public (undocumented)
function reduceM<M extends URIS, F extends URIS>(M: Monad1<M>, F: Foldable1<F>): <B, A>(b: B, f: (b: B, a: A) => Kind<M, B>) => (fa: Kind<F, A>) => Kind<M, B>;

// @public (undocumented)
function reduceM<M, F>(M: Monad_6<M>, F: Foldable_6<F>): <B, A>(b: B, f: (b: B, a: A) => HKT<M, B>) => (fa: HKT<F, A>) => HKT<M, B>;

// @public (undocumented)
const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (as: ReadonlyNonEmptyArray<A>) => B;

// @public (undocumented)
const reduceRight_10: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: ReadonlyArray<A>) => B;

// @public (undocumented)
const reduceRight_11: <K>(O: Ord<K>) => <B, A>(b: B, f: (a: A, b: B) => B) => (m: ReadonlyMap<K, A>) => B;

// @public
function reduceRight_12(O: Ord<string>): <A, B>(b: B, f: (a: A, b: B) => B) => (fa: ReadonlyRecord<string, A>) => B;

// @public @deprecated
function reduceRight_12<A, B>(b: B, f: (a: A, b: B) => B): (fa: ReadonlyRecord<string, A>) => B;

// @public (undocumented)
const reduceRight_13: <A>(O: Ord<A>) => <B>(b: B, f: (a: A, b: B) => B) => (fa: ReadonlySet<A>) => B;

// @public (undocumented)
const reduceRight_14: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: readonly [A, E]) => B;

// @public
function reduceRight_15(O: Ord<string>): <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Record<string, A>) => B;

// @public @deprecated
function reduceRight_15<A, B>(b: B, f: (a: A, b: B) => B): (fa: Record<string, A>) => B;

// @public (undocumented)
const reduceRight_16: <A>(O: Ord<A>) => <B>(b: B, f: (a: A, b: B) => B) => (fa: Set<A>) => B;

// @public (undocumented)
const reduceRight_17: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: These<E, A>) => B;

// @public (undocumented)
const reduceRight_18: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Tree<A>) => B;

// @public (undocumented)
const reduceRight_19: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: [A, E]) => B;

// @public (undocumented)
const reduceRight_2: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: NonEmptyArray<A>) => B;

// @public
const reduceRight_3: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Array<A>) => B;

// @public (undocumented)
const reduceRight_4: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Option_2<A>) => B;

// @public
const reduceRight_5: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: Either<E, A>) => B;

// @public
function reduceRight_6<F extends URIS, G extends URIS>(F: Foldable1<F>, G: Foldable1<G>): <B, A>(b: B, f: (a: A, b: B) => B) => (fga: Kind<F, Kind<G, A>>) => B;

// @public (undocumented)
function reduceRight_6<F, G>(F: Foldable_6<F>, G: Foldable_6<G>): <B, A>(b: B, f: (a: A, b: B) => B) => (fga: HKT<F, HKT<G, A>>) => B;

// @public (undocumented)
const reduceRight_7: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Identity<A>) => B;

// @public (undocumented)
const reduceRight_8: <K>(O: Ord<K>) => <B, A>(b: B, f: (a: A, b: B) => B) => (m: Map<K, A>) => B;

// @public
function reduceRight_9<F extends URIS4>(F: Foldable4<F>): <A, B>(b: B, f: (a: A, b: B) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B;

// @public (undocumented)
function reduceRight_9<F extends URIS3>(F: Foldable3<F>): <A, B>(b: B, f: (a: A, b: B) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B;

// @public (undocumented)
function reduceRight_9<F extends URIS3, E>(F: Foldable3C<F, E>): <A, B>(b: B, f: (a: A, b: B) => B) => <R>(fa: Kind3<F, R, E, A>) => B;

// @public (undocumented)
function reduceRight_9<F extends URIS2>(F: Foldable2<F>): <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: Kind2<F, E, A>) => B;

// @public (undocumented)
function reduceRight_9<F extends URIS2, E>(F: Foldable2C<F, E>): <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Kind2<F, E, A>) => B;

// @public (undocumented)
function reduceRight_9<F extends URIS>(F: Foldable1<F>): <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Kind<F, A>) => B;

// @public (undocumented)
function reduceRight_9<F>(F: Foldable_6<F>): <A, B>(b: B, f: (a: A, b: B) => B) => (fa: HKT<F, A>) => B;

// @public (undocumented)
const reduceRightWithIndex: <A, B>(b: B, f: (i: number, a: A, b: B) => B) => (as: ReadonlyNonEmptyArray<A>) => B;

// @public
function reduceRightWithIndex_10(O: Ord<string>): <K extends string, A, B>(b: B, f: (k: K, a: A, b: B) => B) => (fa: Record<K, A>) => B;

// @public @deprecated
function reduceRightWithIndex_10<K extends string, A, B>(b: B, f: (k: K, a: A, b: B) => B): (fa: Record<K, A>) => B;

// @public (undocumented)
const reduceRightWithIndex_2: <A, B>(b: B, f: (i: number, a: A, b: B) => B) => (fa: NonEmptyArray<A>) => B;

// @public
const reduceRightWithIndex_3: <A, B>(b: B, f: (i: number, a: A, b: B) => B) => (fa: Array<A>) => B;

// @public
function reduceRightWithIndex_4<F extends URIS, I, G extends URIS, J>(F: FoldableWithIndex1<F, I>, G: FoldableWithIndex1<G, J>): <B, A>(b: B, f: (ij: readonly [I, J], a: A, b: B) => B) => (fga: Kind<F, Kind<G, A>>) => B;

// @public (undocumented)
function reduceRightWithIndex_4<F, I, G, J>(F: FoldableWithIndex_4<F, I>, G: FoldableWithIndex_4<G, J>): <B, A>(b: B, f: (ij: readonly [I, J], a: A, b: B) => B) => (fga: HKT<F, HKT<G, A>>) => B;

// @public (undocumented)
const reduceRightWithIndex_5: <K>(O: Ord<K>) => <B, A>(b: B, f: (k: K, a: A, b: B) => B) => (m: Map<K, A>) => B;

// @public
function reduceRightWithIndex_6<F extends URIS4, I>(F: FoldableWithIndex4<F, I>): <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B;

// @public (undocumented)
function reduceRightWithIndex_6<F extends URIS3, I>(F: FoldableWithIndex3<F, I>): <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B;

// @public (undocumented)
function reduceRightWithIndex_6<F extends URIS3, I, E>(F: FoldableWithIndex3C<F, I, E>): <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <R>(fa: Kind3<F, R, E, A>) => B;

// @public (undocumented)
function reduceRightWithIndex_6<F extends URIS2, I>(F: FoldableWithIndex2<F, I>): <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <E>(fa: Kind2<F, E, A>) => B;

// @public (undocumented)
function reduceRightWithIndex_6<F extends URIS2, I, E>(F: FoldableWithIndex2C<F, I, E>): <A, B>(b: B, f: (i: I, a: A, b: B) => B) => (fa: Kind2<F, E, A>) => B;

// @public (undocumented)
function reduceRightWithIndex_6<F extends URIS, I>(F: FoldableWithIndex1<F, I>): <A, B>(b: B, f: (i: I, a: A, b: B) => B) => (fa: Kind<F, A>) => B;

// @public (undocumented)
function reduceRightWithIndex_6<F, I>(F: FoldableWithIndex_4<F, I>): <A, B>(b: B, f: (i: I, a: A, b: B) => B) => (fa: HKT<F, A>) => B;

// @public (undocumented)
const reduceRightWithIndex_7: <A, B>(b: B, f: (i: number, a: A, b: B) => B) => (fa: ReadonlyArray<A>) => B;

// @public (undocumented)
const reduceRightWithIndex_8: <K>(O: Ord<K>) => <B, A>(b: B, f: (k: K, a: A, b: B) => B) => (m: ReadonlyMap<K, A>) => B;

// @public
function reduceRightWithIndex_9(O: Ord<string>): <K extends string, A, B>(b: B, f: (k: K, a: A, b: B) => B) => (fa: ReadonlyRecord<K, A>) => B;

// @public @deprecated
function reduceRightWithIndex_9<K extends string, A, B>(b: B, f: (k: K, a: A, b: B) => B): (fa: ReadonlyRecord<K, A>) => B;

// @public (undocumented)
const reduceWithIndex: <A, B>(b: B, f: (i: number, b: B, a: A) => B) => (as: ReadonlyNonEmptyArray<A>) => B;

// @public
function reduceWithIndex_10(O: Ord<string>): <K extends string, A, B>(b: B, f: (k: K, b: B, a: A) => B) => (fa: Record<K, A>) => B;

// @public @deprecated
function reduceWithIndex_10<K extends string, A, B>(b: B, f: (k: K, b: B, a: A) => B): (fa: Record<K, A>) => B;

// @public (undocumented)
const reduceWithIndex_2: <A, B>(b: B, f: (i: number, b: B, a: A) => B) => (fa: NonEmptyArray<A>) => B;

// @public
const reduceWithIndex_3: <A, B>(b: B, f: (i: number, b: B, a: A) => B) => (fa: Array<A>) => B;

// @public
function reduceWithIndex_4<F extends URIS, I, G extends URIS, J>(F: FoldableWithIndex1<F, I>, G: FoldableWithIndex1<G, J>): <B, A>(b: B, f: (ij: readonly [I, J], b: B, a: A) => B) => (fga: Kind<F, Kind<G, A>>) => B;

// @public (undocumented)
function reduceWithIndex_4<F, I, G, J>(F: FoldableWithIndex_4<F, I>, G: FoldableWithIndex_4<G, J>): <B, A>(b: B, f: (ij: readonly [I, J], b: B, a: A) => B) => (fga: HKT<F, HKT<G, A>>) => B;

// @public (undocumented)
const reduceWithIndex_5: <K>(O: Ord<K>) => <B, A>(b: B, f: (k: K, b: B, a: A) => B) => (m: Map<K, A>) => B;

// @public
function reduceWithIndex_6<F extends URIS4, I>(F: FoldableWithIndex4<F, I>): <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B;

// @public (undocumented)
function reduceWithIndex_6<F extends URIS3, I>(F: FoldableWithIndex3<F, I>): <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B;

// @public (undocumented)
function reduceWithIndex_6<F extends URIS3, I, E>(F: FoldableWithIndex3C<F, I, E>): <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => B;

// @public (undocumented)
function reduceWithIndex_6<F extends URIS2, I>(F: FoldableWithIndex2<F, I>): <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <E>(fa: Kind2<F, E, A>) => B;

// @public (undocumented)
function reduceWithIndex_6<F extends URIS2, I, E>(F: FoldableWithIndex2C<F, I, E>): <A, B>(b: B, f: (i: I, b: B, a: A) => B) => (fa: Kind2<F, E, A>) => B;

// @public (undocumented)
function reduceWithIndex_6<F extends URIS, I>(F: FoldableWithIndex1<F, I>): <A, B>(b: B, f: (i: I, b: B, a: A) => B) => (fa: Kind<F, A>) => B;

// @public (undocumented)
function reduceWithIndex_6<F, I>(F: FoldableWithIndex_4<F, I>): <A, B>(b: B, f: (i: I, b: B, a: A) => B) => (fa: HKT<F, A>) => B;

// @public (undocumented)
const reduceWithIndex_7: <A, B>(b: B, f: (i: number, b: B, a: A) => B) => (fa: ReadonlyArray<A>) => B;

// @public (undocumented)
const reduceWithIndex_8: <K>(O: Ord<K>) => <B, A>(b: B, f: (k: K, b: B, a: A) => B) => (m: ReadonlyMap<K, A>) => B;

// @public
function reduceWithIndex_9(O: Ord<string>): <K extends string, A, B>(b: B, f: (k: K, b: B, a: A) => B) => (fa: ReadonlyRecord<K, A>) => B;

// @public @deprecated
function reduceWithIndex_9<K extends string, A, B>(b: B, f: (k: K, b: B, a: A) => B): (fa: ReadonlyRecord<K, A>) => B;

// @public (undocumented)
interface Refinement<A, B extends A> {
    // (undocumented)
    (a: A): a is B;
}

declare namespace refinement {
    export {
        Refinement,
        fromOptionK_11 as fromOptionK,
        fromEitherK_10 as fromEitherK,
        id_2 as id,
        not_3 as not,
        or_2 as or,
        and_2 as and,
        zero_7 as zero,
        compose_4 as compose
    }
}
export { refinement }

// @public @deprecated
interface Refinement_2<A, B extends A> {
    // (undocumented)
    (a: A): a is B;
}

// @public (undocumented)
type RefinementWithIndex<I, A, B extends A> = (i: I, a: A) => a is B;

// @public
const remove: <A>(E: Eq<A>) => (a: A) => (set: ReadonlySet<A>) => ReadonlySet<A>;

// @public
const remove_2: <A>(E: Eq<A>) => (a: A) => (set: Set<A>) => Set<A>;

// @public (undocumented)
const replace: (searchValue: string | RegExp, replaceValue: string) => (s: string) => string;

// @public
const replicate: <A>(a: A) => (n: number) => readonlyNonEmptyArray.ReadonlyNonEmptyArray<A>;

// @public
const replicate_2: <A>(a: A) => (n: number) => ReadonlyNonEmptyArray<A>;

// @public
const replicate_3: <A>(n: number, a: A) => A[];

// @public
const replicate_4: <A>(n: number, a: A) => readonly A[];

// @public (undocumented)
const reverse: <A>(O: Ord<A>) => Ord<A>;

// @public (undocumented)
const reverse_10: (o: Ordering) => Ordering;

// @public
const reverse_11: <A>(as: readonly A[]) => readonly A[];

// @public
const reverse_2: <A>(S: Semigroup<A>) => Semigroup<A>;

// @public (undocumented)
const reverse_3: <A>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public (undocumented)
const reverse_4: <A>(as: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public
const reverse_5: <A>(as: A[]) => A[];

// @public
const reverse_6: <A>(M: Monoid<A>) => Monoid<A>;

// @public
const reverse_7: <A>(B: BooleanAlgebra_2<A>) => BooleanAlgebra_2<A>;

// @public
const reverse_8: <A>(B: Bounded<A>) => Bounded<A>;

// @public
const reverse_9: <A>(M: Magma<A>) => Magma<A>;

// @public (undocumented)
interface Right<A> {
    // (undocumented)
    readonly right: A;
    // (undocumented)
    readonly _tag: 'Right';
}

// @public (undocumented)
const right: <E, A>(s: Separated<E, A>) => A;

// @public (undocumented)
const right_10: <E = never, A = never>(a: A) => TaskThese<E, A>;

// @public (undocumented)
function right_11<E = never, A = never>(right: A): These<E, A>;

// @public (undocumented)
function right_12<F extends URIS3>(F: Pointed3<F>): <A, R, FE, E = never>(a: A) => Kind3<F, R, FE, These<E, A>>;

// @public (undocumented)
function right_12<F extends URIS3, FE>(F: Pointed3C<F, FE>): <A, R, E = never>(a: A) => Kind3<F, R, FE, These<E, A>>;

// @public (undocumented)
function right_12<F extends URIS2>(F: Pointed2<F>): <A, FE, E = never>(a: A) => Kind2<F, FE, These<E, A>>;

// @public (undocumented)
function right_12<F extends URIS2, FE>(F: Pointed2C<F, FE>): <A, E = never>(a: A) => Kind2<F, FE, These<E, A>>;

// @public (undocumented)
function right_12<F extends URIS>(F: Pointed1<F>): <A, E = never>(a: A) => Kind<F, These<E, A>>;

// @public (undocumented)
function right_12<F>(F: Pointed<F>): <A, E = never>(a: A) => HKT<F, These<E, A>>;

// @public
const right_2: <E = never, A = never>(a: A) => Either<E, A>;

// @public (undocumented)
function right_3<F extends URIS3>(F: Pointed3<F>): <A, R, FE, E = never>(a: A) => Kind3<F, R, FE, Either<E, A>>;

// @public (undocumented)
function right_3<F extends URIS3, FE>(F: Pointed3C<F, FE>): <A, R, E = never>(a: A) => Kind3<F, R, FE, Either<E, A>>;

// @public (undocumented)
function right_3<F extends URIS2>(F: Pointed2<F>): <A, FE, E = never>(a: A) => Kind2<F, FE, Either<E, A>>;

// @public (undocumented)
function right_3<F extends URIS2, FE>(F: Pointed2C<F, FE>): <A, E = never>(a: A) => Kind2<F, FE, Either<E, A>>;

// @public (undocumented)
function right_3<F extends URIS>(F: Pointed1<F>): <A, E = never>(a: A) => Kind<F, Either<E, A>>;

// @public (undocumented)
function right_3<F>(F: Pointed<F>): <A, E = never>(a: A) => HKT<F, Either<E, A>>;

// @public (undocumented)
const right_4: <E = never, A = never>(a: A) => IOEither<E, A>;

// @public (undocumented)
const right_5: Choice2<URI_17>['right'];

// @public (undocumented)
const right_6: <R, E = never, A = never>(a: A) => ReaderEither<R, E, A>;

// @public (undocumented)
const right_7: <R, E = never, A = never>(a: A) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const right_8: <E = never, A = never>(a: A) => TaskEither<E, A>;

// @public (undocumented)
const right_9: <S, R, E = never, A = never>(a: A) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
function rightF<F extends URIS3>(F: Functor3<F>): <R, FE, A, E = never>(fa: Kind3<F, R, FE, A>) => Kind3<F, R, FE, Either<E, A>>;

// @public (undocumented)
function rightF<F extends URIS3, FE>(F: Functor3C<F, FE>): <R, A, E = never>(fa: Kind3<F, R, FE, A>) => Kind3<F, R, FE, Either<E, A>>;

// @public (undocumented)
function rightF<F extends URIS2>(F: Functor2<F>): <FE, A, E = never>(fa: Kind2<F, FE, A>) => Kind2<F, FE, Either<E, A>>;

// @public (undocumented)
function rightF<F extends URIS2, FE>(F: Functor2C<F, FE>): <A, E = never>(fa: Kind2<F, FE, A>) => Kind2<F, FE, Either<E, A>>;

// @public (undocumented)
function rightF<F extends URIS>(F: Functor1<F>): <A, E = never>(fa: Kind<F, A>) => Kind<F, Either<E, A>>;

// @public (undocumented)
function rightF<F>(F: Functor<F>): <A, E = never>(fa: HKT<F, A>) => HKT<F, Either<E, A>>;

// @public (undocumented)
function rightF_2<F extends URIS3>(F: Functor3<F>): <R, FE, A, E = never>(fa: Kind3<F, R, FE, A>) => Kind3<F, R, FE, These<E, A>>;

// @public (undocumented)
function rightF_2<F extends URIS3, FE>(F: Functor3C<F, FE>): <R, A, E = never>(fa: Kind3<F, R, FE, A>) => Kind3<F, R, FE, These<E, A>>;

// @public (undocumented)
function rightF_2<F extends URIS2>(F: Functor2<F>): <FE, A, E = never>(fa: Kind2<F, FE, A>) => Kind2<F, FE, These<E, A>>;

// @public (undocumented)
function rightF_2<F extends URIS2, FE>(F: Functor2C<F, FE>): <A, E = never>(fa: Kind2<F, FE, A>) => Kind2<F, FE, These<E, A>>;

// @public (undocumented)
function rightF_2<F extends URIS>(F: Functor1<F>): <A, E = never>(fa: Kind<F, A>) => Kind<F, These<E, A>>;

// @public (undocumented)
function rightF_2<F>(F: Functor<F>): <A, E = never>(fa: HKT<F, A>) => HKT<F, These<E, A>>;

// @public (undocumented)
const rightIO: <E = never, A = never>(ma: IO<A>) => IOEither<E, A>;

// @public (undocumented)
const rightIO_2: <R, E = never, A = never>(ma: IO<A>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const rightIO_3: <E = never, A = never>(ma: IO<A>) => TaskEither<E, A>;

// @public (undocumented)
function rightIO_4<S, R, E = never, A = never>(ma: IO<A>): StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const rightIO_5: <E = never, A = never>(ma: IO<A>) => TaskThese<E, A>;

// @public (undocumented)
function rightOrBoth<A>(a: A): <E>(me: Option_2<E>) => These<E, A>;

// @public (undocumented)
const rightReader: <R, E = never, A = never>(ma: Reader<R, A>) => ReaderEither<R, E, A>;

// @public (undocumented)
const rightReader_2: <R, E = never, A = never>(ma: Reader<R, A>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
function rightReader_3<S, R, E = never, A = never>(ma: Reader<R, A>): StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const rightReaderIO: <R, E = never, A = never>(ma: ReaderIO<R, A>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const rightReaderTask: <R, E = never, A = never>(ma: ReaderTask<R, A>) => ReaderTaskEither<R, E, A>;

// @public
const rights: <E, A>(as: Either<E, A>[]) => A[];

// @public
const rights_2: <E, A>(as: readonly Either<E, A>[]) => readonly A[];

// @public (undocumented)
const rightState: <S, R, E = never, A = never>(ma: State<S, A>) => StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const rightTask: <R, E = never, A = never>(ma: Task<A>) => ReaderTaskEither<R, E, A>;

// @public (undocumented)
const rightTask_2: <E = never, A = never>(ma: Task<A>) => TaskEither<E, A>;

// @public (undocumented)
function rightTask_3<S, R, E = never, A = never>(ma: Task<A>): StateReaderTaskEither<S, R, E, A>;

// @public (undocumented)
const rightTask_4: <E = never, A = never>(ma: Task<A>) => TaskThese<E, A>;

// @public (undocumented)
interface Ring<A> extends Semiring<A> {
    // (undocumented)
    readonly sub: (x: A, y: A) => A;
}

declare namespace ring {
    export {
        Ring,
        tuple_8 as tuple,
        negate,
        getTupleRing,
        getFunctionRing
    }
}
export { ring }

// @public
const rotate: (n: number) => <A>(as: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public
const rotate_2: (n: number) => <A>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public
const rotate_3: (n: number) => <A>(as: A[]) => A[];

// @public
const rotate_4: (n: number) => <A>(as: readonly A[]) => readonly A[];

// @public @deprecated (undocumented)
function run<R, A>(ma: ReaderTask<R, A>, r: R): Promise<A>;

// @public @deprecated (undocumented)
function run_2<R, E, A>(ma: ReaderTaskEither<R, E, A>, r: R): Promise<Either<E, A>>;

// @public @deprecated (undocumented)
function run_3<S, R, E, A>(ma: StateReaderTaskEither<S, R, E, A>, s: S, r: R): Promise<Either<E, [A, S]>>;

// @public
const scanLeft: <A, B>(b: B, f: (b: B, a: A) => B) => (as: A[]) => nonEmptyArray.NonEmptyArray<B>;

// @public
const scanLeft_2: <A, B>(b: B, f: (b: B, a: A) => B) => (as: readonly A[]) => readonlyNonEmptyArray.ReadonlyNonEmptyArray<B>;

// @public
const scanRight: <A, B>(b: B, f: (a: A, b: B) => B) => (as: A[]) => nonEmptyArray.NonEmptyArray<B>;

// @public
const scanRight_2: <A, B>(b: B, f: (a: A, b: B) => B) => (as: readonly A[]) => readonlyNonEmptyArray.ReadonlyNonEmptyArray<B>;

// @public (undocumented)
const second: Strong2<URI_17>['second'];

// @public
function seek<S>(s: S): <A>(wa: Store<S, A>) => Store<S, A>;

// @public
function seeks<S>(f: Endomorphism<S>): <A>(wa: Store<S, A>) => Store<S, A>;

// @public (undocumented)
interface Semigroup<A> extends Magma<A> {
}

declare namespace semigroup {
    export {
        fold,
        Semigroup,
        min,
        max_2 as max,
        constant,
        reverse_2 as reverse,
        struct_2 as struct,
        tuple_3 as tuple,
        intercalate,
        first,
        last,
        concatAll,
        semigroupVoid,
        getObjectSemigroup,
        getLastSemigroup,
        getFirstSemigroup,
        getTupleSemigroup,
        getStructSemigroup,
        getDualSemigroup,
        getJoinSemigroup,
        getMeetSemigroup,
        getIntercalateSemigroup,
        semigroupAll,
        semigroupAny,
        getFunctionSemigroup,
        semigroupString,
        semigroupSum,
        semigroupProduct
    }
}
export { semigroup }

// @public (undocumented)
const Semigroup_2: semigroup.Semigroup<Ordering>;

// @public
const Semigroup_3: semigroup.Semigroup<string>;

// @public (undocumented)
const Semigroup_4: semigroup.Semigroup<void>;

// @public
const SemigroupAll: Semigroup<boolean>;

// @public @deprecated
const semigroupAll: Semigroup<boolean>;

// @public
const SemigroupAny: Semigroup<boolean>;

// @public @deprecated
const semigroupAny: Semigroup<boolean>;

// @public (undocumented)
interface Semigroupoid<F> {
    // (undocumented)
    readonly compose: <A, B, C>(bc: HKT2<F, B, C>, ab: HKT2<F, A, B>) => HKT2<F, A, C>;
    // (undocumented)
    readonly URI: F;
}

declare namespace semigroupoid {
    export {
        Semigroupoid,
        Semigroupoid2,
        Semigroupoid2C,
        Semigroupoid3,
        Semigroupoid3C,
        Semigroupoid4
    }
}
export { semigroupoid }

// @public (undocumented)
interface Semigroupoid2<F extends URIS2> {
    // (undocumented)
    readonly compose: <A, B, C>(ab: Kind2<F, B, C>, la: Kind2<F, A, B>) => Kind2<F, A, C>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Semigroupoid2C<F extends URIS2, A> {
    // (undocumented)
    readonly compose: <B, C>(ab: Kind2<F, B, C>, la: Kind2<F, A, B>) => Kind2<F, A, C>;
    // (undocumented)
    readonly _E: A;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Semigroupoid3<F extends URIS3> {
    // (undocumented)
    readonly compose: <R, A, B, C>(ab: Kind3<F, R, B, C>, la: Kind3<F, R, A, B>) => Kind3<F, R, A, C>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Semigroupoid3C<F extends URIS3, A> {
    // (undocumented)
    readonly compose: <R, B, C>(ab: Kind3<F, R, B, C>, la: Kind3<F, R, A, B>) => Kind3<F, R, A, C>;
    // (undocumented)
    readonly _E: A;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Semigroupoid4<F extends URIS4> {
    // (undocumented)
    readonly compose: <S, R, A, B, C>(ab: Kind4<F, S, R, B, C>, la: Kind4<F, S, R, A, B>) => Kind4<F, S, R, A, C>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const Semigroupoid_2: Semigroupoid2<URI_28>;

// @public (undocumented)
const Semigroupoid_3: Semigroupoid2<URI_38>;

// @public @deprecated
const semigroupOrdering: semigroup.Semigroup<Ordering>;

// @public
const SemigroupProduct: Semigroup<number>;

// @public @deprecated
const semigroupProduct: Semigroup<number>;

// @public @deprecated
const semigroupString: Semigroup<string>;

// @public
const SemigroupSum: Semigroup<number>;

// @public @deprecated
const semigroupSum: Semigroup<number>;

// @public @deprecated
const semigroupVoid: Semigroup<void>;

// @public (undocumented)
interface Semiring<A> {
    // (undocumented)
    readonly add: (x: A, y: A) => A;
    // (undocumented)
    readonly mul: (x: A, y: A) => A;
    // (undocumented)
    readonly one: A;
    // (undocumented)
    readonly zero: A;
}

declare namespace semiring {
    export {
        Semiring,
        getFunctionSemiring
    }
}
export { semiring }

// @public
const separate: <A, B>(fa: Either<A, B>[]) => Separated<A[], B[]>;

// @public
const separate_10: <A, B>(fa: Record<string, Either<A, B>>) => Separated<Record<string, A>, Record<string, B>>;

// @public (undocumented)
function separate_11<E, A>(EE: Eq<E>, EA: Eq<A>): (fa: Set<Either<E, A>>) => Separated<Set<E>, Set<A>>;

// @public (undocumented)
const separate_12: Compactable1<URI_33>['separate'];

// @public (undocumented)
const separate_2: <A, B>(ma: Option_2<Either<A, B>>) => Separated<Option_2<A>, Option_2<B>>;

// @public
function separate_3<F extends URIS2, G extends URIS2, E>(F: Functor2<F>, C: Compactable2C<G, E>, G: Functor2<G>): <FE, A, B>(fge: Kind2<F, FE, Kind2<G, E, Either<A, B>>>) => separated.Separated<Kind2<F, FE, Kind2<G, E, A>>, Kind2<F, FE, Kind2<G, E, B>>>;

// @public (undocumented)
function separate_3<F extends URIS, G extends URIS2, E>(F: Functor1<F>, C: Compactable2C<G, E>, G: Functor2<G>): <A, B>(fge: Kind<F, Kind2<G, E, Either<A, B>>>) => separated.Separated<Kind<F, Kind2<G, E, A>>, Kind<F, Kind2<G, E, B>>>;

// @public (undocumented)
function separate_3<F extends URIS, G extends URIS>(F: Functor1<F>, C: Compactable1<G>, G: Functor1<G>): <A, B>(fge: Kind<F, Kind<G, Either<A, B>>>) => separated.Separated<Kind<F, Kind<G, A>>, Kind<F, Kind<G, B>>>;

// @public (undocumented)
function separate_3<F, G>(F: Functor<F>, C: Compactable_3<G>, G: Functor<G>): <A, B>(fge: HKT<F, HKT<G, Either<A, B>>>) => separated.Separated<HKT<F, HKT<G, A>>, HKT<F, HKT<G, B>>>;

// @public (undocumented)
const separate_4: Compactable1<URI_14>['separate'];

// @public (undocumented)
const separate_5: <K, A, B>(fa: Map<K, Either<A, B>>) => Separated<Map<K, A>, Map<K, B>>;

// @public (undocumented)
const separate_6: <A, B>(fa: readonly Either<A, B>[]) => Separated<readonly A[], readonly B[]>;

// @public (undocumented)
const separate_7: <K, A, B>(fa: ReadonlyMap<K, Either<A, B>>) => Separated<ReadonlyMap<K, A>, ReadonlyMap<K, B>>;

// @public
const separate_8: <A, B>(r: Readonly<Record<string, Either<A, B>>>) => Separated<Readonly<Record<string, A>>, Readonly<Record<string, B>>>;

// @public (undocumented)
function separate_9<E, A>(EE: Eq<E>, EA: Eq<A>): (fa: ReadonlySet<Either<E, A>>) => Separated<ReadonlySet<E>, ReadonlySet<A>>;

// @public
interface Separated<E, A> {
    // (undocumented)
    readonly left: E;
    // (undocumented)
    readonly right: A;
}

declare namespace separated {
    export {
        Separated,
        separated_2 as separated,
        map_5 as map,
        mapLeft,
        bimap,
        URI_5 as URI,
        Bifunctor,
        Functor_5 as Functor,
        flap_4 as flap,
        left,
        right
    }
}
export { separated }

// @public @deprecated
interface Separated_2<A, B> {
    // (undocumented)
    readonly left: A;
    // (undocumented)
    readonly right: B;
}

// @public (undocumented)
const separated_2: <E, A>(left: E, right: A) => Separated<E, A>;

// @public (undocumented)
interface Sequence<T> {
    // (undocumented)
    <F extends URIS4>(F: Applicative4<F>): <S, R, E, A>(ta: HKT<T, Kind4<F, S, R, E, A>>) => Kind4<F, S, R, E, HKT<T, A>>;
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <R, E, A>(ta: HKT<T, Kind3<F, R, E, A>>) => Kind3<F, R, E, HKT<T, A>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <R, A>(ta: HKT<T, Kind3<F, R, E, A>>) => Kind3<F, R, E, HKT<T, A>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <E, A>(ta: HKT<T, Kind2<F, E, A>>) => Kind2<F, E, HKT<T, A>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A>(ta: HKT<T, Kind2<F, E, A>>) => Kind2<F, E, HKT<T, A>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A>(ta: HKT<T, Kind<F, A>>) => Kind<F, HKT<T, A>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A>(ta: HKT<T, HKT<F, A>>) => HKT<F, HKT<T, A>>;
}

// @public (undocumented)
const sequence: Traversable1<URI_2>['sequence'];

// @public (undocumented)
interface Sequence1<T extends URIS> {
    // (undocumented)
    <F extends URIS4>(F: Applicative4<F>): <S, R, E, A>(ta: Kind<T, Kind4<F, S, R, E, A>>) => Kind4<F, S, R, E, Kind<T, A>>;
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <R, E, A>(ta: Kind<T, Kind3<F, R, E, A>>) => Kind3<F, R, E, Kind<T, A>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <R, A>(ta: Kind<T, Kind3<F, R, E, A>>) => Kind3<F, R, E, Kind<T, A>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <E, A>(ta: Kind<T, Kind2<F, E, A>>) => Kind2<F, E, Kind<T, A>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A>(ta: Kind<T, Kind2<F, E, A>>) => Kind2<F, E, Kind<T, A>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A>(ta: Kind<T, Kind<F, A>>) => Kind<F, Kind<T, A>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A>(ta: Kind<T, HKT<F, A>>) => HKT<F, Kind<T, A>>;
}

// @public (undocumented)
interface Sequence2<T extends URIS2> {
    // (undocumented)
    <F extends URIS4>(F: Applicative4<F>): <TE, S, R, FE, A>(ta: Kind2<T, TE, Kind4<F, S, R, FE, A>>) => Kind4<F, S, R, FE, Kind2<T, TE, A>>;
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <TE, R, FE, A>(ta: Kind2<T, TE, Kind3<F, R, FE, A>>) => Kind3<F, R, FE, Kind2<T, TE, A>>;
    // (undocumented)
    <F extends URIS3, FE>(F: Applicative3C<F, FE>): <TE, R, A>(ta: Kind2<T, TE, Kind3<F, R, FE, A>>) => Kind3<F, R, FE, Kind2<T, TE, A>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <TE, FE, A>(ta: Kind2<T, TE, Kind2<F, FE, A>>) => Kind2<F, FE, Kind2<T, TE, A>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <TE, A>(ta: Kind2<T, TE, Kind2<F, FE, A>>) => Kind2<F, FE, Kind2<T, TE, A>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <E, A>(ta: Kind2<T, E, Kind<F, A>>) => Kind<F, Kind2<T, E, A>>;
    // (undocumented)
    <F>(F: Applicative<F>): <E, A>(ta: Kind2<T, E, HKT<F, A>>) => HKT<F, Kind2<T, E, A>>;
}

// @public (undocumented)
interface Sequence2C<T extends URIS2, E> {
    // (undocumented)
    <F extends URIS4>(F: Applicative4<F>): <S, R, FE, A>(ta: Kind2<T, E, Kind4<F, S, R, FE, A>>) => Kind4<F, S, R, FE, Kind2<T, E, A>>;
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <R, FE, A>(ta: Kind2<T, E, Kind3<F, R, FE, A>>) => Kind3<F, R, FE, Kind2<T, E, A>>;
    // (undocumented)
    <F extends URIS3, FE>(F: Applicative3C<F, FE>): <R, A>(ta: Kind2<T, E, Kind3<F, R, FE, A>>) => Kind3<F, R, FE, Kind2<T, E, A>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <FE, A>(ta: Kind2<T, E, Kind2<F, FE, A>>) => Kind2<F, FE, Kind2<T, E, A>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <A>(ta: Kind2<T, E, Kind2<F, FE, A>>) => Kind2<F, FE, Kind2<T, E, A>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A>(ta: Kind2<T, E, Kind<F, A>>) => Kind<F, Kind2<T, E, A>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A>(ta: Kind2<T, E, HKT<F, A>>) => HKT<F, Kind2<T, E, A>>;
}

// @public (undocumented)
interface Sequence3<T extends URIS3> {
    // (undocumented)
    <F extends URIS4>(F: Applicative4<F>): <TR, TE, S, FR, FE, A>(ta: Kind3<T, TR, TE, Kind4<F, S, FR, FE, A>>) => Kind4<F, S, FR, FE, Kind3<T, TR, TE, A>>;
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <TR, TE, FR, FE, A>(ta: Kind3<T, TR, TE, Kind3<F, FR, FE, A>>) => Kind3<F, FR, FE, Kind3<T, TR, TE, A>>;
    // (undocumented)
    <F extends URIS3, FE>(F: Applicative3C<F, FE>): <TR, TE, FR, A>(ta: Kind3<T, TR, TE, Kind3<F, FR, FE, A>>) => Kind3<F, FR, FE, Kind3<T, TR, TE, A>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <R, TE, FE, A>(ta: Kind3<T, R, TE, Kind2<F, FE, A>>) => Kind2<F, FE, Kind3<T, R, TE, A>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <R, TE, A>(ta: Kind3<T, R, TE, Kind2<F, FE, A>>) => Kind2<F, FE, Kind3<T, R, TE, A>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <R, E, A>(ta: Kind3<T, R, E, Kind<F, A>>) => Kind<F, Kind3<T, R, E, A>>;
    // (undocumented)
    <F>(F: Applicative<F>): <R, E, A>(ta: Kind3<T, R, E, HKT<F, A>>) => HKT<F, Kind3<T, R, E, A>>;
}

// @public
function sequence_10<F extends URIS3>(F: Applicative3<F>): <K extends string, R, E, A>(ta: Record<K, Kind3<F, R, E, A>>) => Kind3<F, R, E, Record<K, A>>;

// @public (undocumented)
function sequence_10<F extends URIS3, E>(F: Applicative3C<F, E>): <K extends string, R, A>(ta: Record<K, Kind3<F, R, E, A>>) => Kind3<F, R, E, Record<K, A>>;

// @public (undocumented)
function sequence_10<F extends URIS2>(F: Applicative2<F>): <K extends string, E, A>(ta: Record<K, Kind2<F, E, A>>) => Kind2<F, E, Record<K, A>>;

// @public (undocumented)
function sequence_10<F extends URIS2, E>(F: Applicative2C<F, E>): <K extends string, A>(ta: Record<K, Kind2<F, E, A>>) => Kind2<F, E, Record<K, A>>;

// @public (undocumented)
function sequence_10<F extends URIS>(F: Applicative1<F>): <K extends string, A>(ta: Record<K, Kind<F, A>>) => Kind<F, Record<K, A>>;

// @public (undocumented)
function sequence_10<F>(F: Applicative<F>): <K extends string, A>(ta: Record<K, HKT<F, A>>) => HKT<F, Record<K, A>>;

// @public (undocumented)
const sequence_11: Traversable2<URI_35>['sequence'];

// @public
function sequence_12<T extends URIS, G extends URIS2>(T: Traversable1<T>, G: Traversable2<G>): {
    <F extends URIS4>(F: Applicative4<F>): <GE, S, R, FE, A>(tgfa: Kind<T, Kind2<G, GE, Kind4<F, S, R, FE, A>>>) => Kind4<F, S, R, FE, Kind<T, Kind2<G, GE, A>>>;
    <F extends URIS3>(F: Applicative3<F>): <GE, R, FE, A>(tgfa: Kind<T, Kind2<G, GE, Kind3<F, R, FE, A>>>) => Kind3<F, R, FE, Kind<T, Kind2<G, GE, A>>>;
    <F extends URIS3, FE>(F: Applicative3C<F, FE>): <GE, R, A>(tgfa: Kind<T, Kind2<G, GE, Kind3<F, R, FE, A>>>) => Kind3<F, R, FE, Kind<T, Kind2<G, GE, A>>>;
    <F extends URIS2>(F: Applicative2<F>): <GE, FE, A>(tgfa: Kind<T, Kind2<G, GE, Kind2<F, FE, A>>>) => Kind2<F, FE, Kind<T, Kind2<G, GE, A>>>;
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <GE, A>(tgfa: Kind<T, Kind2<G, GE, Kind2<F, FE, A>>>) => Kind2<F, FE, Kind<T, Kind2<G, GE, A>>>;
    <F extends URIS>(F: Applicative1<F>): <GE, A>(tgfa: Kind<T, Kind2<G, GE, Kind<F, A>>>) => Kind<F, Kind<T, Kind2<G, GE, A>>>;
    <F>(F: Applicative<F>): <A>(tgfa: HKT<T, HKT<G, HKT<F, A>>>) => HKT<F, HKT<T, HKT<G, A>>>;
};

// @public (undocumented)
function sequence_12<T extends URIS, G extends URIS>(T: Traversable1<T>, G: Traversable1<G>): {
    <F extends URIS4>(F: Applicative4<F>): <S, R, E, A>(tgfa: Kind<T, Kind<G, Kind4<F, S, R, E, A>>>) => Kind4<F, S, R, E, Kind<T, Kind<G, A>>>;
    <F extends URIS3>(F: Applicative3<F>): <R, E, A>(tgfa: Kind<T, Kind<G, Kind3<F, R, E, A>>>) => Kind3<F, R, E, Kind<T, Kind<G, A>>>;
    <F extends URIS3, E>(F: Applicative3C<F, E>): <R, A>(tgfa: Kind<T, Kind<G, Kind3<F, R, E, A>>>) => Kind3<F, R, E, Kind<T, Kind<G, A>>>;
    <F extends URIS2>(F: Applicative2<F>): <E, A>(tgfa: Kind<T, Kind<G, Kind2<F, E, A>>>) => Kind2<F, E, Kind<T, Kind<G, A>>>;
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A>(tgfa: Kind<T, Kind<G, Kind2<F, E, A>>>) => Kind2<F, E, Kind<T, Kind<G, A>>>;
    <F extends URIS>(F: Applicative1<F>): <A>(tgfa: Kind<T, Kind<G, Kind<F, A>>>) => Kind<F, Kind<T, Kind<G, A>>>;
    <F>(F: Applicative<F>): <A>(tgfa: HKT<T, HKT<G, HKT<F, A>>>) => HKT<F, HKT<T, HKT<G, A>>>;
};

// @public (undocumented)
function sequence_12<T, G>(T: Traversable_12<T>, G: Traversable_12<G>): <F>(F: Applicative<F>) => <A>(tgfa: HKT<T, HKT<G, HKT<F, A>>>) => HKT<F, HKT<T, HKT<G, A>>>;

// @public (undocumented)
const sequence_13: Traversable1<URI_37>['sequence'];

// @public (undocumented)
const sequence_14: Traversable2<URI_38>['sequence'];

// @public (undocumented)
const sequence_2: Traversable1<URI_3>['sequence'];

// @public
const sequence_3: Traversable1<URI_4>['sequence'];

// @public (undocumented)
const sequence_4: Traversable1<URI_7>['sequence'];

// @public
const sequence_5: Traversable2<URI_6>['sequence'];

// @public (undocumented)
const sequence_6: Traversable1<URI_11>['sequence'];

// @public (undocumented)
const sequence_7: Traversable1<URI_24>['sequence'];

// @public
function sequence_8<F extends URIS3>(F: Applicative3<F>): <K extends string, R, E, A>(ta: ReadonlyRecord<K, Kind3<F, R, E, A>>) => Kind3<F, R, E, ReadonlyRecord<K, A>>;

// @public (undocumented)
function sequence_8<F extends URIS3, E>(F: Applicative3C<F, E>): <K extends string, R, A>(ta: ReadonlyRecord<K, Kind3<F, R, E, A>>) => Kind3<F, R, E, ReadonlyRecord<K, A>>;

// @public (undocumented)
function sequence_8<F extends URIS2>(F: Applicative2<F>): <K extends string, E, A>(ta: ReadonlyRecord<K, Kind2<F, E, A>>) => Kind2<F, E, ReadonlyRecord<K, A>>;

// @public (undocumented)
function sequence_8<F extends URIS2, E>(F: Applicative2C<F, E>): <K extends string, A>(ta: ReadonlyRecord<K, Kind2<F, E, A>>) => Kind2<F, E, ReadonlyRecord<K, A>>;

// @public (undocumented)
function sequence_8<F extends URIS>(F: Applicative1<F>): <K extends string, A>(ta: ReadonlyRecord<K, Kind<F, A>>) => Kind<F, ReadonlyRecord<K, A>>;

// @public (undocumented)
function sequence_8<F>(F: Applicative<F>): <K extends string, A>(ta: ReadonlyRecord<K, HKT<F, A>>) => HKT<F, ReadonlyRecord<K, A>>;

// @public (undocumented)
const sequence_9: Traversable2<URI_28>['sequence'];

// @public
const sequenceArray: <A>(arr: ReadonlyArray<Option_2<A>>) => Option_2<ReadonlyArray<A>>;

// @public
const sequenceArray_10: <A, E>(arr: ReadonlyArray<TaskEither<E, A>>) => TaskEither<E, ReadonlyArray<A>>;

// @public
const sequenceArray_11: <R, E, A>(arr: ReadonlyArray<ReaderTaskEither<R, E, A>>) => ReaderTaskEither<R, E, ReadonlyArray<A>>;

// @public
const sequenceArray_12: <S, A>(arr: ReadonlyArray<State<S, A>>) => State<S, ReadonlyArray<A>>;

// @public
const sequenceArray_13: <S, R, E, A>(arr: ReadonlyArray<StateReaderTaskEither<S, R, E, A>>) => StateReaderTaskEither<S, R, E, ReadonlyArray<A>>;

// @public
const sequenceArray_14: <A>(as: ReadonlyArray<TaskOption<A>>) => TaskOption<ReadonlyArray<A>>;

// @public
const sequenceArray_2: <E, A>(as: ReadonlyArray<Either<E, A>>) => Either<E, ReadonlyArray<A>>;

// @public
const sequenceArray_3: <A>(arr: ReadonlyArray<IO<A>>) => IO<ReadonlyArray<A>>;

// @public
const sequenceArray_4: <E, A>(arr: ReadonlyArray<IOEither<E, A>>) => IOEither<E, ReadonlyArray<A>>;

// @public
const sequenceArray_5: <R, A>(arr: ReadonlyArray<Reader<R, A>>) => Reader<R, ReadonlyArray<A>>;

// @public
const sequenceArray_6: <R, E, A>(arr: ReadonlyArray<ReaderEither<R, E, A>>) => ReaderEither<R, E, ReadonlyArray<A>>;

// @public
const sequenceArray_7: <R, A>(arr: ReadonlyArray<ReaderIO<R, A>>) => ReaderIO<R, ReadonlyArray<A>>;

// @public
const sequenceArray_8: <A>(arr: ReadonlyArray<Task<A>>) => Task<ReadonlyArray<A>>;

// @public
const sequenceArray_9: <R, A>(arr: ReadonlyArray<ReaderTask<R, A>>) => ReaderTask<R, ReadonlyArray<A>>;

// @public @deprecated (undocumented)
interface SequenceComposition11<F extends URIS, G extends URIS> {
    // (undocumented)
    <H extends URIS3>(H: Applicative3<H>): <R, E, A>(fga: Kind<F, Kind<G, Kind3<H, R, E, A>>>) => Kind3<H, R, E, Kind<F, Kind<G, A>>>;
    // (undocumented)
    <H extends URIS2>(H: Applicative2<H>): <E, A>(fga: Kind<F, Kind<G, Kind2<H, E, A>>>) => Kind2<H, E, Kind<F, Kind<G, A>>>;
    // (undocumented)
    <H extends URIS2, E>(H: Applicative2C<H, E>): <A>(fga: Kind<F, Kind<G, Kind2<H, E, A>>>) => Kind2<H, E, Kind<F, Kind<G, A>>>;
    // (undocumented)
    <H extends URIS>(H: Applicative1<H>): <A>(fga: Kind<F, Kind<G, Kind<H, A>>>) => Kind<H, Kind<F, Kind<G, A>>>;
    // (undocumented)
    <H>(H: Applicative<H>): <A>(fga: Kind<F, Kind<G, HKT<H, A>>>) => HKT<H, Kind<F, Kind<G, A>>>;
}

// Warning: (ae-forgotten-export) The symbol "EnforceNonEmptyRecord" needs to be exported by the entry point index.d.ts
//
// @public
function sequenceS<F extends URIS4>(F: Apply4<F>): <S, R, E, NER extends Record<string, Kind4<F, S, R, E, any>>>(r: EnforceNonEmptyRecord<NER> & Record<string, Kind4<F, S, R, E, any>>) => Kind4<F, S, R, E, {
    [K in keyof NER]: [NER[K]] extends [Kind4<F, any, any, any, infer A>] ? A : never;
}>;

// @public (undocumented)
function sequenceS<F extends URIS3>(F: Apply3<F>): <R, E, NER extends Record<string, Kind3<F, R, E, any>>>(r: EnforceNonEmptyRecord<NER> & Record<string, Kind3<F, R, E, any>>) => Kind3<F, R, E, {
    [K in keyof NER]: [NER[K]] extends [Kind3<F, any, any, infer A>] ? A : never;
}>;

// @public (undocumented)
function sequenceS<F extends URIS3, E>(F: Apply3C<F, E>): <R, NER extends Record<string, Kind3<F, R, E, any>>>(r: EnforceNonEmptyRecord<NER> & Record<string, Kind3<F, R, E, any>>) => Kind3<F, R, E, {
    [K in keyof NER]: [NER[K]] extends [Kind3<F, any, any, infer A>] ? A : never;
}>;

// @public (undocumented)
function sequenceS<F extends URIS2>(F: Apply2<F>): <E, NER extends Record<string, Kind2<F, E, any>>>(r: EnforceNonEmptyRecord<NER> & Record<string, Kind2<F, E, any>>) => Kind2<F, E, {
    [K in keyof NER]: [NER[K]] extends [Kind2<F, any, infer A>] ? A : never;
}>;

// @public (undocumented)
function sequenceS<F extends URIS2, E>(F: Apply2C<F, E>): <NER extends Record<string, Kind2<F, E, any>>>(r: EnforceNonEmptyRecord<NER>) => Kind2<F, E, {
    [K in keyof NER]: [NER[K]] extends [Kind2<F, any, infer A>] ? A : never;
}>;

// @public (undocumented)
function sequenceS<F extends URIS>(F: Apply1<F>): <NER extends Record<string, Kind<F, any>>>(r: EnforceNonEmptyRecord<NER>) => Kind<F, {
    [K in keyof NER]: [NER[K]] extends [Kind<F, infer A>] ? A : never;
}>;

// @public (undocumented)
function sequenceS<F>(F: Apply<F>): <NER extends Record<string, HKT<F, any>>>(r: EnforceNonEmptyRecord<NER>) => HKT<F, {
    [K in keyof NER]: [NER[K]] extends [HKT<F, infer A>] ? A : never;
}>;

// @public
const sequenceSeqArray: <E, A>(arr: ReadonlyArray<IOEither<E, A>>) => IOEither<E, ReadonlyArray<A>>;

// @public
const sequenceSeqArray_2: <A>(arr: ReadonlyArray<Task<A>>) => Task<ReadonlyArray<A>>;

// @public @deprecated
const sequenceSeqArray_3: <R, A>(arr: ReadonlyArray<ReaderTask<R, A>>) => ReaderTask<R, ReadonlyArray<A>>;

// @public
const sequenceSeqArray_4: <A, E>(arr: ReadonlyArray<TaskEither<E, A>>) => TaskEither<E, ReadonlyArray<A>>;

// @public
const sequenceSeqArray_5: <R, E, A>(arr: ReadonlyArray<ReaderTaskEither<R, E, A>>) => ReaderTaskEither<R, E, ReadonlyArray<A>>;

// @public
const sequenceSeqArray_6: <A>(as: ReadonlyArray<TaskOption<A>>) => TaskOption<ReadonlyArray<A>>;

// @public
function sequenceT<F extends URIS4>(F: Apply4<F>): <S, R, E, T extends Array<Kind4<F, S, R, E, any>>>(...t: T & {
    readonly 0: Kind4<F, S, R, E, any>;
}) => Kind4<F, S, R, E, {
    [K in keyof T]: [T[K]] extends [Kind4<F, S, R, E, infer A>] ? A : never;
}>;

// @public (undocumented)
function sequenceT<F extends URIS3>(F: Apply3<F>): <R, E, T extends Array<Kind3<F, R, E, any>>>(...t: T & {
    readonly 0: Kind3<F, R, E, any>;
}) => Kind3<F, R, E, {
    [K in keyof T]: [T[K]] extends [Kind3<F, R, E, infer A>] ? A : never;
}>;

// @public (undocumented)
function sequenceT<F extends URIS3, E>(F: Apply3C<F, E>): <R, T extends Array<Kind3<F, R, E, any>>>(...t: T & {
    readonly 0: Kind3<F, R, E, any>;
}) => Kind3<F, R, E, {
    [K in keyof T]: [T[K]] extends [Kind3<F, R, E, infer A>] ? A : never;
}>;

// @public (undocumented)
function sequenceT<F extends URIS2>(F: Apply2<F>): <E, T extends Array<Kind2<F, E, any>>>(...t: T & {
    readonly 0: Kind2<F, E, any>;
}) => Kind2<F, E, {
    [K in keyof T]: [T[K]] extends [Kind2<F, E, infer A>] ? A : never;
}>;

// @public (undocumented)
function sequenceT<F extends URIS2, E>(F: Apply2C<F, E>): <T extends Array<Kind2<F, E, any>>>(...t: T & {
    readonly 0: Kind2<F, E, any>;
}) => Kind2<F, E, {
    [K in keyof T]: [T[K]] extends [Kind2<F, E, infer A>] ? A : never;
}>;

// @public (undocumented)
function sequenceT<F extends URIS>(F: Apply1<F>): <T extends Array<Kind<F, any>>>(...t: T & {
    readonly 0: Kind<F, any>;
}) => Kind<F, {
    [K in keyof T]: [T[K]] extends [Kind<F, infer A>] ? A : never;
}>;

// @public (undocumented)
function sequenceT<F>(F: Apply<F>): <T extends Array<HKT<F, any>>>(...t: T & {
    readonly 0: HKT<F, any>;
}) => HKT<F, {
    [K in keyof T]: [T[K]] extends [HKT<F, infer A>] ? A : never;
}>;

declare namespace set {
    export {
        map_32 as map,
        chain_24 as chain,
        filter_14 as filter,
        partition_12 as partition,
        union_10 as union,
        intersection_8 as intersection,
        partitionMap_12 as partitionMap,
        difference_8 as difference,
        insert_2 as insert,
        separate_11 as separate,
        filterMap_12 as filterMap,
        getShow_14 as getShow,
        getEq_14 as getEq,
        getUnionSemigroup_10 as getUnionSemigroup,
        getUnionMonoid_8 as getUnionMonoid,
        getIntersectionSemigroup_8 as getIntersectionSemigroup,
        getDifferenceMagma_8 as getDifferenceMagma,
        reduce_16 as reduce,
        foldMap_16 as foldMap,
        reduceRight_16 as reduceRight,
        singleton_6 as singleton,
        remove_2 as remove,
        toggle_2 as toggle,
        fromArray_5 as fromArray,
        compact_11 as compact,
        empty_8 as empty,
        isEmpty_8 as isEmpty,
        size_8 as size,
        some_9 as some,
        every_6 as every,
        isSubset_2 as isSubset,
        elem_10 as elem,
        toArray_5 as toArray,
        subset
    }
}
export { set }

// @public (undocumented)
interface Show<A> {
    // (undocumented)
    readonly show: (a: A) => string;
}

declare namespace show {
    export {
        Show,
        struct_5 as struct,
        tuple_6 as tuple,
        getTupleShow,
        getStructShow,
        showBoolean,
        showString,
        showNumber
    }
}
export { show }

// @public (undocumented)
const Show_2: show.Show<boolean>;

// @public (undocumented)
const Show_3: show.Show<number>;

// @public (undocumented)
const Show_4: show.Show<string>;

// @public @deprecated
const showBoolean: Show<boolean>;

// @public @deprecated
const showNumber: Show<number>;

// @public @deprecated
const showString: Show<string>;

// @public (undocumented)
const sign: (n: number) => Ordering;

// @public
const singleton: <K, A>(k: K, a: A) => Map<K, A>;

// @public
const singleton_2: <K, A>(k: K, a: A) => ReadonlyMap<K, A>;

// @public
const singleton_3: <A>(k: string, a: A) => Readonly<Record<string, A>>;

// @public
const singleton_4: <A>(a: A) => ReadonlySet<A>;

// @public
const singleton_5: <A>(k: string, a: A) => Record<string, A>;

// @public
const singleton_6: <A>(a: A) => Set<A>;

// @public
const size: <A>(as: A[]) => number;

// @public
const size_2: <K, A>(m: Map<K, A>) => number;

// @public
const size_3: <A>(as: readonly A[]) => number;

// @public
const size_4: <K, A>(m: ReadonlyMap<K, A>) => number;

// @public
const size_5: <A>(r: Readonly<Record<string, A>>) => number;

// @public
const size_6: <A>(set: ReadonlySet<A>) => number;

// @public
const size_7: <A>(r: Record<string, A>) => number;

// @public
const size_8: <A>(set: Set<A>) => number;

// @public
const size_9: (s: string) => number;

// @public (undocumented)
const SK: <A, B>(_: A, b: B) => B;

// @public (undocumented)
const slice: (start: number, end: number) => (s: string) => string;

// @public (undocumented)
function snd<A, E>(ea: readonly [A, E]): E;

// @public (undocumented)
const snd_2: <A, E>(ea: [A, E]) => E;

// @public @deprecated
const snoc: <A>(init: readonly A[], end: A) => ReadonlyNonEmptyArray<A>;

// @public @deprecated
const snoc_2: <A>(init: A[], end: A) => NonEmptyArray<A>;

// @public @deprecated
const snoc_3: <A>(init: A[], end: A) => nonEmptyArray.NonEmptyArray<A>;

// @public @deprecated
const snoc_4: <A>(init: readonly A[], end: A) => readonlyNonEmptyArray.ReadonlyNonEmptyArray<A>;

// @public (undocumented)
interface Some<A> {
    // (undocumented)
    readonly _tag: 'Some';
    // (undocumented)
    readonly value: A;
}

// @public
const some: <A>(a: A) => Option_2<A>;

// @public (undocumented)
const some_10: <A>(a: A) => TaskOption<A>;

// @public
const some_2: <A>(predicate: Predicate<A>) => (as: A[]) => as is nonEmptyArray.NonEmptyArray<A>;

// @public (undocumented)
const some_3: <A>(a: A) => IOOption<A>;

// @public (undocumented)
function some_4<F extends URIS4>(F: Pointed4<F>): <A, S, R, E>(a: A) => Kind4<F, S, R, E, Option_2<A>>;

// @public (undocumented)
function some_4<F extends URIS3>(F: Pointed3<F>): <A, R, E>(a: A) => Kind3<F, R, E, Option_2<A>>;

// @public (undocumented)
function some_4<F extends URIS3, E>(F: Pointed3C<F, E>): <A, R>(a: A) => Kind3<F, R, E, Option_2<A>>;

// @public (undocumented)
function some_4<F extends URIS2>(F: Pointed2<F>): <A, E>(a: A) => Kind2<F, E, Option_2<A>>;

// @public (undocumented)
function some_4<F extends URIS2, E>(F: Pointed2C<F, E>): <A>(a: A) => Kind2<F, E, Option_2<A>>;

// @public (undocumented)
function some_4<F extends URIS>(F: Pointed1<F>): <A>(a: A) => Kind<F, Option_2<A>>;

// @public (undocumented)
function some_4<F>(F: Pointed<F>): <A>(a: A) => HKT<F, Option_2<A>>;

// @public
const some_5: <A>(predicate: Predicate<A>) => (as: readonly A[]) => as is readonlyNonEmptyArray.ReadonlyNonEmptyArray<A>;

// @public
function some_6<A>(predicate: (a: A) => boolean): (r: ReadonlyRecord<string, A>) => boolean;

// @public (undocumented)
const some_7: <A>(predicate: Predicate<A>) => (set: ReadonlySet<A>) => boolean;

// @public
const some_8: <A>(predicate: (a: A) => boolean) => (r: Record<string, A>) => boolean;

// @public (undocumented)
const some_9: <A>(predicate: Predicate<A>) => (set: Set<A>) => boolean;

// @public (undocumented)
const sort: <B>(O: Ord<B>) => <A extends B>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public (undocumented)
const sort_2: <B>(O: Ord<B>) => <A extends B>(as: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public
const sort_3: <B>(O: Ord<B>) => <A extends B>(as: A[]) => A[];

// @public
const sort_4: <B>(O: Ord<B>) => <A extends B>(as: readonly A[]) => readonly A[];

// @public
const sortBy: <B>(ords: Ord<B>[]) => <A extends B>(as: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public
const sortBy_2: <B>(ords: readonly Ord<B>[]) => <A extends B>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public
const sortBy_3: <B>(ords: Ord<B>[]) => <A extends B>(as: A[]) => A[];

// @public
const sortBy_4: <B>(ords: readonly Ord<B>[]) => <A extends B>(as: readonly A[]) => readonly A[];

// @public
function spanLeft<A, B extends A>(refinement: Refinement<A, B>): (as: Array<A>) => Spanned<B, A>;

// @public (undocumented)
function spanLeft<A>(predicate: Predicate<A>): <B extends A>(bs: Array<B>) => Spanned<B, B>;

// @public (undocumented)
function spanLeft<A>(predicate: Predicate<A>): (as: Array<A>) => Spanned<A, A>;

// @public
function spanLeft_2<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => Spanned_2<B, A>;

// @public (undocumented)
function spanLeft_2<A>(predicate: Predicate<A>): <B extends A>(bs: ReadonlyArray<B>) => Spanned_2<B, B>;

// @public (undocumented)
function spanLeft_2<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Spanned_2<A, A>;

// @public
interface Spanned<I, R> {
    // (undocumented)
    init: Array<I>;
    // (undocumented)
    rest: Array<R>;
}

// @public (undocumented)
interface Spanned_2<I, R> {
    // (undocumented)
    readonly init: ReadonlyArray<I>;
    // (undocumented)
    readonly rest: ReadonlyArray<R>;
}

// @public
function split<P extends URIS4>(P: Choice4<P>, C: Category4<P>): <S, R, A, B, C, D>(pab: Kind4<P, S, R, A, B>, pcd: Kind4<P, S, R, C, D>) => Kind4<P, S, R, Either<A, C>, Either<B, D>>;

// @public (undocumented)
function split<P extends URIS3>(P: Choice3<P>, C: Category3<P>): <R, A, B, C, D>(pab: Kind3<P, R, A, B>, pcd: Kind3<P, R, C, D>) => Kind3<P, R, Either<A, C>, Either<B, D>>;

// @public (undocumented)
function split<P extends URIS2>(P: Choice2<P>, C: Category2<P>): <A, B, C, D>(pab: Kind2<P, A, B>, pcd: Kind2<P, C, D>) => Kind2<P, Either<A, C>, Either<B, D>>;

// @public (undocumented)
function split<P>(P: Choice<P>, C: Category<P>): <A, B, C, D>(pab: HKT2<P, A, B>, pcd: HKT2<P, C, D>) => HKT2<P, Either<A, C>, Either<B, D>>;

// @public (undocumented)
const split_2: (separator: string | RegExp) => (s: string) => ReadonlyNonEmptyArray<string>;

// @public
function split_3<F extends URIS4>(S: Strong4<F>, C: Category4<F>): <S, R, A, B, C, D>(pab: Kind4<F, S, R, A, B>, pcd: Kind4<F, S, R, C, D>) => Kind4<F, S, R, [A, C], [B, D]>;

// @public (undocumented)
function split_3<F extends URIS3>(S: Strong3<F>, C: Category3<F>): <R, A, B, C, D>(pab: Kind3<F, R, A, B>, pcd: Kind3<F, R, C, D>) => Kind3<F, R, [A, C], [B, D]>;

// @public (undocumented)
function split_3<F extends URIS2>(S: Strong2<F>, C: Category2<F>): <A, B, C, D>(pab: Kind2<F, A, B>, pcd: Kind2<F, C, D>) => Kind2<F, [A, C], [B, D]>;

// @public (undocumented)
function split_3<F>(S: Strong_2<F>, C: Category<F>): <A, B, C, D>(pab: HKT2<F, A, B>, pcd: HKT2<F, C, D>) => HKT2<F, [A, C], [B, D]>;

// @public
const splitAt: (n: number) => <A>(as: ReadonlyNonEmptyArray<A>) => readonly [ReadonlyNonEmptyArray<A>, readonly A[]];

// @public
const splitAt_2: (n: number) => <A>(as: NonEmptyArray<A>) => [NonEmptyArray<A>, A[]];

// @public
const splitAt_3: (n: number) => <A>(as: A[]) => [A[], A[]];

// @public
const splitAt_4: (n: number) => <A>(as: readonly A[]) => readonly [readonly A[], readonly A[]];

// @public @deprecated
function splitChoice<F extends URIS3>(F: Category3<F> & Choice3<F>): <R, A, B, C, D>(pab: Kind3<F, R, A, B>, pcd: Kind3<F, R, C, D>) => Kind3<F, R, Either<A, C>, Either<B, D>>;

// @public @deprecated (undocumented)
function splitChoice<F extends URIS2>(F: Category2<F> & Choice2<F>): <A, B, C, D>(pab: Kind2<F, A, B>, pcd: Kind2<F, C, D>) => Kind2<F, Either<A, C>, Either<B, D>>;

// @public @deprecated (undocumented)
function splitChoice<F>(F: Category<F> & Choice<F>): <A, B, C, D>(pab: HKT2<F, A, B>, pcd: HKT2<F, C, D>) => HKT2<F, Either<A, C>, Either<B, D>>;

// @public @deprecated
function splitStrong<F extends URIS4>(F: Category4<F> & Strong4<F>): <S, R, A, B, C, D>(pab: Kind4<F, S, R, A, B>, pcd: Kind4<F, S, R, C, D>) => Kind4<F, S, R, [A, C], [B, D]>;

// @public @deprecated (undocumented)
function splitStrong<F extends URIS3>(F: Category3<F> & Strong3<F>): <R, A, B, C, D>(pab: Kind3<F, R, A, B>, pcd: Kind3<F, R, C, D>) => Kind3<F, R, [A, C], [B, D]>;

// @public @deprecated (undocumented)
function splitStrong<F extends URIS2>(F: Category2<F> & Strong2<F>): <A, B, C, D>(pab: Kind2<F, A, B>, pcd: Kind2<F, C, D>) => Kind2<F, [A, C], [B, D]>;

// @public @deprecated (undocumented)
function splitStrong<F>(F: Category<F> & Strong_2<F>): <A, B, C, D>(pab: HKT2<F, A, B>, pcd: HKT2<F, C, D>) => HKT2<F, [A, C], [B, D]>;

// @public (undocumented)
const startsWith: (searchString: string, position?: number) => (s: string) => boolean;

// @public (undocumented)
interface State<S, A> {
    // (undocumented)
    (s: S): [A, S];
}

declare namespace state {
    export {
        State,
        get_2 as get,
        put_2 as put,
        modify_2 as modify,
        gets_2 as gets,
        map_33 as map,
        ap_23 as ap,
        of_19 as of,
        flatMap_18 as flatMap,
        flatten_18 as flatten,
        URI_30 as URI,
        Functor_26 as Functor,
        flap_26 as flap,
        Pointed_19 as Pointed,
        Apply_14 as Apply,
        apFirst_19 as apFirst,
        apSecond_19 as apSecond,
        Applicative_15 as Applicative,
        Chain_19 as Chain,
        chainRec_14 as chainRec,
        ChainRec_15 as ChainRec,
        Monad_19 as Monad,
        tap_13 as tap,
        FromState_2 as FromState,
        evaluate,
        execute,
        bindTo_19 as bindTo,
        let__18 as let,
        bind_19 as bind,
        do__14 as do,
        apS_19 as apS,
        traverseReadonlyNonEmptyArrayWithIndex_13 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_13 as traverseReadonlyArrayWithIndex,
        traverseArrayWithIndex_12 as traverseArrayWithIndex,
        traverseArray_12 as traverseArray,
        sequenceArray_12 as sequenceArray,
        chain_25 as chain,
        chainFirst_19 as chainFirst,
        evalState,
        execState,
        state_2 as state
    }
}
export { state }

// @public @deprecated
const state_2: Monad2<URI_30>;

// @public @deprecated (undocumented)
interface StateM<M> {
    // (undocumented)
    readonly ap: <S, A, B>(fab: StateT<M, S, (a: A) => B>, fa: StateT<M, S, A>) => StateT<M, S, B>;
    // (undocumented)
    readonly chain: <S, A, B>(fa: StateT<M, S, A>, f: (a: A) => StateT<M, S, B>) => StateT<M, S, B>;
    // (undocumented)
    readonly evalState: <S, A>(ma: StateT<M, S, A>, s: S) => HKT<M, A>;
    // (undocumented)
    readonly execState: <S, A>(ma: StateT<M, S, A>, s: S) => HKT<M, S>;
    // (undocumented)
    readonly fromM: <S, A>(ma: HKT<M, A>) => StateT<M, S, A>;
    // (undocumented)
    readonly fromState: <S, A>(fa: State<S, A>) => StateT<M, S, A>;
    // (undocumented)
    readonly get: <S>() => StateT<M, S, S>;
    // (undocumented)
    readonly gets: <S, A>(f: (s: S) => A) => StateT<M, S, A>;
    // (undocumented)
    readonly map: <S, A, B>(fa: StateT<M, S, A>, f: (a: A) => B) => StateT<M, S, B>;
    // (undocumented)
    readonly modify: <S>(f: (s: S) => S) => StateT<M, S, void>;
    // (undocumented)
    readonly of: <S, A>(a: A) => StateT<M, S, A>;
    // (undocumented)
    readonly put: <S>(s: S) => StateT<M, S, void>;
}

// @public @deprecated (undocumented)
interface StateM1<M extends URIS> {
    // (undocumented)
    readonly ap: <S, A, B>(fab: StateT1<M, S, (a: A) => B>, fa: StateT1<M, S, A>) => StateT1<M, S, B>;
    // (undocumented)
    readonly chain: <S, A, B>(fa: StateT1<M, S, A>, f: (a: A) => StateT1<M, S, B>) => StateT1<M, S, B>;
    // (undocumented)
    readonly evalState: <S, A>(ma: StateT1<M, S, A>, s: S) => Kind<M, A>;
    // (undocumented)
    readonly execState: <S, A>(ma: StateT1<M, S, A>, s: S) => Kind<M, S>;
    // (undocumented)
    readonly fromM: <S, A>(ma: Kind<M, A>) => StateT1<M, S, A>;
    // (undocumented)
    readonly fromState: <S, A>(fa: State<S, A>) => StateT1<M, S, A>;
    // (undocumented)
    readonly get: <S>() => StateT1<M, S, S>;
    // (undocumented)
    readonly gets: <S, A>(f: (s: S) => A) => StateT1<M, S, A>;
    // (undocumented)
    readonly map: <S, A, B>(fa: StateT1<M, S, A>, f: (a: A) => B) => StateT1<M, S, B>;
    // (undocumented)
    readonly modify: <S>(f: (s: S) => S) => StateT1<M, S, void>;
    // (undocumented)
    readonly of: <S, A>(a: A) => StateT1<M, S, A>;
    // (undocumented)
    readonly put: <S>(s: S) => StateT1<M, S, void>;
}

// @public @deprecated (undocumented)
interface StateM2<M extends URIS2> {
    // (undocumented)
    readonly ap: <S, E, A, B>(fab: StateT2<M, S, E, (a: A) => B>, fa: StateT2<M, S, E, A>) => StateT2<M, S, E, B>;
    // (undocumented)
    readonly chain: <S, E, A, B>(fa: StateT2<M, S, E, A>, f: (a: A) => StateT2<M, S, E, B>) => StateT2<M, S, E, B>;
    // (undocumented)
    readonly evalState: <S, E, A>(ma: StateT2<M, S, E, A>, s: S) => Kind2<M, E, A>;
    // (undocumented)
    readonly execState: <S, E, A>(ma: StateT2<M, S, E, A>, s: S) => Kind2<M, E, S>;
    // (undocumented)
    readonly fromM: <S, E, A>(ma: Kind2<M, E, A>) => StateT2<M, S, E, A>;
    // (undocumented)
    readonly fromState: <S, E, A>(fa: State<S, A>) => StateT2<M, S, E, A>;
    // (undocumented)
    readonly get: <E, S>() => StateT2<M, S, E, S>;
    // (undocumented)
    readonly gets: <S, E, A>(f: (s: S) => A) => StateT2<M, S, E, A>;
    // (undocumented)
    readonly map: <S, E, A, B>(fa: StateT2<M, S, E, A>, f: (a: A) => B) => StateT2<M, S, E, B>;
    // (undocumented)
    readonly modify: <E, S>(f: (s: S) => S) => StateT2<M, S, E, void>;
    // (undocumented)
    readonly of: <S, E, A>(a: A) => StateT2<M, S, E, A>;
    // (undocumented)
    readonly put: <E, S>(s: S) => StateT2<M, S, E, void>;
}

// @public @deprecated (undocumented)
interface StateM2C<M extends URIS2, E> {
    // (undocumented)
    readonly ap: <S, A, B>(fab: StateT2<M, S, E, (a: A) => B>, fa: StateT2<M, S, E, A>) => StateT2<M, S, E, B>;
    // (undocumented)
    readonly chain: <S, A, B>(fa: StateT2<M, S, E, A>, f: (a: A) => StateT2<M, S, E, B>) => StateT2<M, S, E, B>;
    // (undocumented)
    readonly evalState: <S, A>(ma: StateT2<M, S, E, A>, s: S) => Kind2<M, E, A>;
    // (undocumented)
    readonly execState: <S, A>(ma: StateT2<M, S, E, A>, s: S) => Kind2<M, E, S>;
    // (undocumented)
    readonly fromM: <S, A>(ma: Kind2<M, E, A>) => StateT2<M, S, E, A>;
    // (undocumented)
    readonly fromState: <S, A>(fa: State<S, A>) => StateT2<M, S, E, A>;
    // (undocumented)
    readonly get: <S>() => StateT2<M, S, E, S>;
    // (undocumented)
    readonly gets: <S, A>(f: (s: S) => A) => StateT2<M, S, E, A>;
    // (undocumented)
    readonly map: <S, A, B>(fa: StateT2<M, S, E, A>, f: (a: A) => B) => StateT2<M, S, E, B>;
    // (undocumented)
    readonly modify: <S>(f: (s: S) => S) => StateT2<M, S, E, void>;
    // (undocumented)
    readonly of: <S, A>(a: A) => StateT2<M, S, E, A>;
    // (undocumented)
    readonly put: <S>(s: S) => StateT2<M, S, E, void>;
}

// @public @deprecated (undocumented)
interface StateM3<M extends URIS3> {
    // (undocumented)
    readonly ap: <S, R, E, A, B>(fab: StateT3<M, S, R, E, (a: A) => B>, fa: StateT3<M, S, R, E, A>) => StateT3<M, S, R, E, B>;
    // (undocumented)
    readonly chain: <S, R, E, A, B>(fa: StateT3<M, S, R, E, A>, f: (a: A) => StateT3<M, S, R, E, B>) => StateT3<M, S, R, E, B>;
    // (undocumented)
    readonly evalState: <S, R, E, A>(ma: StateT3<M, S, R, E, A>, s: S) => Kind3<M, R, E, A>;
    // (undocumented)
    readonly execState: <S, R, E, A>(ma: StateT3<M, S, R, E, A>, s: S) => Kind3<M, R, E, S>;
    // (undocumented)
    readonly fromM: <S, R, E, A>(ma: Kind3<M, R, E, A>) => StateT3<M, S, R, E, A>;
    // (undocumented)
    readonly fromState: <S, R, E, A>(fa: State<S, A>) => StateT3<M, S, R, E, A>;
    // (undocumented)
    readonly get: <R, E, S>() => StateT3<M, S, R, E, S>;
    // (undocumented)
    readonly gets: <S, R, E, A>(f: (s: S) => A) => StateT3<M, S, R, E, A>;
    // (undocumented)
    readonly map: <S, R, E, A, B>(fa: StateT3<M, S, R, E, A>, f: (a: A) => B) => StateT3<M, S, R, E, B>;
    // (undocumented)
    readonly modify: <R, E, S>(f: (s: S) => S) => StateT3<M, S, R, E, void>;
    // (undocumented)
    readonly of: <S, R, E, A>(a: A) => StateT3<M, S, R, E, A>;
    // (undocumented)
    readonly put: <R, E, S>(s: S) => StateT3<M, S, R, E, void>;
}

// @public @deprecated (undocumented)
interface StateM3C<M extends URIS3, E> {
    // (undocumented)
    readonly ap: <S, R, A, B>(fab: StateT3<M, S, R, E, (a: A) => B>, fa: StateT3<M, S, R, E, A>) => StateT3<M, S, R, E, B>;
    // (undocumented)
    readonly chain: <S, R, A, B>(fa: StateT3<M, S, R, E, A>, f: (a: A) => StateT3<M, S, R, E, B>) => StateT3<M, S, R, E, B>;
    // (undocumented)
    readonly evalState: <S, R, A>(ma: StateT3<M, S, R, E, A>, s: S) => Kind3<M, R, E, A>;
    // (undocumented)
    readonly execState: <S, R, A>(ma: StateT3<M, S, R, E, A>, s: S) => Kind3<M, R, E, S>;
    // (undocumented)
    readonly fromM: <S, R, A>(ma: Kind3<M, R, E, A>) => StateT3<M, S, R, E, A>;
    // (undocumented)
    readonly fromState: <S, R, A>(fa: State<S, A>) => StateT3<M, S, R, E, A>;
    // (undocumented)
    readonly get: <R, S>() => StateT3<M, S, R, E, S>;
    // (undocumented)
    readonly gets: <S, R, A>(f: (s: S) => A) => StateT3<M, S, R, E, A>;
    // (undocumented)
    readonly map: <S, R, A, B>(fa: StateT3<M, S, R, E, A>, f: (a: A) => B) => StateT3<M, S, R, E, B>;
    // (undocumented)
    readonly modify: <R, S>(f: (s: S) => S) => StateT3<M, S, R, E, void>;
    // (undocumented)
    readonly of: <S, R, A>(a: A) => StateT3<M, S, R, E, A>;
    // (undocumented)
    readonly put: <R, S>(s: S) => StateT3<M, S, R, E, void>;
}

// @public (undocumented)
interface StateReaderTaskEither<S, R, E, A> {
    // (undocumented)
    (s: S): ReaderTaskEither<R, E, [A, S]>;
}

declare namespace stateReaderTaskEither {
    export {
        rightTask_3 as rightTask,
        leftTask_3 as leftTask,
        rightReader_3 as rightReader,
        leftReader_3 as leftReader,
        rightIO_4 as rightIO,
        leftIO_4 as leftIO,
        run_3 as run,
        StateReaderTaskEither,
        left_9 as left,
        right_9 as right,
        rightState,
        leftState,
        fromEither_11 as fromEither,
        fromReader_7 as fromReader,
        fromIO_10 as fromIO,
        fromTask_6 as fromTask,
        fromState_2 as fromState,
        fromTaskEither_2 as fromTaskEither,
        fromIOEither_4 as fromIOEither,
        fromReaderEither_2 as fromReaderEither,
        fromReaderTaskEither,
        local_6 as local,
        asksStateReaderTaskEitherW,
        asksStateReaderTaskEither,
        fromIOEitherK_3 as fromIOEitherK,
        fromTaskEitherK_2 as fromTaskEitherK,
        fromReaderTaskEitherK,
        chainReaderTaskEitherKW,
        chainReaderTaskEitherK,
        map_34 as map,
        bimap_11 as bimap,
        mapLeft_11 as mapLeft,
        ap_24 as ap,
        apW_9 as apW,
        of_20 as of,
        flatMap_19 as flatMap,
        flatMapTaskEither_2 as flatMapTaskEither,
        flatMapIO_8 as flatMapIO,
        flatMapTask_4 as flatMapTask,
        flatMapReader_5 as flatMapReader,
        flatMapIOEither_3 as flatMapIOEither,
        flatMapEither_6 as flatMapEither,
        flatMapOption_7 as flatMapOption,
        flatMapReaderTaskEither,
        flatMapState,
        flattenW_9 as flattenW,
        flatten_19 as flatten,
        altW_13 as altW,
        alt_17 as alt,
        throwError_8 as throwError,
        URI_31 as URI,
        Functor_27 as Functor,
        as_12 as as,
        asUnit_12 as asUnit,
        flap_27 as flap,
        Pointed_20 as Pointed,
        Apply_15 as Apply,
        apFirst_20 as apFirst,
        apFirstW_7 as apFirstW,
        apSecond_20 as apSecond,
        apSecondW_7 as apSecondW,
        Applicative_16 as Applicative,
        Chain_20 as Chain,
        chainRec_15 as chainRec,
        ChainRec_16 as ChainRec,
        FromState_3 as FromState,
        get_3 as get,
        put_3 as put,
        modify_3 as modify,
        gets_3 as gets,
        fromStateK_2 as fromStateK,
        chainStateK_2 as chainStateK,
        Monad_20 as Monad,
        MonadIO_10 as MonadIO,
        MonadTask_6 as MonadTask,
        MonadThrow_9 as MonadThrow,
        FromEither_11 as FromEither,
        FromIO_10 as FromIO,
        FromTask_6 as FromTask,
        FromReader_6 as FromReader,
        tap_14 as tap,
        tapEither_7 as tapEither,
        tapIO_8 as tapIO,
        tapTask_4 as tapTask,
        tapReader_6 as tapReader,
        Bifunctor_10 as Bifunctor,
        Alt_14 as Alt,
        ask_7 as ask,
        asks_7 as asks,
        fromReaderK_6 as fromReaderK,
        chainReaderK_6 as chainReaderK,
        chainReaderKW_5 as chainReaderKW,
        chainFirstReaderK_6 as chainFirstReaderK,
        chainFirstReaderKW_5 as chainFirstReaderKW,
        fromOption_10 as fromOption,
        fromOptionK_12 as fromOptionK,
        chainOptionK_9 as chainOptionK,
        chainOptionKW_6 as chainOptionKW,
        chainEitherK_8 as chainEitherK,
        chainEitherKW_5 as chainEitherKW,
        chainFirstEitherK_8 as chainFirstEitherK,
        chainFirstEitherKW_5 as chainFirstEitherKW,
        fromPredicate_12 as fromPredicate,
        filterOrElse_7 as filterOrElse,
        filterOrElseW_6 as filterOrElseW,
        fromEitherK_11 as fromEitherK,
        fromIOK_9 as fromIOK,
        chainIOK_9 as chainIOK,
        chainFirstIOK_9 as chainFirstIOK,
        chainTaskEitherKW_2 as chainTaskEitherKW,
        chainTaskEitherK_2 as chainTaskEitherK,
        chainIOEitherKW_3 as chainIOEitherKW,
        chainIOEitherK_3 as chainIOEitherK,
        fromTaskK_5 as fromTaskK,
        chainTaskK_5 as chainTaskK,
        chainFirstTaskK_5 as chainFirstTaskK,
        evaluate_2 as evaluate,
        execute_2 as execute,
        bindTo_20 as bindTo,
        let__19 as let,
        bind_20 as bind,
        bindW_9 as bindW,
        do__15 as do,
        apS_20 as apS,
        apSW_9 as apSW,
        traverseReadonlyNonEmptyArrayWithIndex_14 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_14 as traverseReadonlyArrayWithIndex,
        traverseArrayWithIndex_13 as traverseArrayWithIndex,
        traverseArray_13 as traverseArray,
        sequenceArray_13 as sequenceArray,
        chain_26 as chain,
        chainW_9 as chainW,
        chainFirst_20 as chainFirst,
        chainFirstW_9 as chainFirstW,
        stateReaderTaskEither_2 as stateReaderTaskEither,
        stateReaderTaskEitherSeq,
        evalState_2 as evalState,
        execState_2 as execState
    }
}
export { stateReaderTaskEither }

// @public @deprecated
const stateReaderTaskEither_2: Monad4<URI_31> & Bifunctor4<URI_31> & Alt4<URI_31> & MonadTask4<URI_31> & MonadThrow4<URI_31>;

// @public @deprecated
const stateReaderTaskEitherSeq: typeof stateReaderTaskEither_2;

// @public (undocumented)
interface StateT<M, S, A> {
    // (undocumented)
    (s: S): HKT<M, [A, S]>;
}

declare namespace stateT {
    export {
        of_21 as of,
        map_35 as map,
        ap_25 as ap,
        chain_27 as chain,
        fromState_3 as fromState,
        fromF_2 as fromF,
        evaluate_3 as evaluate,
        execute_3 as execute,
        getStateM,
        StateT,
        StateT1,
        StateT2,
        StateT3,
        StateM,
        StateM1,
        StateM2,
        StateM2C,
        StateM3,
        StateM3C
    }
}
export { stateT }

// @public (undocumented)
interface StateT1<M extends URIS, S, A> {
    // (undocumented)
    (s: S): Kind<M, [A, S]>;
}

// @public (undocumented)
interface StateT2<M extends URIS2, S, E, A> {
    // (undocumented)
    (s: S): Kind2<M, E, [A, S]>;
}

// @public (undocumented)
interface StateT3<M extends URIS3, S, R, E, A> {
    // (undocumented)
    (s: S): Kind3<M, R, E, [A, S]>;
}

// @public (undocumented)
interface Store<S, A> {
    // (undocumented)
    readonly peek: (s: S) => A;
    // (undocumented)
    readonly pos: S;
}

declare namespace store {
    export {
        seek,
        seeks,
        peeks,
        experiment,
        Store,
        extend_11 as extend,
        extract_5 as extract,
        duplicate_9 as duplicate,
        map_36 as map,
        URI_32 as URI,
        Functor_28 as Functor,
        flap_28 as flap,
        Comonad_6 as Comonad,
        store_2 as store
    }
}
export { store }

// @public @deprecated
const store_2: Comonad2<URI_32>;

// @public @deprecated
const strictEqual: <A>(a: A, b: A) => boolean;

declare namespace string {
    export {
        Eq_6 as Eq,
        Semigroup_3 as Semigroup,
        empty_9 as empty,
        Monoid_3 as Monoid,
        Ord_5 as Ord,
        Show_4 as Show,
        isString,
        toUpperCase,
        toLowerCase,
        replace,
        trim,
        trimLeft,
        trimRight,
        slice,
        isEmpty_9 as isEmpty,
        size_9 as size,
        split_2 as split,
        includes,
        startsWith,
        endsWith
    }
}
export { string }

// @public
const stringify: <A>(a: A) => Either<unknown, string>;

// @public @deprecated
const stringifyJSON: <E>(u: unknown, onError: (reason: unknown) => E) => Either<E, string>;

// @public (undocumented)
const Strong: Strong2<URI_17>;

declare namespace strong {
    export {
        split_3 as split,
        fanOut,
        splitStrong,
        fanout,
        Strong_2 as Strong,
        Strong2,
        Strong3,
        Strong4
    }
}
export { strong }

// @public (undocumented)
interface Strong2<F extends URIS2> extends Profunctor2<F> {
    // (undocumented)
    readonly first: <A, B, C>(pab: Kind2<F, A, B>) => Kind2<F, [A, C], [B, C]>;
    // (undocumented)
    readonly second: <A, B, C>(pab: Kind2<F, B, C>) => Kind2<F, [A, B], [A, C]>;
}

// @public (undocumented)
interface Strong3<F extends URIS3> extends Profunctor3<F> {
    // (undocumented)
    readonly first: <R, A, B, C>(pab: Kind3<F, R, A, B>) => Kind3<F, R, [A, C], [B, C]>;
    // (undocumented)
    readonly second: <R, A, B, C>(pab: Kind3<F, R, B, C>) => Kind3<F, R, [A, B], [A, C]>;
}

// @public (undocumented)
interface Strong4<F extends URIS4> extends Profunctor4<F> {
    // (undocumented)
    readonly first: <S, R, A, B, C>(pab: Kind4<F, S, R, A, B>) => Kind4<F, S, R, [A, C], [B, C]>;
    // (undocumented)
    readonly second: <S, R, A, B, C>(pab: Kind4<F, S, R, B, C>) => Kind4<F, S, R, [A, B], [A, C]>;
}

// @public (undocumented)
interface Strong_2<F> extends Profunctor<F> {
    // (undocumented)
    readonly first: <A, B, C>(pab: HKT2<F, A, B>) => HKT2<F, [A, C], [B, C]>;
    // (undocumented)
    readonly second: <A, B, C>(pab: HKT2<F, B, C>) => HKT2<F, [A, B], [A, C]>;
}

declare namespace struct {
    export {
        getAssignSemigroup,
        evolve
    }
}
export { struct }

// @public
const struct_2: <A>(semigroups: { [K in keyof A]: Semigroup<A[K]>; }) => Semigroup<{ readonly [K_1 in keyof A]: A[K_1]; }>;

// @public
const struct_3: <A>(monoids: { [K in keyof A]: Monoid<A[K]>; }) => Monoid<{ readonly [K_1 in keyof A]: A[K_1]; }>;

// @public (undocumented)
const struct_4: <A>(eqs: { [K in keyof A]: Eq<A[K]>; }) => Eq<{ readonly [K_1 in keyof A]: A[K_1]; }>;

// @public (undocumented)
const struct_5: <A>(shows: { [K in keyof A]: Show<A[K]>; }) => Show<{ readonly [K_1 in keyof A]: A[K_1]; }>;

// @public @deprecated
const subset: <A>(E: Eq<A>) => {
    (that: Set<A>): (me: Set<A>) => boolean;
    (me: Set<A>, that: Set<A>): boolean;
};

// @public
const swap: <E, A>(ma: Either<E, A>) => Either<A, E>;

// @public (undocumented)
function swap_10<F extends URIS3>(F: Functor3<F>): <R, FE, E, A>(ma: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<A, E>>;

// @public (undocumented)
function swap_10<F extends URIS3, FE>(F: Functor3C<F, FE>): <R, E, A>(ma: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<A, E>>;

// @public (undocumented)
function swap_10<F extends URIS2>(F: Functor2<F>): <FE, E, A>(ma: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<A, E>>;

// @public (undocumented)
function swap_10<F extends URIS2, FE>(F: Functor2C<F, FE>): <E, A>(ma: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<A, E>>;

// @public (undocumented)
function swap_10<F extends URIS>(F: Functor1<F>): <E, A>(ma: Kind<F, These<E, A>>) => Kind<F, These<A, E>>;

// @public (undocumented)
function swap_10<F>(F: Functor<F>): <E, A>(ma: HKT<F, These<E, A>>) => HKT<F, These<A, E>>;

// @public (undocumented)
const swap_11: <A, E>(ea: [A, E]) => [E, A];

// @public (undocumented)
function swap_2<F extends URIS3>(F: Functor3<F>): <R, FE, E, A>(ma: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<A, E>>;

// @public (undocumented)
function swap_2<F extends URIS3, FE>(F: Functor3C<F, FE>): <R, E, A>(ma: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<A, E>>;

// @public (undocumented)
function swap_2<F extends URIS2>(F: Functor2<F>): <FE, E, A>(ma: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<A, E>>;

// @public (undocumented)
function swap_2<F extends URIS2, FE>(F: Functor2C<F, FE>): <E, A>(ma: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<A, E>>;

// @public (undocumented)
function swap_2<F extends URIS>(F: Functor1<F>): <E, A>(ma: Kind<F, Either<E, A>>) => Kind<F, Either<A, E>>;

// @public (undocumented)
function swap_2<F>(F: Functor<F>): <E, A>(ma: HKT<F, Either<E, A>>) => HKT<F, Either<A, E>>;

// @public (undocumented)
const swap_3: <E, A>(ma: IOEither<E, A>) => IOEither<A, E>;

// @public (undocumented)
const swap_4: <R, E, A>(ma: ReaderEither<R, E, A>) => ReaderEither<R, A, E>;

// @public (undocumented)
const swap_5: <R, E, A>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, A, E>;

// @public (undocumented)
const swap_6: <E, A>(ma: TaskEither<E, A>) => TaskEither<A, E>;

// @public (undocumented)
const swap_7: <A, E>(ea: readonly [A, E]) => readonly [E, A];

// @public (undocumented)
const swap_8: <E, A>(fa: TaskThese<E, A>) => TaskThese<A, E>;

// @public (undocumented)
const swap_9: <E, A>(fa: These<E, A>) => These<A, E>;

// @public (undocumented)
const tail: <A>(as: ReadonlyNonEmptyArray<A>) => ReadonlyArray<A>;

// @public (undocumented)
const tail_2: <A>(as: NonEmptyArray<A>) => A[];

// @public
const tail_3: <A>(as: A[]) => Option_2<A[]>;

// @public
const tail_4: <A>(as: readonly A[]) => Option_2<readonly A[]>;

// @public (undocumented)
const tailRec: <A, B>(startWith: A, f: (a: A) => either.Either<A, B>) => B;

// @public (undocumented)
const tailRec2: <A, B, C>(a: A, b: B, f: (a: A, b: B) => either.Either<readonly [A, B], C>) => C;

// @public (undocumented)
const tailRec3: <A, B, C, D>(a: A, b: B, c: C, f: (a: A, b: B, c: C) => either.Either<readonly [A, B, C], D>) => D;

// @public
const takeLeft: (n: number) => <A>(as: A[]) => A[];

// @public
const takeLeft_2: (n: number) => <A>(as: readonly A[]) => readonly A[];

// @public
function takeLeftWhile<A, B extends A>(refinement: Refinement<A, B>): (as: Array<A>) => Array<B>;

// @public (undocumented)
function takeLeftWhile<A>(predicate: Predicate<A>): <B extends A>(bs: Array<B>) => Array<B>;

// @public (undocumented)
function takeLeftWhile<A>(predicate: Predicate<A>): (as: Array<A>) => Array<A>;

// @public
function takeLeftWhile_2<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => ReadonlyArray<B>;

// @public (undocumented)
function takeLeftWhile_2<A>(predicate: Predicate<A>): <B extends A>(bs: ReadonlyArray<B>) => ReadonlyArray<B>;

// @public (undocumented)
function takeLeftWhile_2<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => ReadonlyArray<A>;

// @public
const takeRight: (n: number) => <A>(as: A[]) => A[];

// @public
const takeRight_2: (n: number) => <A>(as: readonly A[]) => readonly A[];

// @public
const tap: {
    <A, _>(self: Option_2<A>, f: (a: A) => Option_2<_>): Option_2<A>;
    <A, _>(f: (a: A) => Option_2<_>): (self: Option_2<A>) => Option_2<A>;
};

// @public
const tap_10: {
    <A, _>(self: Task<A>, f: (a: A) => Task<_>): Task<A>;
    <A, _>(f: (a: A) => Task<_>): (self: Task<A>) => Task<A>;
};

// @public
const tap_11: {
    <E1, A, E2, _>(self: TaskEither<E1, A>, f: (a: A) => TaskEither<E2, _>): TaskEither<E1 | E2, A>;
    <A, E2, _>(f: (a: A) => TaskEither<E2, _>): <E1>(self: TaskEither<E1, A>) => TaskEither<E2 | E1, A>;
};

// @public
const tap_12: {
    <R1, E1, A, R2, E2, _>(self: ReaderTaskEither<R1, E1, A>, f: (a: A) => ReaderTaskEither<R2, E2, _>): ReaderTaskEither<R1 & R2, E1 | E2, A>;
    <A, R2, E2, _>(f: (a: A) => ReaderTaskEither<R2, E2, _>): <R1, E1>(self: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E2 | E1, A>;
};

// @public
const tap_13: {
    <S, A, _>(self: State<S, A>, f: (a: A) => State<S, _>): State<S, A>;
    <A, S, _>(f: (a: A) => State<S, _>): (self: State<S, A>) => State<S, A>;
};

// @public
const tap_14: {
    <S, R1, E1, A, R2, E2, _>(self: StateReaderTaskEither<S, R1, E1, A>, f: (a: A) => StateReaderTaskEither<S, R2, E2, _>): StateReaderTaskEither<S, R1 & R2, E1 | E2, A>;
    <A, S, R2, E2, _>(f: (a: A) => StateReaderTaskEither<S, R2, E2, _>): <R1, E1>(self: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E2 | E1, A>;
};

// @public
const tap_15: {
    <A, _>(self: TaskOption<A>, f: (a: A) => TaskOption<_>): TaskOption<A>;
    <A, _>(f: (a: A) => TaskOption<_>): (self: TaskOption<A>) => TaskOption<A>;
};

// @public
const tap_2: {
    <E1, A, E2, _>(self: Either<E1, A>, f: (a: A) => Either<E2, _>): Either<E1 | E2, A>;
    <A, E2, _>(f: (a: A) => Either<E2, _>): <E1>(self: Either<E1, A>) => Either<E2 | E1, A>;
};

// @public
const tap_3: {
    <A, _>(self: IO<A>, f: (a: A) => IO<_>): IO<A>;
    <A, _>(f: (a: A) => IO<_>): (self: IO<A>) => IO<A>;
};

// @public
const tap_4: {
    <E1, A, E2, _>(self: IOEither<E1, A>, f: (a: A) => IOEither<E2, _>): IOEither<E1 | E2, A>;
    <A, E2, _>(f: (a: A) => IOEither<E2, _>): <E1>(self: IOEither<E1, A>) => IOEither<E2 | E1, A>;
};

// @public
const tap_5: {
    <A, _>(self: IOOption<A>, f: (a: A) => IOOption<_>): IOOption<A>;
    <A, _>(f: (a: A) => IOOption<_>): (self: IOOption<A>) => IOOption<A>;
};

// @public
const tap_6: {
    <R1, A, R2, _>(self: Reader<R1, A>, f: (a: A) => Reader<R2, _>): Reader<R1 & R2, A>;
    <A, R2, _>(f: (a: A) => Reader<R2, _>): <R1>(self: Reader<R1, A>) => Reader<R2 & R1, A>;
};

// @public
const tap_7: {
    <R1, E1, A, R2, E2, _>(self: ReaderEither<R1, E1, A>, f: (a: A) => ReaderEither<R2, E2, _>): ReaderEither<R1 & R2, E1 | E2, A>;
    <A, R2, E2, _>(f: (a: A) => ReaderEither<R2, E2, _>): <R1, E1>(self: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E2 | E1, A>;
};

// @public
const tap_8: {
    <R1, A, R2, _>(self: ReaderIO<R1, A>, f: (a: A) => ReaderIO<R2, _>): ReaderIO<R1 & R2, A>;
    <A, R2, _>(f: (a: A) => ReaderIO<R2, _>): <R1>(self: ReaderIO<R1, A>) => ReaderIO<R2 & R1, A>;
};

// @public
const tap_9: {
    <R1, A, R2, _>(self: ReaderTask<R1, A>, f: (a: A) => ReaderTask<R2, _>): ReaderTask<R1 & R2, A>;
    <A, R2, _>(f: (a: A) => ReaderTask<R2, _>): <R1>(self: ReaderTask<R1, A>) => ReaderTask<R2 & R1, A>;
};

// @public
const tapEither: {
    <A, E, _>(f: (a: A) => Either<E, _>): (self: Option_2<A>) => Option_2<A>;
    <A, E, _>(self: Option_2<A>, f: (a: A) => Either<E, _>): Option_2<A>;
};

// @public
const tapEither_2: {
    <A, E2, _>(f: (a: A) => Either<E2, _>): <E1>(self: IOEither<E1, A>) => IOEither<E2 | E1, A>;
    <E1, A, E2, _>(self: IOEither<E1, A>, f: (a: A) => Either<E2, _>): IOEither<E1 | E2, A>;
};

// @public
const tapEither_3: {
    <A, E, _>(f: (a: A) => Either<E, _>): (self: IOOption<A>) => IOOption<A>;
    <A, E, _>(self: IOOption<A>, f: (a: A) => Either<E, _>): IOOption<A>;
};

// @public
const tapEither_4: {
    <A, E2, _>(f: (a: A) => Either<E2, _>): <R1, E1>(self: ReaderEither<R1, E1, A>) => ReaderEither<R1, E1 | E2, A>;
    <R1, E1, A, E2, _>(self: ReaderEither<R1, E1, A>, f: (a: A) => Either<E2, _>): ReaderEither<R1, E1 | E2, A>;
};

// @public
const tapEither_5: {
    <A, E2, _>(f: (a: A) => Either<E2, _>): <E1>(self: TaskEither<E1, A>) => TaskEither<E2 | E1, A>;
    <E1, A, E2, _>(self: TaskEither<E1, A>, f: (a: A) => Either<E2, _>): TaskEither<E1 | E2, A>;
};

// @public
const tapEither_6: {
    <A, E2, _>(f: (a: A) => Either<E2, _>): <R, E1>(self: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, A>;
    <R, E1, A, E2, _>(self: ReaderTaskEither<R, E1, A>, f: (a: A) => Either<E2, _>): ReaderTaskEither<R, E1 | E2, A>;
};

// @public
const tapEither_7: {
    <A, E2, _>(f: (a: A) => Either<E2, _>): <S, R1, E1>(self: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1, E2 | E1, A>;
    <S, R1, E1, A, E2, _>(self: StateReaderTaskEither<S, R1, E1, A>, f: (a: A) => Either<E2, _>): StateReaderTaskEither<S, R1, E1 | E2, A>;
};

// @public
const tapEither_8: {
    <A, E, _>(f: (a: A) => Either<E, _>): (self: TaskOption<A>) => TaskOption<A>;
    <A, E, _>(self: TaskOption<A>, f: (a: A) => Either<E, _>): TaskOption<A>;
};

// @public
const tapError: {
    <E1, E2, _>(onLeft: (e: E1) => IOEither<E2, _>): <A>(self: IOEither<E1, A>) => IOEither<E1 | E2, A>;
    <E1, A, E2, _>(self: IOEither<E1, A>, onLeft: (e: E1) => IOEither<E2, _>): IOEither<E1 | E2, A>;
};

// @public
const tapError_2: {
    <E1, R2, E2, _>(onLeft: (e: E1) => ReaderEither<R2, E2, _>): <R1, A>(self: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E1 | E2, A>;
    <R1, E1, A, R2, E2, _>(self: ReaderEither<R1, E1, A>, onLeft: (e: E1) => ReaderEither<R2, E2, _>): ReaderEither<R1 & R2, E1 | E2, A>;
};

// @public
const tapError_3: {
    <E1, R2, E2, _>(onLeft: (e: E1) => ReaderTaskEither<R2, E2, _>): <R1, A>(self: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, A>;
    <R1, E1, A, R2, E2, _>(self: ReaderTaskEither<R1, E1, A>, onLeft: (e: E1) => ReaderTaskEither<R2, E2, _>): ReaderTaskEither<R1 & R2, E1 | E2, A>;
};

// @public
const tapError_4: {
    <E1, E2, _>(onLeft: (e: E1) => TaskEither<E2, _>): <A>(self: TaskEither<E1, A>) => TaskEither<E1 | E2, A>;
    <E1, A, E2, _>(self: TaskEither<E1, A>, onLeft: (e: E1) => TaskEither<E2, _>): TaskEither<E1 | E2, A>;
};

// @public
const tapIO: {
    <A, _>(f: (a: A) => IO<_>): <E>(self: IOEither<E, A>) => IOEither<E, A>;
    <E, A, _>(self: IOEither<E, A>, f: (a: A) => IO<_>): IOEither<E, A>;
};

// @public
const tapIO_2: {
    <A, _>(f: (a: A) => IO<_>): (self: IOOption<A>) => IOOption<A>;
    <A, _>(self: IOOption<A>, f: (a: A) => IO<_>): IOOption<A>;
};

// @public
const tapIO_3: {
    <A, _>(f: (a: A) => IO<_>): <R>(self: ReaderIO<R, A>) => ReaderIO<R, A>;
    <R, A, _>(self: ReaderIO<R, A>, f: (a: A) => IO<_>): ReaderIO<R, A>;
};

// @public
const tapIO_4: {
    <A, _>(f: (a: A) => IO<_>): <R>(self: ReaderTask<R, A>) => ReaderTask<R, A>;
    <R, A, _>(self: ReaderTask<R, A>, f: (a: A) => IO<_>): ReaderTask<R, A>;
};

// @public
const tapIO_5: {
    <A, _>(f: (a: A) => IO<_>): (self: Task<A>) => Task<A>;
    <A, _>(self: Task<A>, f: (a: A) => IO<_>): Task<A>;
};

// @public
const tapIO_6: {
    <A, _>(f: (a: A) => IO<_>): <E>(self: TaskEither<E, A>) => TaskEither<E, A>;
    <E, A, _>(self: TaskEither<E, A>, f: (a: A) => IO<_>): TaskEither<E, A>;
};

// @public
const tapIO_7: {
    <A, _>(f: (a: A) => IO<_>): <R, E>(self: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;
    <R, E, A, _>(self: ReaderTaskEither<R, E, A>, f: (a: A) => IO<_>): ReaderTaskEither<R, E, A>;
};

// @public
const tapIO_8: {
    <A, _>(f: (a: A) => IO<_>): <S, R, E>(self: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>;
    <S, R, E, A, _>(self: StateReaderTaskEither<S, R, E, A>, f: (a: A) => IO<_>): StateReaderTaskEither<S, R, E, A>;
};

// @public
const tapIO_9: {
    <A, _>(f: (a: A) => IO<_>): (self: TaskOption<A>) => TaskOption<A>;
    <A, _>(self: TaskOption<A>, f: (a: A) => IO<_>): TaskOption<A>;
};

// @public (undocumented)
function tapReader<M extends URIS2>(F: FromReader<M>, M: Chain_5<M>): <A, R, B>(self: HKT2<M, R, A>, f: (a: A) => Reader<R, B>) => HKT2<M, R, A>;

// @public
const tapReader_2: {
    <R2, A, E, _>(f: (a: A) => Reader<R2, _>): <R1>(self: ReaderEither<R1, E, A>) => ReaderEither<R1 & R2, E, A>;
    <R1, R2, E, A, _>(self: ReaderEither<R1, E, A>, f: (a: A) => Reader<R2, _>): ReaderEither<R1 & R2, E, A>;
};

// @public
const tapReader_3: {
    <R2, A, _>(f: (a: A) => Reader<R2, _>): <R1>(self: ReaderIO<R1, A>) => ReaderIO<R1 & R2, A>;
    <R1, A, R2, _>(self: ReaderIO<R1, A>, f: (a: A) => Reader<R2, _>): ReaderIO<R1 & R2, A>;
};

// @public
const tapReader_4: {
    <R2, A, _>(f: (a: A) => reader.Reader<R2, _>): <R1>(self: ReaderTask<R1, A>) => ReaderTask<R1 & R2, A>;
    <R1, R2, A, _>(self: ReaderTask<R1, A>, f: (a: A) => reader.Reader<R2, _>): ReaderTask<R1 & R2, A>;
};

// @public
const tapReader_5: {
    <A, R2, _>(f: (a: A) => Reader<R2, _>): <R1, E>(self: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, A>;
    <R1, E, A, R2, _>(self: ReaderTaskEither<R1, E, A>, f: (a: A) => Reader<R2, _>): ReaderTaskEither<R1 & R2, E, A>;
};

// @public
const tapReader_6: {
    <A, R2, _>(f: (a: A) => Reader<R2, _>): <S, R1, E>(self: StateReaderTaskEither<S, R1, E, A>) => StateReaderTaskEither<S, R1 & R2, E, A>;
    <S, R1, E, A, R2, _>(self: StateReaderTaskEither<S, R1, E, A>, f: (a: A) => Reader<R2, _>): StateReaderTaskEither<S, R1 & R2, E, A>;
};

// @public
const tapReaderEither: {
    <A, R2, E2, _>(f: (a: A) => ReaderEither<R2, E2, _>): <R1, E1>(self: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, A>;
    <R1, E1, A, R2, E2, _>(self: ReaderTaskEither<R1, E1, A>, f: (a: A) => ReaderEither<R2, E2, _>): ReaderTaskEither<R1 & R2, E1 | E2, A>;
};

// @public
const tapReaderIO: {
    <R2, A, _>(f: (a: A) => ReaderIO<R2, _>): <R1>(self: ReaderTask<R1, A>) => ReaderTask<R1 & R2, A>;
    <R1, R2, A, _>(self: ReaderTask<R1, A>, f: (a: A) => ReaderIO<R2, _>): ReaderTask<R1 & R2, A>;
};

// @public
const tapReaderIO_2: {
    <A, R2, _>(f: (a: A) => ReaderIO<R2, _>): <R1, E>(self: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, A>;
    <R1, E, A, R2, _>(self: ReaderTaskEither<R1, E, A>, f: (a: A) => ReaderIO<R2, _>): ReaderTaskEither<R1 & R2, E, A>;
};

// @public
const tapReaderTask: {
    <A, R2, _>(f: (a: A) => ReaderTask<R2, _>): <R1, E>(self: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, A>;
    <R1, E, A, R2, _>(self: ReaderTaskEither<R1, E, A>, f: (a: A) => ReaderTask<R2, _>): ReaderTaskEither<R1 & R2, E, A>;
};

// @public
const tapTask: {
    <A, _>(f: (a: A) => Task<_>): <R>(self: ReaderTask<R, A>) => ReaderTask<R, A>;
    <R, A, _>(self: ReaderTask<R, A>, f: (a: A) => Task<_>): ReaderTask<R, A>;
};

// @public
const tapTask_2: {
    <A, _>(f: (a: A) => Task<_>): <E>(self: TaskEither<E, A>) => TaskEither<E, A>;
    <E, A, _>(self: TaskEither<E, A>, f: (a: A) => Task<_>): TaskEither<E, A>;
};

// @public
const tapTask_3: {
    <A, _>(f: (a: A) => Task<_>): <R, E>(self: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>;
    <R, E, A, _>(self: ReaderTaskEither<R, E, A>, f: (a: A) => Task<_>): ReaderTaskEither<R, E, A>;
};

// @public
const tapTask_4: {
    <A, _>(f: (a: A) => Task<_>): <S, R, E>(self: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>;
    <S, R, E, A, _>(self: StateReaderTaskEither<S, R, E, A>, f: (a: A) => Task<_>): StateReaderTaskEither<S, R, E, A>;
};

// @public
const tapTask_5: {
    <A, _>(f: (a: A) => Task<_>): (self: TaskOption<A>) => TaskOption<A>;
    <A, _>(self: TaskOption<A>, f: (a: A) => Task<_>): TaskOption<A>;
};

// @public
const tapTaskEither: {
    <A, E2, _>(f: (a: A) => TaskEither<E2, _>): <R, E1>(self: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, A>;
    <R, E1, A, E2, _>(self: ReaderTaskEither<R, E1, A>, f: (a: A) => TaskEither<E2, _>): ReaderTaskEither<R, E1 | E2, A>;
};

// @public (undocumented)
interface Task<A> {
    // (undocumented)
    (): Promise<A>;
}

declare namespace task {
    export {
        delay,
        getRaceMonoid,
        Task,
        fromIO_7 as fromIO,
        map_23 as map,
        ap_19 as ap,
        of_15 as of,
        flatMap_14 as flatMap,
        flatten_14 as flatten,
        URI_21 as URI,
        Functor_18 as Functor,
        as_9 as as,
        asUnit_9 as asUnit,
        flap_18 as flap,
        Pointed_15 as Pointed,
        ApplyPar_3 as ApplyPar,
        apFirst_15 as apFirst,
        apSecond_15 as apSecond,
        ApplicativePar_3 as ApplicativePar,
        ApplySeq_2 as ApplySeq,
        ApplicativeSeq_3 as ApplicativeSeq,
        Chain_15 as Chain,
        chainRec_11 as chainRec,
        ChainRec_12 as ChainRec,
        Monad_15 as Monad,
        MonadIO_7 as MonadIO,
        fromTask_3 as fromTask,
        MonadTask_3 as MonadTask,
        FromIO_7 as FromIO,
        flatMapIO_5 as flatMapIO,
        tap_10 as tap,
        tapIO_5 as tapIO,
        fromIOK_6 as fromIOK,
        chainIOK_6 as chainIOK,
        chainFirstIOK_6 as chainFirstIOK,
        FromTask_3 as FromTask,
        never,
        Do_13 as Do,
        bindTo_14 as bindTo,
        let__13 as let,
        bind_14 as bind,
        do__10 as do,
        apS_14 as apS,
        ApT_9 as ApT,
        traverseReadonlyNonEmptyArrayWithIndex_9 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_9 as traverseReadonlyArrayWithIndex,
        traverseReadonlyNonEmptyArrayWithIndexSeq_2 as traverseReadonlyNonEmptyArrayWithIndexSeq,
        traverseReadonlyArrayWithIndexSeq_2 as traverseReadonlyArrayWithIndexSeq,
        traverseArrayWithIndex_8 as traverseArrayWithIndex,
        traverseArray_8 as traverseArray,
        sequenceArray_8 as sequenceArray,
        traverseSeqArrayWithIndex_2 as traverseSeqArrayWithIndex,
        traverseSeqArray_2 as traverseSeqArray,
        sequenceSeqArray_2 as sequenceSeqArray,
        chain_18 as chain,
        chainFirst_14 as chainFirst,
        task_2 as task,
        taskSeq,
        getSemigroup_14 as getSemigroup,
        getMonoid_11 as getMonoid
    }
}
export { task }

// @public @deprecated
const task_2: Monad1<URI_21> & MonadTask1<URI_21>;

// @public (undocumented)
interface TaskEither<E, A> extends Task<Either<E, A>> {
}

declare namespace taskEither {
    export {
        getApplicativeTaskValidation,
        getAltTaskValidation,
        getFilterable_5 as getFilterable,
        taskify,
        getTaskValidation,
        TaskEither,
        left_8 as left,
        right_8 as right,
        rightTask_2 as rightTask,
        leftTask_2 as leftTask,
        rightIO_3 as rightIO,
        leftIO_3 as leftIO,
        fromIO_9 as fromIO,
        fromTask_5 as fromTask,
        fromEither_9 as fromEither,
        fromIOEither_3 as fromIOEither,
        fromTaskOption,
        match_12 as match,
        matchW_10 as matchW,
        matchE_7 as matchE,
        fold_12 as fold,
        matchEW_5 as matchEW,
        foldW_7 as foldW,
        getOrElse_9 as getOrElse,
        getOrElseW_7 as getOrElseW,
        tryCatch_4 as tryCatch,
        tryCatchK_4 as tryCatchK,
        toUnion_6 as toUnion,
        fromNullable_7 as fromNullable,
        fromNullableK_7 as fromNullableK,
        chainNullableK_7 as chainNullableK,
        orElse_7 as orElse,
        orElseW_5 as orElseW,
        tapError_4 as tapError,
        orElseFirstIOK_2 as orElseFirstIOK,
        orElseFirstTaskK,
        orLeft_5 as orLeft,
        swap_6 as swap,
        fromTaskOptionK,
        chainTaskOptionKW,
        chainTaskOptionK,
        fromIOEitherK_2 as fromIOEitherK,
        map_24 as map,
        mapBoth_3 as mapBoth,
        bimap_8 as bimap,
        mapError_3 as mapError,
        mapLeft_8 as mapLeft,
        ap_20 as ap,
        apW_7 as apW,
        flatMap_15 as flatMap,
        flattenW_7 as flattenW,
        flatten_15 as flatten,
        alt_14 as alt,
        altW_10 as altW,
        of_16 as of,
        throwError_6 as throwError,
        URI_23 as URI,
        getCompactable_4 as getCompactable,
        Functor_19 as Functor,
        as_10 as as,
        asUnit_10 as asUnit,
        flap_19 as flap,
        Pointed_16 as Pointed,
        ApplyPar_4 as ApplyPar,
        apFirst_16 as apFirst,
        apFirstW_5 as apFirstW,
        apSecond_16 as apSecond,
        apSecondW_5 as apSecondW,
        ApplicativePar_4 as ApplicativePar,
        ApplySeq_3 as ApplySeq,
        ApplicativeSeq_4 as ApplicativeSeq,
        Chain_16 as Chain,
        chainRec_12 as chainRec,
        ChainRec_13 as ChainRec,
        Monad_16 as Monad,
        MonadIO_8 as MonadIO,
        MonadTask_4 as MonadTask,
        MonadThrow_7 as MonadThrow,
        FromEither_8 as FromEither,
        FromIO_8 as FromIO,
        FromTask_4 as FromTask,
        tap_11 as tap,
        tapEither_5 as tapEither,
        tapIO_6 as tapIO,
        tapTask_2 as tapTask,
        Bifunctor_7 as Bifunctor,
        Alt_11 as Alt,
        fromOption_7 as fromOption,
        fromOptionK_8 as fromOptionK,
        chainOptionK_7 as chainOptionK,
        chainOptionKW_4 as chainOptionKW,
        liftNullable_4 as liftNullable,
        liftOption_4 as liftOption,
        flatMapNullable_5 as flatMapNullable,
        flatMapOption_5 as flatMapOption,
        flatMapEither_4 as flatMapEither,
        flatMapIO_6 as flatMapIO,
        flatMapTask_2 as flatMapTask,
        flatMapIOEither,
        flatMapTaskOption,
        chainEitherK_6 as chainEitherK,
        chainEitherKW_3 as chainEitherKW,
        chainFirstEitherK_6 as chainFirstEitherK,
        chainFirstEitherKW_3 as chainFirstEitherKW,
        fromPredicate_9 as fromPredicate,
        filterOrElse_5 as filterOrElse,
        filterOrElseW_4 as filterOrElseW,
        fromEitherK_7 as fromEitherK,
        fromIOK_7 as fromIOK,
        chainIOK_7 as chainIOK,
        chainFirstIOK_7 as chainFirstIOK,
        fromTaskK_3 as fromTaskK,
        chainTaskK_3 as chainTaskK,
        chainFirstTaskK_3 as chainFirstTaskK,
        chainIOEitherKW,
        chainIOEitherK,
        bracket_3 as bracket,
        bracketW_3 as bracketW,
        Do_15 as Do,
        bindTo_16 as bindTo,
        let__15 as let,
        bind_16 as bind,
        bindW_7 as bindW,
        do__12 as do,
        apS_16 as apS,
        apSW_7 as apSW,
        ApT_11 as ApT,
        traverseReadonlyNonEmptyArrayWithIndex_11 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_11 as traverseReadonlyArrayWithIndex,
        traverseReadonlyNonEmptyArrayWithIndexSeq_4 as traverseReadonlyNonEmptyArrayWithIndexSeq,
        traverseReadonlyArrayWithIndexSeq_4 as traverseReadonlyArrayWithIndexSeq,
        traverseArrayWithIndex_10 as traverseArrayWithIndex,
        traverseArray_10 as traverseArray,
        sequenceArray_10 as sequenceArray,
        traverseSeqArrayWithIndex_4 as traverseSeqArrayWithIndex,
        traverseSeqArray_4 as traverseSeqArray,
        sequenceSeqArray_4 as sequenceSeqArray,
        chain_20 as chain,
        chainW_7 as chainW,
        chainFirst_16 as chainFirst,
        chainFirstW_7 as chainFirstW,
        orElseFirst_4 as orElseFirst,
        orElseFirstW_3 as orElseFirstW,
        taskEither_2 as taskEither,
        taskEitherSeq,
        getApplySemigroup_6 as getApplySemigroup,
        getApplyMonoid_5 as getApplyMonoid,
        getSemigroup_16 as getSemigroup
    }
}
export { taskEither }

// @public @deprecated
const taskEither_2: Monad2<URI_23> & Bifunctor2<URI_23> & Alt2<URI_23> & MonadTask2<URI_23> & MonadThrow2<URI_23>;

// @public @deprecated
const taskEitherSeq: typeof taskEither_2;

// @public
function taskify<L, R>(f: (cb: (e: L | null | undefined, r?: R) => void) => void): () => TaskEither<L, R>;

// @public (undocumented)
function taskify<A, L, R>(f: (a: A, cb: (e: L | null | undefined, r?: R) => void) => void): (a: A) => TaskEither<L, R>;

// @public (undocumented)
function taskify<A, B, L, R>(f: (a: A, b: B, cb: (e: L | null | undefined, r?: R) => void) => void): (a: A, b: B) => TaskEither<L, R>;

// @public (undocumented)
function taskify<A, B, C, L, R>(f: (a: A, b: B, c: C, cb: (e: L | null | undefined, r?: R) => void) => void): (a: A, b: B, c: C) => TaskEither<L, R>;

// @public (undocumented)
function taskify<A, B, C, D, L, R>(f: (a: A, b: B, c: C, d: D, cb: (e: L | null | undefined, r?: R) => void) => void): (a: A, b: B, c: C, d: D) => TaskEither<L, R>;

// @public (undocumented)
function taskify<A, B, C, D, E, L, R>(f: (a: A, b: B, c: C, d: D, e: E, cb: (e: L | null | undefined, r?: R) => void) => void): (a: A, b: B, c: C, d: D, e: E) => TaskEither<L, R>;

// @public (undocumented)
interface TaskOption<A> extends Task<Option_2<A>> {
}

declare namespace taskOption {
    export {
        TaskOption,
        some_10 as some,
        fromPredicate_13 as fromPredicate,
        fromOption_11 as fromOption,
        fromEither_12 as fromEither,
        fromIO_11 as fromIO,
        fromTask_7 as fromTask,
        fromTaskEither_3 as fromTaskEither,
        match_14 as match,
        matchW_12 as matchW,
        matchE_8 as matchE,
        fold_13 as fold,
        matchEW_6 as matchEW,
        foldW_8 as foldW,
        getOrElse_10 as getOrElse,
        getOrElseW_8 as getOrElseW,
        fromNullable_8 as fromNullable,
        tryCatch_5 as tryCatch,
        tryCatchK_5 as tryCatchK,
        fromNullableK_8 as fromNullableK,
        chainNullableK_8 as chainNullableK,
        fromOptionK_13 as fromOptionK,
        chainOptionK_10 as chainOptionK,
        map_37 as map,
        ap_26 as ap,
        of_22 as of,
        flatMap_20 as flatMap,
        flatMapIO_9 as flatMapIO,
        flatMapTask_5 as flatMapTask,
        flatten_20 as flatten,
        alt_18 as alt,
        altW_14 as altW,
        zero_8 as zero,
        throwError_9 as throwError,
        none_3 as none,
        compact_12 as compact,
        separate_12 as separate,
        filter_15 as filter,
        filterMap_13 as filterMap,
        partition_13 as partition,
        partitionMap_13 as partitionMap,
        URI_33 as URI,
        Functor_29 as Functor,
        as_13 as as,
        asUnit_13 as asUnit,
        flap_29 as flap,
        Pointed_21 as Pointed,
        ApplyPar_6 as ApplyPar,
        apFirst_21 as apFirst,
        apSecond_21 as apSecond,
        ApplicativePar_6 as ApplicativePar,
        ApplySeq_5 as ApplySeq,
        ApplicativeSeq_6 as ApplicativeSeq,
        Chain_21 as Chain,
        chainRec_16 as chainRec,
        ChainRec_17 as ChainRec,
        FromEither_12 as FromEither,
        FromIO_11 as FromIO,
        FromTask_7 as FromTask,
        tap_15 as tap,
        tapEither_8 as tapEither,
        tapIO_9 as tapIO,
        tapTask_5 as tapTask,
        Alt_15 as Alt,
        Zero_6 as Zero,
        guard_5 as guard,
        Alternative_6 as Alternative,
        Monad_21 as Monad,
        MonadIO_11 as MonadIO,
        MonadThrow_10 as MonadThrow,
        MonadTask_7 as MonadTask,
        Compactable_10 as Compactable,
        Filterable_10 as Filterable,
        fromIOK_10 as fromIOK,
        chainIOK_10 as chainIOK,
        chainFirstIOK_10 as chainFirstIOK,
        fromEitherK_12 as fromEitherK,
        chainEitherK_9 as chainEitherK,
        chainFirstEitherK_9 as chainFirstEitherK,
        fromTaskK_6 as fromTaskK,
        chainTaskK_6 as chainTaskK,
        chainFirstTaskK_6 as chainFirstTaskK,
        Do_18 as Do,
        bindTo_21 as bindTo,
        let__20 as let,
        bind_21 as bind,
        do__16 as do,
        apS_21 as apS,
        ApT_13 as ApT,
        traverseReadonlyNonEmptyArrayWithIndex_15 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_15 as traverseReadonlyArrayWithIndex,
        traverseReadonlyNonEmptyArrayWithIndexSeq_6 as traverseReadonlyNonEmptyArrayWithIndexSeq,
        traverseReadonlyArrayWithIndexSeq_6 as traverseReadonlyArrayWithIndexSeq,
        traverseArrayWithIndex_14 as traverseArrayWithIndex,
        traverseArray_14 as traverseArray,
        sequenceArray_14 as sequenceArray,
        traverseSeqArrayWithIndex_6 as traverseSeqArrayWithIndex,
        traverseSeqArray_6 as traverseSeqArray,
        sequenceSeqArray_6 as sequenceSeqArray,
        chain_28 as chain,
        chainFirst_21 as chainFirst
    }
}
export { taskOption }

// @public @deprecated
const taskSeq: Monad1<URI_21> & MonadTask1<URI_21>;

// @public (undocumented)
interface TaskThese<E, A> extends Task<These<E, A>> {
}

declare namespace taskThese {
    export {
        getApplicative_3 as getApplicative,
        getChain_2 as getChain,
        getMonad_2 as getMonad,
        TaskThese,
        left_10 as left,
        right_10 as right,
        both,
        rightTask_4 as rightTask,
        leftTask_4 as leftTask,
        rightIO_5 as rightIO,
        leftIO_5 as leftIO,
        fromEither_13 as fromEither,
        fromThese_2 as fromThese,
        fromIO_12 as fromIO,
        fromIOEither_5 as fromIOEither,
        fromTask_8 as fromTask,
        match_15 as match,
        matchW_13 as matchW,
        matchE_9 as matchE,
        fold_14 as fold,
        matchEW_7 as matchEW,
        foldW_9 as foldW,
        swap_8 as swap,
        map_38 as map,
        bimap_12 as bimap,
        mapLeft_12 as mapLeft,
        of_23 as of,
        URI_34 as URI,
        getApply_3 as getApply,
        Functor_30 as Functor,
        flap_30 as flap,
        Pointed_22 as Pointed,
        Bifunctor_11 as Bifunctor,
        FromEither_13 as FromEither,
        fromOption_12 as fromOption,
        fromOptionK_14 as fromOptionK,
        fromPredicate_14 as fromPredicate,
        FromThese_2 as FromThese,
        fromTheseK_2 as fromTheseK,
        FromIO_12 as FromIO,
        fromIOK_11 as fromIOK,
        FromTask_8 as FromTask,
        fromTaskK_7 as fromTaskK,
        toTuple2_2 as toTuple2,
        ApT_15 as ApT,
        traverseReadonlyNonEmptyArrayWithIndex_17 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_17 as traverseReadonlyArrayWithIndex,
        traverseReadonlyNonEmptyArrayWithIndexSeq_7 as traverseReadonlyNonEmptyArrayWithIndexSeq,
        traverseReadonlyArrayWithIndexSeq_7 as traverseReadonlyArrayWithIndexSeq,
        functorTaskThese,
        bifunctorTaskThese,
        toTuple_2 as toTuple,
        taskThese_2 as taskThese,
        getSemigroup_20 as getSemigroup
    }
}
export { taskThese }

// @public @deprecated
const taskThese_2: Functor2<URI_34> & Bifunctor2<URI_34>;

// @public
const tell: <W>(w: W) => Writer<W, void>;

// @public (undocumented)
type These<E, A> = Either<E, A> | Both<E, A>;

declare namespace these {
    export {
        isBoth,
        left_11 as left,
        right_11 as right,
        both_2 as both,
        getShow_15 as getShow,
        getEq_15 as getEq,
        getSemigroup_19 as getSemigroup,
        getApplicative_4 as getApplicative,
        getChain_3 as getChain,
        getMonad_3 as getMonad,
        getLeft_2 as getLeft,
        getRight_2 as getRight,
        leftOrBoth,
        rightOrBoth,
        getLeftOnly,
        getRightOnly,
        Both,
        These,
        isLeft_2 as isLeft,
        isRight_2 as isRight,
        matchW_14 as matchW,
        foldW_10 as foldW,
        match_16 as match,
        fold_15 as fold,
        swap_9 as swap,
        getApply_4 as getApply,
        fromOptions,
        bimap_13 as bimap,
        mapLeft_13 as mapLeft,
        map_39 as map,
        reduce_17 as reduce,
        foldMap_17 as foldMap,
        reduceRight_17 as reduceRight,
        traverse_11 as traverse,
        sequence_11 as sequence,
        of_24 as of,
        URI_35 as URI,
        Functor_31 as Functor,
        flap_31 as flap,
        Pointed_23 as Pointed,
        Bifunctor_12 as Bifunctor,
        FromThese_3 as FromThese,
        Foldable_12 as Foldable,
        Traversable_11 as Traversable,
        FromEither_14 as FromEither,
        fromPredicate_15 as fromPredicate,
        fromOption_13 as fromOption,
        fromOptionK_15 as fromOptionK,
        elem_11 as elem,
        exists_5 as exists,
        toTuple2,
        toTuple,
        ApT_14 as ApT,
        traverseReadonlyNonEmptyArrayWithIndex_16 as traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex_16 as traverseReadonlyArrayWithIndex,
        these_2 as these
    }
}
export { these }

// @public @deprecated
const these_2: Functor2<URI_35> & Bifunctor2<URI_35> & Foldable2<URI_35> & Traversable2<URI_35>;

// @public @deprecated (undocumented)
interface TheseM<M> {
    // (undocumented)
    readonly bimap: <E, A, N, B>(fa: TheseT<M, E, A>, f: (e: E) => N, g: (a: A) => B) => TheseT<M, N, B>;
    // (undocumented)
    readonly both: <E, A>(e: E, a: A) => TheseT<M, E, A>;
    // (undocumented)
    readonly fold: <E, A, R>(fa: TheseT<M, E, A>, onLeft: (e: E) => HKT<M, R>, onRight: (a: A) => HKT<M, R>, onBoth: (e: E, a: A) => HKT<M, R>) => HKT<M, R>;
    // (undocumented)
    readonly getMonad: <E>(S: Semigroup<E>) => {
        readonly _E: E;
        readonly map: <A, B>(ma: TheseT<M, E, A>, f: (a: A) => B) => TheseT<M, E, B>;
        readonly of: <A>(a: A) => TheseT<M, E, A>;
        readonly ap: <A, B>(mab: TheseT<M, E, (a: A) => B>, ma: TheseT<M, E, A>) => TheseT<M, E, B>;
        readonly chain: <A, B>(ma: TheseT<M, E, A>, f: (a: A) => TheseT<M, E, B>) => TheseT<M, E, B>;
    };
    // (undocumented)
    readonly left: <E, A>(e: E) => TheseT<M, E, A>;
    // (undocumented)
    readonly leftM: <E, A>(me: HKT<M, E>) => TheseT<M, E, A>;
    // (undocumented)
    readonly map: <E, A, B>(fa: TheseT<M, E, A>, f: (a: A) => B) => TheseT<M, E, B>;
    // (undocumented)
    readonly mapLeft: <E, A, N>(fa: TheseT<M, E, A>, f: (e: E) => N) => TheseT<M, N, A>;
    // (undocumented)
    readonly right: <E, A>(a: A) => TheseT<M, E, A>;
    // (undocumented)
    readonly rightM: <E, A>(ma: HKT<M, A>) => TheseT<M, E, A>;
    // (undocumented)
    readonly swap: <E, A>(fa: TheseT<M, E, A>) => TheseT<M, A, E>;
    // (undocumented)
    readonly toTuple: <E, A>(fa: TheseT<M, E, A>, e: E, a: A) => HKT<M, [E, A]>;
}

// @public @deprecated (undocumented)
interface TheseM1<M extends URIS> {
    // (undocumented)
    readonly bimap: <E, A, N, B>(fa: TheseT1<M, E, A>, f: (e: E) => N, g: (a: A) => B) => TheseT1<M, N, B>;
    // (undocumented)
    readonly both: <E, A>(e: E, a: A) => TheseT1<M, E, A>;
    // (undocumented)
    readonly fold: <E, A, R>(fa: TheseT1<M, E, A>, onLeft: (e: E) => Kind<M, R>, onRight: (a: A) => Kind<M, R>, onBoth: (e: E, a: A) => Kind<M, R>) => Kind<M, R>;
    // (undocumented)
    readonly getMonad: <E>(S: Semigroup<E>) => {
        readonly _E: E;
        readonly map: <A, B>(ma: TheseT1<M, E, A>, f: (a: A) => B) => TheseT1<M, E, B>;
        readonly of: <A>(a: A) => TheseT1<M, E, A>;
        readonly ap: <A, B>(mab: TheseT1<M, E, (a: A) => B>, ma: TheseT1<M, E, A>) => TheseT1<M, E, B>;
        readonly chain: <A, B>(ma: TheseT1<M, E, A>, f: (a: A) => TheseT1<M, E, B>) => TheseT1<M, E, B>;
    };
    // (undocumented)
    readonly left: <E, A>(e: E) => TheseT1<M, E, A>;
    // (undocumented)
    readonly leftM: <E, A>(me: Kind<M, E>) => TheseT1<M, E, A>;
    // (undocumented)
    readonly map: <E, A, B>(fa: TheseT1<M, E, A>, f: (a: A) => B) => TheseT1<M, E, B>;
    // (undocumented)
    readonly mapLeft: <E, A, N>(fa: TheseT1<M, E, A>, f: (e: E) => N) => TheseT1<M, N, A>;
    // (undocumented)
    readonly right: <E, A>(a: A) => TheseT1<M, E, A>;
    // (undocumented)
    readonly rightM: <E, A>(ma: Kind<M, A>) => TheseT1<M, E, A>;
    // (undocumented)
    readonly swap: <E, A>(fa: TheseT1<M, E, A>) => TheseT1<M, A, E>;
    // (undocumented)
    readonly toTuple: <E, A>(fa: TheseT1<M, E, A>, e: E, a: A) => Kind<M, [E, A]>;
}

// @public @deprecated (undocumented)
interface TheseM2<M extends URIS2> {
    // (undocumented)
    readonly bimap: <R, E, A, N, B>(fa: TheseT2<M, R, E, A>, f: (e: E) => N, g: (a: A) => B) => TheseT2<M, R, N, B>;
    // (undocumented)
    readonly both: <R, E, A>(e: E, a: A) => TheseT2<M, R, E, A>;
    // (undocumented)
    readonly fold: <R, E, A, B>(fa: TheseT2<M, R, E, A>, onLeft: (e: E) => Kind2<M, R, B>, onRight: (a: A) => Kind2<M, R, B>, onBoth: (e: E, a: A) => Kind2<M, R, B>) => Kind2<M, R, B>;
    // (undocumented)
    readonly getMonad: <E>(S: Semigroup<E>) => {
        readonly _E: E;
        readonly map: <R, A, B>(ma: TheseT2<M, R, E, A>, f: (a: A) => B) => TheseT2<M, R, E, B>;
        readonly of: <R, A>(a: A) => TheseT2<M, R, E, A>;
        readonly ap: <R, A, B>(mab: TheseT2<M, R, E, (a: A) => B>, ma: TheseT2<M, R, E, A>) => TheseT2<M, R, E, B>;
        readonly chain: <R, A, B>(ma: TheseT2<M, R, E, A>, f: (a: A) => TheseT2<M, R, E, B>) => TheseT2<M, R, E, B>;
    };
    // (undocumented)
    readonly left: <R, E, A>(e: E) => TheseT2<M, R, E, A>;
    // (undocumented)
    readonly leftM: <R, E, A>(me: Kind2<M, R, E>) => TheseT2<M, R, E, A>;
    // (undocumented)
    readonly map: <R, E, A, B>(fa: TheseT2<M, R, E, A>, f: (a: A) => B) => TheseT2<M, R, E, B>;
    // (undocumented)
    readonly mapLeft: <R, E, A, N>(fa: TheseT2<M, R, E, A>, f: (e: E) => N) => TheseT2<M, R, N, A>;
    // (undocumented)
    readonly right: <R, E, A>(a: A) => TheseT2<M, R, E, A>;
    // (undocumented)
    readonly rightM: <R, E, A>(ma: Kind2<M, R, A>) => TheseT2<M, R, E, A>;
    // (undocumented)
    readonly swap: <R, E, A>(fa: TheseT2<M, R, E, A>) => TheseT2<M, R, A, E>;
    // (undocumented)
    readonly toTuple: <R, E, A>(fa: TheseT2<M, R, E, A>, e: E, a: A) => Kind2<M, R, [E, A]>;
}

// @public @deprecated (undocumented)
interface TheseT<M, E, A> extends HKT<M, These<E, A>> {
}

declare namespace theseT {
    export {
        right_12 as right,
        left_12 as left,
        both_3 as both,
        rightF_2 as rightF,
        leftF_2 as leftF,
        map_40 as map,
        ap_27 as ap,
        chain_29 as chain,
        bimap_14 as bimap,
        mapLeft_14 as mapLeft,
        match_17 as match,
        matchE_10 as matchE,
        swap_10 as swap,
        toTuple2_3 as toTuple2,
        getTheseM,
        TheseT,
        TheseM,
        TheseT1,
        TheseM1,
        TheseT2,
        TheseM2
    }
}
export { theseT }

// @public @deprecated (undocumented)
type TheseT1<M extends URIS, E, A> = Kind<M, These<E, A>>;

// @public @deprecated (undocumented)
type TheseT2<M extends URIS2, R, E, A> = Kind2<M, R, These<E, A>>;

// @public (undocumented)
const throwError: MonadThrow1<URI_7>['throwError'];

// @public (undocumented)
const throwError_2: MonadThrow2<URI_6>['throwError'];

// @public (undocumented)
const throwError_3: MonadThrow2<URI_13>['throwError'];

// @public (undocumented)
const throwError_4: MonadThrow1<URI_14>['throwError'];

// @public (undocumented)
const throwError_5: MonadThrow3<URI_18>['throwError'];

// @public (undocumented)
const throwError_6: MonadThrow2<URI_23>['throwError'];

// @public (undocumented)
const throwError_7: MonadThrow3<URI_22>['throwError'];

// @public (undocumented)
const throwError_8: MonadThrow4<URI_31>['throwError'];

// @public (undocumented)
const throwError_9: MonadThrow1<URI_33>['throwError'];

// @public @deprecated
const toArray: typeof toReadonlyArray;

// @public
function toArray_2<K>(O: Ord<K>): <A>(m: Map<K, A>) => Array<[K, A]>;

// @public (undocumented)
const toArray_3: <A>(as: readonly A[]) => A[];

// @public
const toArray_4: <K extends string, A>(r: Record<K, A>) => Array<[K, A]>;

// @public
const toArray_5: <A>(O: Ord<A>) => (set: Set<A>) => A[];

// @public
const toEntries: <K extends string, A>(r: Readonly<Record<K, A>>) => readonly (readonly [K, A])[];

// @public
const toEntries_2: <K extends string, A>(r: Record<K, A>) => [K, A][];

// @public
function toError(e: unknown): Error;

// @public
const toggle: <A>(E: Eq<A>) => (a: A) => (set: ReadonlySet<A>) => ReadonlySet<A>;

// @public
const toggle_2: <A>(E: Eq<A>) => (a: A) => (set: Set<A>) => Set<A>;

// @public (undocumented)
const toLowerCase: (s: string) => string;

// @public (undocumented)
function toMap<K, A>(m: ReadonlyMap<K, A>): Map<K, A>;

// @public
const toNullable: <A>(ma: Option_2<A>) => A | null;

// @public (undocumented)
const toNullable_2: <A>(ma: IOOption<A>) => IO<A | null>;

// @public
function toReadonlyArray<F extends URIS4>(F: Foldable4<F>): <S, R, E, A>(fa: Kind4<F, S, R, E, A>) => ReadonlyArray<A>;

// @public (undocumented)
function toReadonlyArray<F extends URIS3>(F: Foldable3<F>): <R, E, A>(fa: Kind3<F, R, E, A>) => ReadonlyArray<A>;

// @public (undocumented)
function toReadonlyArray<F extends URIS3, E>(F: Foldable3C<F, E>): <R, A>(fa: Kind3<F, R, E, A>) => ReadonlyArray<A>;

// @public (undocumented)
function toReadonlyArray<F extends URIS2>(F: Foldable2<F>): <E, A>(fa: Kind2<F, E, A>) => ReadonlyArray<A>;

// @public (undocumented)
function toReadonlyArray<F extends URIS2, E>(F: Foldable2C<F, E>): <A>(fa: Kind2<F, E, A>) => ReadonlyArray<A>;

// @public (undocumented)
function toReadonlyArray<F extends URIS>(F: Foldable1<F>): <A>(fa: Kind<F, A>) => ReadonlyArray<A>;

// @public (undocumented)
function toReadonlyArray<F>(F: Foldable_6<F>): <A>(fa: HKT<F, A>) => ReadonlyArray<A>;

// @public
const toReadonlyArray_2: <K>(O: Ord<K>) => <A>(m: ReadonlyMap<K, A>) => readonly (readonly [K, A])[];

// @public
const toReadonlyArray_3: <K extends string, A>(r: ReadonlyRecord<K, A>) => ReadonlyArray<readonly [K, A]>;

// @public
const toReadonlyArray_4: <A>(O: Ord<A>) => (set: ReadonlySet<A>) => readonly A[];

// @public
const toRecord: <K extends string, A>(r: Readonly<Record<K, A>>) => Record<K, A>;

// @public (undocumented)
function toSet<A>(s: ReadonlySet<A>): Set<A>;

// @public @deprecated
const toTuple: <E, A>(e: E, a: A) => (fa: These<E, A>) => [E, A];

// @public (undocumented)
const toTuple2: <E, A>(e: LazyArg<E>, a: LazyArg<A>) => (fa: These<E, A>) => readonly [E, A];

// @public (undocumented)
const toTuple2_2: <E, A>(e: LazyArg<E>, a: LazyArg<A>) => (fa: TaskThese<E, A>) => Task<readonly [E, A]>;

// @public (undocumented)
function toTuple2_3<F extends URIS3>(F: Functor3<F>): <E, A>(e: LazyArg<E>, a: LazyArg<A>) => <R, FE>(fa: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, readonly [E, A]>;

// @public (undocumented)
function toTuple2_3<F extends URIS3, FE>(F: Functor3C<F, FE>): <E, A>(e: LazyArg<E>, a: LazyArg<A>) => <R>(fa: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, readonly [E, A]>;

// @public (undocumented)
function toTuple2_3<F extends URIS2>(F: Functor2<F>): <E, A>(e: LazyArg<E>, a: LazyArg<A>) => <FE>(fa: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, readonly [E, A]>;

// @public (undocumented)
function toTuple2_3<F extends URIS2, FE>(F: Functor2C<F, FE>): <E, A>(e: LazyArg<E>, a: LazyArg<A>) => (fa: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, readonly [E, A]>;

// @public (undocumented)
function toTuple2_3<F extends URIS>(F: Functor1<F>): <E, A>(e: LazyArg<E>, a: LazyArg<A>) => (fa: Kind<F, These<E, A>>) => Kind<F, readonly [E, A]>;

// @public (undocumented)
function toTuple2_3<F>(F: Functor<F>): <E, A>(e: LazyArg<E>, a: LazyArg<A>) => (fa: HKT<F, These<E, A>>) => HKT<F, readonly [E, A]>;

// @public @deprecated
const toTuple_2: <E, A>(e: E, a: A) => (fa: TaskThese<E, A>) => task.Task<[E, A]>;

// @public
const toUndefined: <A>(ma: Option_2<A>) => A | undefined;

// @public (undocumented)
const toUndefined_2: <A>(ma: IOOption<A>) => IO<A | undefined>;

// @public
function toUnfoldable<K, F extends URIS>(ord: Ord<K>, U: Unfoldable1<F>): <A>(d: Map<K, A>) => Kind<F, [K, A]>;

// @public (undocumented)
function toUnfoldable<K, F>(ord: Ord<K>, U: Unfoldable_2<F>): <A>(d: Map<K, A>) => HKT<F, [K, A]>;

// @public
function toUnfoldable_2<K, F extends URIS>(ord: Ord<K>, U: Unfoldable1<F>): <A>(d: ReadonlyMap<K, A>) => Kind<F, readonly [K, A]>;

// @public (undocumented)
function toUnfoldable_2<K, F>(ord: Ord<K>, U: Unfoldable_2<F>): <A>(d: ReadonlyMap<K, A>) => HKT<F, readonly [K, A]>;

// @public
function toUnfoldable_3<F extends URIS>(U: Unfoldable1<F>): <K extends string, A>(r: ReadonlyRecord<K, A>) => Kind<F, readonly [K, A]>;

// @public (undocumented)
function toUnfoldable_3<F>(U: Unfoldable_2<F>): <K extends string, A>(r: ReadonlyRecord<K, A>) => HKT<F, readonly [K, A]>;

// @public
function toUnfoldable_4<F extends URIS>(U: Unfoldable1<F>): <K extends string, A>(r: Record<K, A>) => Kind<F, [K, A]>;

// @public (undocumented)
function toUnfoldable_4<F>(U: Unfoldable_2<F>): <K extends string, A>(r: Record<K, A>) => HKT<F, [K, A]>;

// @public (undocumented)
const toUnion: <E, A>(fa: Either<E, A>) => E | A;

// @public (undocumented)
function toUnion_2<F extends URIS3>(F: Functor3<F>): <R, FE, E, A>(fa: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, E | A>;

// @public (undocumented)
function toUnion_2<F extends URIS3, FE>(F: Functor3C<F, FE>): <R, E, A>(fa: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, E | A>;

// @public (undocumented)
function toUnion_2<F extends URIS2>(F: Functor2<F>): <FE, E, A>(fa: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, E | A>;

// @public (undocumented)
function toUnion_2<F extends URIS2, FE>(F: Functor2C<F, FE>): <E, A>(fa: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, E | A>;

// @public (undocumented)
function toUnion_2<F extends URIS>(F: Functor1<F>): <E, A>(fa: Kind<F, Either<E, A>>) => Kind<F, E | A>;

// @public (undocumented)
function toUnion_2<F>(F: Functor<F>): <E, A>(fa: HKT<F, Either<E, A>>) => HKT<F, E | A>;

// @public (undocumented)
const toUnion_3: <E, A>(fa: IOEither<E, A>) => IO<E | A>;

// @public (undocumented)
const toUnion_4: <R, E, A>(fa: ReaderEither<R, E, A>) => Reader<R, E | A>;

// @public (undocumented)
const toUnion_5: <R, E, A>(fa: ReaderTaskEither<R, E, A>) => ReaderTask<R, E | A>;

// @public (undocumented)
const toUnion_6: <E, A>(fa: TaskEither<E, A>) => Task<E | A>;

// @public (undocumented)
const toUpperCase: (s: string) => string;

// @public (undocumented)
interface Traced<P, A> {
    // (undocumented)
    (p: P): A;
}

declare namespace traced {
    export {
        tracks,
        listen,
        listens,
        censor,
        getComonad,
        Traced,
        map_41 as map,
        URI_36 as URI,
        Functor_32 as Functor,
        flap_32 as flap,
        traced_2 as traced
    }
}
export { traced }

// @public @deprecated
const traced_2: Functor2<URI_36>;

// @public
function tracks<P, A>(M: Monoid<P>, f: (a: A) => P): (wa: Traced<P, A>) => A;

// @public (undocumented)
const Traversable: Traversable1<URI_2>;

declare namespace traversable {
    export {
        traverse_12 as traverse,
        sequence_12 as sequence,
        getTraversableComposition,
        Traversable_12 as Traversable,
        Traversable1,
        Traversable2,
        Traversable2C,
        Traversable3,
        Traverse,
        Traverse1,
        Traverse2,
        Traverse2C,
        Traverse3,
        Sequence,
        Sequence1,
        Sequence2,
        Sequence2C,
        Sequence3,
        PipeableTraverse1,
        PipeableTraverse2,
        TraversableComposition,
        TraverseComposition11,
        SequenceComposition11,
        TraversableComposition11
    }
}
export { traversable }

// @public (undocumented)
interface Traversable1<T extends URIS> extends Functor1<T>, Foldable1<T> {
    // (undocumented)
    readonly sequence: Sequence1<T>;
    // (undocumented)
    readonly traverse: Traverse1<T>;
}

// @public (undocumented)
interface Traversable2<T extends URIS2> extends Functor2<T>, Foldable2<T> {
    // (undocumented)
    readonly sequence: Sequence2<T>;
    // (undocumented)
    readonly traverse: Traverse2<T>;
}

// @public (undocumented)
interface Traversable2C<T extends URIS2, TL> extends Functor2C<T, TL>, Foldable2C<T, TL> {
    // (undocumented)
    readonly sequence: Sequence2C<T, TL>;
    // (undocumented)
    readonly traverse: Traverse2C<T, TL>;
}

// @public (undocumented)
interface Traversable3<T extends URIS3> extends Functor3<T>, Foldable3<T> {
    // (undocumented)
    readonly sequence: Sequence3<T>;
    // (undocumented)
    readonly traverse: Traverse3<T>;
}

// @public @deprecated
const Traversable_10: Traversable1<URI_29>;

// @public (undocumented)
const Traversable_11: Traversable2<URI_35>;

// @public (undocumented)
interface Traversable_12<T> extends Functor<T>, Foldable_6<T> {
    // (undocumented)
    readonly sequence: Sequence<T>;
    readonly traverse: Traverse<T>;
}

// @public (undocumented)
const Traversable_13: Traversable1<URI_37>;

// @public (undocumented)
const Traversable_14: Traversable2<URI_38>;

// @public (undocumented)
const Traversable_2: Traversable1<URI_3>;

// @public (undocumented)
const Traversable_3: Traversable1<URI_4>;

// @public (undocumented)
const Traversable_4: Traversable1<URI_7>;

// @public (undocumented)
const Traversable_5: Traversable2<URI_6>;

// @public (undocumented)
const Traversable_6: Traversable1<URI_11>;

// @public (undocumented)
const Traversable_7: Traversable1<URI_24>;

// @public @deprecated
const Traversable_8: Traversable1<URI_26>;

// @public (undocumented)
const Traversable_9: Traversable2<URI_28>;

// @public @deprecated (undocumented)
interface TraversableComposition<F, G> extends FoldableComposition<F, G>, FunctorComposition<F, G> {
    // (undocumented)
    readonly sequence: <H>(H: Applicative<H>) => <A>(fga: HKT<F, HKT<G, HKT<H, A>>>) => HKT<H, HKT<F, HKT<G, A>>>;
    // (undocumented)
    readonly traverse: <H>(H: Applicative<H>) => <A, B>(fga: HKT<F, HKT<G, A>>, f: (a: A) => HKT<H, B>) => HKT<H, HKT<F, HKT<G, B>>>;
}

// @public @deprecated (undocumented)
interface TraversableComposition11<F extends URIS, G extends URIS> extends FoldableComposition11<F, G>, FunctorComposition11<F, G> {
    // (undocumented)
    readonly sequence: SequenceComposition11<F, G>;
    // (undocumented)
    readonly traverse: TraverseComposition11<F, G>;
}

// @public (undocumented)
const TraversableWithIndex: TraversableWithIndex1<URI_2, number>;

declare namespace traversableWithIndex {
    export {
        TraversableWithIndex_7 as TraversableWithIndex,
        TraversableWithIndex1,
        TraversableWithIndex2,
        TraversableWithIndex2C,
        TraverseWithIndex,
        TraverseWithIndex1,
        TraverseWithIndex2,
        TraverseWithIndex2C,
        PipeableTraverseWithIndex1,
        PipeableTraverseWithIndex2
    }
}
export { traversableWithIndex }

// @public (undocumented)
interface TraversableWithIndex1<T extends URIS, I> extends FunctorWithIndex1<T, I>, FoldableWithIndex1<T, I>, Traversable1<T> {
    // (undocumented)
    readonly traverseWithIndex: TraverseWithIndex1<T, I>;
}

// @public (undocumented)
interface TraversableWithIndex2<T extends URIS2, I> extends FunctorWithIndex2<T, I>, FoldableWithIndex2<T, I>, Traversable2<T> {
    // (undocumented)
    readonly traverseWithIndex: TraverseWithIndex2<T, I>;
}

// @public (undocumented)
interface TraversableWithIndex2C<T extends URIS2, I, E> extends FunctorWithIndex2C<T, I, E>, FoldableWithIndex2C<T, I, E>, Traversable2C<T, E> {
    // (undocumented)
    readonly traverseWithIndex: TraverseWithIndex2C<T, I, E>;
}

// @public (undocumented)
const TraversableWithIndex_2: TraversableWithIndex1<URI_3, number>;

// @public (undocumented)
const TraversableWithIndex_3: TraversableWithIndex1<URI_4, number>;

// @public (undocumented)
const TraversableWithIndex_4: TraversableWithIndex1<URI_24, number>;

// @public @deprecated
const TraversableWithIndex_5: TraversableWithIndex1<URI_26, string>;

// @public @deprecated
const TraversableWithIndex_6: TraversableWithIndex1<URI_29, string>;

// @public (undocumented)
interface TraversableWithIndex_7<T, I> extends FunctorWithIndex_4<T, I>, FoldableWithIndex_4<T, I>, Traversable_12<T> {
    // (undocumented)
    readonly traverseWithIndex: TraverseWithIndex<T, I>;
}

// @public (undocumented)
interface Traverse<T> {
    // (undocumented)
    <F extends URIS4>(F: Applicative4<F>): <A, S, R, E, B>(ta: HKT<T, A>, f: (a: A) => Kind4<F, S, R, E, B>) => Kind4<F, S, R, E, HKT<T, B>>;
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, E, B>(ta: HKT<T, A>, f: (a: A) => Kind3<F, R, E, B>) => Kind3<F, R, E, HKT<T, B>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B>(ta: HKT<T, A>, f: (a: A) => Kind3<F, R, E, B>) => Kind3<F, R, E, HKT<T, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, E, B>(ta: HKT<T, A>, f: (a: A) => Kind2<F, E, B>) => Kind2<F, E, HKT<T, B>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B>(ta: HKT<T, A>, f: (a: A) => Kind2<F, E, B>) => Kind2<F, E, HKT<T, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(ta: HKT<T, A>, f: (a: A) => Kind<F, B>) => Kind<F, HKT<T, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(ta: HKT<T, A>, f: (a: A) => HKT<F, B>) => HKT<F, HKT<T, B>>;
}

// @public (undocumented)
const traverse: PipeableTraverse1<URI_2>;

// @public (undocumented)
interface Traverse1<T extends URIS> {
    // (undocumented)
    <F extends URIS4>(F: Applicative4<F>): <A, S, R, E, B>(ta: Kind<T, A>, f: (a: A) => Kind4<F, S, R, E, B>) => Kind4<F, S, R, E, Kind<T, B>>;
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, E, B>(ta: Kind<T, A>, f: (a: A) => Kind3<F, R, E, B>) => Kind3<F, R, E, Kind<T, B>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B>(ta: Kind<T, A>, f: (a: A) => Kind3<F, R, E, B>) => Kind3<F, R, E, Kind<T, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, E, B>(ta: Kind<T, A>, f: (a: A) => Kind2<F, E, B>) => Kind2<F, E, Kind<T, B>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B>(ta: Kind<T, A>, f: (a: A) => Kind2<F, E, B>) => Kind2<F, E, Kind<T, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(ta: Kind<T, A>, f: (a: A) => Kind<F, B>) => Kind<F, Kind<T, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(ta: Kind<T, A>, f: (a: A) => HKT<F, B>) => HKT<F, Kind<T, B>>;
}

// @public (undocumented)
interface Traverse2<T extends URIS2> {
    // (undocumented)
    <F extends URIS4>(F: Applicative4<F>): <TE, A, S, R, FE, B>(ta: Kind2<T, TE, A>, f: (a: A) => Kind4<F, S, R, FE, B>) => Kind4<F, S, R, FE, Kind2<T, TE, B>>;
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <TE, A, R, FE, B>(ta: Kind2<T, TE, A>, f: (a: A) => Kind3<F, R, FE, B>) => Kind3<F, R, FE, Kind2<T, TE, B>>;
    // (undocumented)
    <F extends URIS3, FE>(F: Applicative3C<F, FE>): <TE, A, R, B>(ta: Kind2<T, TE, A>, f: (a: A) => Kind3<F, R, FE, B>) => Kind3<F, R, FE, Kind2<T, TE, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <TE, A, FE, B>(ta: Kind2<T, TE, A>, f: (a: A) => Kind2<F, FE, B>) => Kind2<F, FE, Kind2<T, TE, B>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <TE, A, B>(ta: Kind2<T, TE, A>, f: (a: A) => Kind2<F, FE, B>) => Kind2<F, FE, Kind2<T, TE, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <E, A, B>(ta: Kind2<T, E, A>, f: (a: A) => Kind<F, B>) => Kind<F, Kind2<T, E, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <E, A, B>(ta: Kind2<T, E, A>, f: (a: A) => HKT<F, B>) => HKT<F, Kind2<T, E, B>>;
}

// @public (undocumented)
interface Traverse2C<T extends URIS2, E> {
    // (undocumented)
    <F extends URIS4>(F: Applicative4<F>): <A, S, R, FE, B>(ta: Kind2<T, E, A>, f: (a: A) => Kind4<F, S, R, FE, B>) => Kind4<F, S, R, FE, Kind2<T, E, B>>;
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, FE, B>(ta: Kind2<T, E, A>, f: (a: A) => Kind3<F, R, FE, B>) => Kind3<F, R, FE, Kind2<T, E, B>>;
    // (undocumented)
    <F extends URIS3, FE>(F: Applicative3C<F, FE>): <A, R, B>(ta: Kind2<T, E, A>, f: (a: A) => Kind3<F, R, FE, B>) => Kind3<F, R, FE, Kind2<T, E, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, FE, B>(ta: Kind2<T, E, A>, f: (a: A) => Kind2<F, FE, B>) => Kind2<F, FE, Kind2<T, E, B>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <A, B>(ta: Kind2<T, E, A>, f: (a: A) => Kind2<F, FE, B>) => Kind2<F, FE, Kind2<T, E, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(ta: Kind2<T, E, A>, f: (a: A) => Kind<F, B>) => Kind<F, Kind2<T, E, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(ta: Kind2<T, E, A>, f: (a: A) => HKT<F, B>) => HKT<F, Kind2<T, E, B>>;
}

// @public (undocumented)
interface Traverse3<T extends URIS3> {
    // (undocumented)
    <F extends URIS4>(F: Applicative4<F>): <TR, TE, A, S, FR, FE, B>(ta: Kind3<T, TR, TE, A>, f: (a: A) => Kind4<F, S, FR, FE, B>) => Kind4<F, S, FR, FE, Kind3<T, TR, TE, B>>;
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <TR, TE, A, FR, FE, B>(ta: Kind3<T, TR, TE, A>, f: (a: A) => Kind3<F, FR, FE, B>) => Kind3<F, FR, FE, Kind3<T, TR, TE, B>>;
    // (undocumented)
    <F extends URIS3, FE>(F: Applicative3C<F, FE>): <TR, TE, A, FR, B>(ta: Kind3<T, TR, TE, A>, f: (a: A) => Kind3<F, FR, FE, B>) => Kind3<F, FR, FE, Kind3<T, TR, TE, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <TR, A, TE, FE, B>(ta: Kind3<T, TR, TE, A>, f: (a: A) => Kind2<F, FE, B>) => Kind2<F, FE, Kind3<T, TR, TE, B>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <R, TE, A, B>(ta: Kind3<T, R, TE, A>, f: (a: A) => Kind2<F, FE, B>) => Kind2<F, FE, Kind3<T, R, TE, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <R, E, A, B>(ta: Kind3<T, R, E, A>, f: (a: A) => Kind<F, B>) => Kind<F, Kind3<T, R, E, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <R, E, A, B>(ta: Kind3<T, R, E, A>, f: (a: A) => HKT<F, B>) => HKT<F, Kind3<T, R, E, B>>;
}

// @public
function traverse_<M extends URIS3, F extends URIS>(M: Applicative3<M>, F: Foldable1<F>): <R, E, A, B>(fa: Kind<F, A>, f: (a: A) => Kind3<M, R, E, B>) => Kind3<M, R, E, void>;

// @public (undocumented)
function traverse_<M extends URIS2, F extends URIS>(M: Applicative2<M>, F: Foldable1<F>): <E, A, B>(fa: Kind<F, A>, f: (a: A) => Kind2<M, E, B>) => Kind2<M, E, void>;

// @public (undocumented)
function traverse_<M extends URIS2, F extends URIS, E>(M: Applicative2C<M, E>, F: Foldable1<F>): <A, B>(fa: Kind<F, A>, f: (a: A) => Kind2<M, E, B>) => Kind2<M, E, void>;

// @public (undocumented)
function traverse_<M extends URIS, F extends URIS>(M: Applicative1<M>, F: Foldable1<F>): <A, B>(fa: Kind<F, A>, f: (a: A) => Kind<M, B>) => Kind<M, void>;

// @public (undocumented)
function traverse_<M, F>(M: Applicative<M>, F: Foldable_6<F>): <A, B>(fa: HKT<F, A>, f: (a: A) => HKT<M, B>) => HKT<M, void>;

// @public (undocumented)
function traverse_10<F extends URIS4>(F: Applicative4<F>): <S, R, E, A, B>(f: (a: A) => Kind4<F, S, R, E, B>) => <K extends string>(ta: Record<K, A>) => Kind4<F, S, R, E, Record<K, B>>;

// @public (undocumented)
function traverse_10<F extends URIS3>(F: Applicative3<F>): <R, E, A, B>(f: (a: A) => Kind3<F, R, E, B>) => <K extends string>(ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>;

// @public (undocumented)
function traverse_10<F extends URIS3, E>(F: Applicative3C<F, E>): <R, A, B>(f: (a: A) => Kind3<F, R, E, B>) => <K extends string>(ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>;

// @public (undocumented)
function traverse_10<F extends URIS2>(F: Applicative2<F>): <E, A, B>(f: (a: A) => Kind2<F, E, B>) => <K extends string>(ta: Record<K, A>) => Kind2<F, E, Record<K, B>>;

// @public (undocumented)
function traverse_10<F extends URIS2, E>(F: Applicative2C<F, E>): <A, B>(f: (a: A) => Kind2<F, E, B>) => <K extends string>(ta: Record<K, A>) => Kind2<F, E, Record<K, B>>;

// @public (undocumented)
function traverse_10<F extends URIS>(F: Applicative1<F>): <A, B>(f: (a: A) => Kind<F, B>) => <K extends string>(ta: Record<K, A>) => Kind<F, Record<K, B>>;

// @public (undocumented)
function traverse_10<F>(F: Applicative<F>): <A, B>(f: (a: A) => HKT<F, B>) => <K extends string>(ta: Record<K, A>) => HKT<F, Record<K, B>>;

// @public (undocumented)
const traverse_11: PipeableTraverse2<URI_35>;

// @public
function traverse_12<T extends URIS, G extends URIS2>(T: Traversable1<T>, G: Traversable2<G>): {
    <F extends URIS4>(F: Applicative4<F>): <A, S, R, FE, B>(f: (a: A) => Kind4<F, S, R, FE, B>) => <GE>(tga: Kind<T, Kind2<G, GE, A>>) => Kind4<F, S, R, FE, Kind<T, Kind2<G, GE, B>>>;
    <F extends URIS3>(F: Applicative3<F>): <A, R, FE, B>(f: (a: A) => Kind3<F, R, FE, B>) => <GE>(tga: Kind<T, Kind2<G, GE, A>>) => Kind3<F, R, FE, Kind<T, Kind2<G, GE, B>>>;
    <F extends URIS3, FE>(F: Applicative3C<F, FE>): <A, R, B>(f: (a: A) => Kind3<F, R, FE, B>) => <GE>(tga: Kind<T, Kind2<G, GE, A>>) => Kind3<F, R, FE, Kind<T, Kind2<G, GE, B>>>;
    <F extends URIS2>(F: Applicative2<F>): <A, FE, B>(f: (a: A) => Kind2<F, FE, B>) => <GE>(tga: Kind<T, Kind2<G, GE, A>>) => Kind2<F, FE, Kind<T, Kind2<G, GE, B>>>;
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <A, B>(f: (a: A) => Kind2<F, FE, B>) => <GE>(tga: Kind<T, Kind2<G, GE, A>>) => Kind2<F, FE, Kind<T, Kind2<G, GE, B>>>;
    <F extends URIS>(F: Applicative1<F>): <A, B>(f: (a: A) => Kind<F, B>) => <GE>(tga: Kind<T, Kind2<G, GE, A>>) => Kind<F, Kind<T, Kind2<G, GE, B>>>;
    <F>(F: Applicative<F>): <A, B>(f: (a: A) => HKT<F, B>) => <GE>(tga: Kind<T, Kind2<G, GE, A>>) => HKT<F, Kind<T, Kind2<G, GE, B>>>;
};

// @public (undocumented)
function traverse_12<T extends URIS, G extends URIS>(T: Traversable1<T>, G: Traversable1<G>): {
    <F extends URIS4>(F: Applicative4<F>): <A, S, R, E, B>(f: (a: A) => Kind4<F, S, R, E, B>) => (tga: Kind<T, Kind<G, A>>) => Kind4<F, S, R, E, Kind<T, Kind<G, B>>>;
    <F extends URIS3>(F: Applicative3<F>): <A, R, E, B>(f: (a: A) => Kind3<F, R, E, B>) => (tga: Kind<T, Kind<G, A>>) => Kind3<F, R, E, Kind<T, Kind<G, B>>>;
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B>(f: (a: A) => Kind3<F, R, E, B>) => (tga: Kind<T, Kind<G, A>>) => Kind3<F, R, E, Kind<T, Kind<G, B>>>;
    <F extends URIS2>(F: Applicative2<F>): <A, E, B>(f: (a: A) => Kind2<F, E, B>) => (tga: Kind<T, Kind<G, A>>) => Kind2<F, E, Kind<T, Kind<G, B>>>;
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B>(f: (a: A) => Kind2<F, E, B>) => (tga: Kind<T, Kind<G, A>>) => Kind2<F, E, Kind<T, Kind<G, B>>>;
    <F extends URIS>(F: Applicative1<F>): <A, B>(f: (a: A) => Kind<F, B>) => (tga: Kind<T, Kind<G, A>>) => Kind<F, Kind<T, Kind<G, B>>>;
    <F>(F: Applicative<F>): <A, B>(f: (a: A) => HKT<F, B>) => (tga: Kind<T, Kind<G, A>>) => HKT<F, Kind<T, Kind<G, B>>>;
};

// @public (undocumented)
function traverse_12<T, G>(T: Traversable_12<T>, G: Traversable_12<G>): <F>(F: Applicative<F>) => <A, B>(f: (a: A) => HKT<F, B>) => (tga: HKT<T, HKT<G, A>>) => HKT<F, HKT<T, HKT<G, B>>>;

// @public (undocumented)
const traverse_13: PipeableTraverse1<URI_37>;

// @public (undocumented)
const traverse_14: PipeableTraverse2<URI_38>;

// @public (undocumented)
const traverse_2: PipeableTraverse1<URI_3>;

// @public
const traverse_3: PipeableTraverse1<URI_4>;

// @public (undocumented)
const traverse_4: PipeableTraverse1<URI_7>;

// @public
const traverse_5: PipeableTraverse2<URI_6>;

// @public (undocumented)
const traverse_6: PipeableTraverse1<URI_11>;

// @public (undocumented)
const traverse_7: PipeableTraverse1<URI_24>;

// @public (undocumented)
function traverse_8<F extends URIS4>(F: Applicative4<F>): <S, R, E, A, B>(f: (a: A) => Kind4<F, S, R, E, B>) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind4<F, S, R, E, ReadonlyRecord<K, B>>;

// @public (undocumented)
function traverse_8<F extends URIS3>(F: Applicative3<F>): <R, E, A, B>(f: (a: A) => Kind3<F, R, E, B>) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind3<F, R, E, ReadonlyRecord<K, B>>;

// @public (undocumented)
function traverse_8<F extends URIS3, E>(F: Applicative3C<F, E>): <R, A, B>(f: (a: A) => Kind3<F, R, E, B>) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind3<F, R, E, ReadonlyRecord<K, B>>;

// @public (undocumented)
function traverse_8<F extends URIS2>(F: Applicative2<F>): <E, A, B>(f: (a: A) => Kind2<F, E, B>) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind2<F, E, ReadonlyRecord<K, B>>;

// @public (undocumented)
function traverse_8<F extends URIS2, E>(F: Applicative2C<F, E>): <A, B>(f: (a: A) => Kind2<F, E, B>) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind2<F, E, ReadonlyRecord<K, B>>;

// @public (undocumented)
function traverse_8<F extends URIS>(F: Applicative1<F>): <A, B>(f: (a: A) => Kind<F, B>) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind<F, ReadonlyRecord<K, B>>;

// @public (undocumented)
function traverse_8<F>(F: Applicative<F>): <A, B>(f: (a: A) => HKT<F, B>) => <K extends string>(ta: ReadonlyRecord<K, A>) => HKT<F, ReadonlyRecord<K, B>>;

// @public (undocumented)
const traverse_9: PipeableTraverse2<URI_28>;

// @public
const traverseArray: <A, B>(f: (a: A) => Option_2<B>) => (as: readonly A[]) => Option_2<readonly B[]>;

// @public
const traverseArray_10: <A, B, E>(f: (a: A) => TaskEither<E, B>) => (as: readonly A[]) => TaskEither<E, readonly B[]>;

// @public
const traverseArray_11: <R, E, A, B>(f: (a: A) => ReaderTaskEither<R, E, B>) => (as: readonly A[]) => ReaderTaskEither<R, E, readonly B[]>;

// @public
const traverseArray_12: <A, S, B>(f: (a: A) => State<S, B>) => (as: readonly A[]) => State<S, readonly B[]>;

// @public
const traverseArray_13: <S, R, E, A, B>(f: (a: A) => StateReaderTaskEither<S, R, E, B>) => (as: readonly A[]) => StateReaderTaskEither<S, R, E, readonly B[]>;

// @public
const traverseArray_14: <A, B>(f: (a: A) => TaskOption<B>) => (as: ReadonlyArray<A>) => TaskOption<ReadonlyArray<B>>;

// @public
const traverseArray_2: <E, A, B>(f: (a: A) => Either<E, B>) => (as: readonly A[]) => Either<E, readonly B[]>;

// @public
const traverseArray_3: <A, B>(f: (a: A) => IO<B>) => (as: readonly A[]) => IO<readonly B[]>;

// @public
const traverseArray_4: <A, E, B>(f: (a: A) => IOEither<E, B>) => (as: readonly A[]) => IOEither<E, readonly B[]>;

// @public
const traverseArray_5: <R, A, B>(f: (a: A) => Reader<R, B>) => (as: readonly A[]) => Reader<R, readonly B[]>;

// @public
const traverseArray_6: <R, E, A, B>(f: (a: A) => ReaderEither<R, E, B>) => (as: readonly A[]) => ReaderEither<R, E, readonly B[]>;

// @public
const traverseArray_7: <A, R, B>(f: (a: A) => ReaderIO<R, B>) => (as: readonly A[]) => ReaderIO<R, readonly B[]>;

// @public
const traverseArray_8: <A, B>(f: (a: A) => Task<B>) => (as: readonly A[]) => Task<readonly B[]>;

// @public
const traverseArray_9: <R, A, B>(f: (a: A) => ReaderTask<R, B>) => (as: readonly A[]) => ReaderTask<R, readonly B[]>;

// @public
const traverseArrayWithIndex: <A, B>(f: (index: number, a: A) => Option_2<B>) => (as: ReadonlyArray<A>) => Option_2<ReadonlyArray<B>>;

// @public
const traverseArrayWithIndex_10: <A, B, E>(f: (index: number, a: A) => TaskEither<E, B>) => (as: ReadonlyArray<A>) => TaskEither<E, ReadonlyArray<B>>;

// @public
const traverseArrayWithIndex_11: <R, E, A, B>(f: (index: number, a: A) => ReaderTaskEither<R, E, B>) => (as: ReadonlyArray<A>) => ReaderTaskEither<R, E, ReadonlyArray<B>>;

// @public
const traverseArrayWithIndex_12: <A, S, B>(f: (index: number, a: A) => State<S, B>) => (as: ReadonlyArray<A>) => State<S, ReadonlyArray<B>>;

// @public
const traverseArrayWithIndex_13: <S, R, E, A, B>(f: (index: number, a: A) => StateReaderTaskEither<S, R, E, B>) => (as: ReadonlyArray<A>) => StateReaderTaskEither<S, R, E, ReadonlyArray<B>>;

// @public
const traverseArrayWithIndex_14: <A, B>(f: (index: number, a: A) => TaskOption<B>) => (as: ReadonlyArray<A>) => TaskOption<ReadonlyArray<B>>;

// @public
const traverseArrayWithIndex_2: <E, A, B>(f: (index: number, a: A) => Either<E, B>) => (as: ReadonlyArray<A>) => Either<E, ReadonlyArray<B>>;

// @public
const traverseArrayWithIndex_3: <A, B>(f: (index: number, a: A) => IO<B>) => (as: ReadonlyArray<A>) => IO<ReadonlyArray<B>>;

// @public
const traverseArrayWithIndex_4: <A, E, B>(f: (index: number, a: A) => IOEither<E, B>) => (as: ReadonlyArray<A>) => IOEither<E, ReadonlyArray<B>>;

// @public
const traverseArrayWithIndex_5: <R, A, B>(f: (index: number, a: A) => Reader<R, B>) => (as: ReadonlyArray<A>) => Reader<R, ReadonlyArray<B>>;

// @public
const traverseArrayWithIndex_6: <R, E, A, B>(f: (index: number, a: A) => ReaderEither<R, E, B>) => (as: ReadonlyArray<A>) => ReaderEither<R, E, ReadonlyArray<B>>;

// @public
const traverseArrayWithIndex_7: <A, R, B>(f: (index: number, a: A) => ReaderIO<R, B>) => (as: ReadonlyArray<A>) => ReaderIO<R, ReadonlyArray<B>>;

// @public
const traverseArrayWithIndex_8: <A, B>(f: (index: number, a: A) => Task<B>) => (as: ReadonlyArray<A>) => Task<ReadonlyArray<B>>;

// @public
const traverseArrayWithIndex_9: <R, A, B>(f: (index: number, a: A) => ReaderTask<R, B>) => (as: ReadonlyArray<A>) => ReaderTask<R, ReadonlyArray<B>>;

// @public @deprecated (undocumented)
interface TraverseComposition11<F extends URIS, G extends URIS> {
    // (undocumented)
    <H extends URIS3>(H: Applicative3<H>): <R, E, A, B>(fga: Kind<F, Kind<G, A>>, f: (a: A) => Kind3<H, R, E, B>) => Kind3<H, R, E, Kind<F, Kind<G, B>>>;
    // (undocumented)
    <H extends URIS2>(H: Applicative2<H>): <E, A, B>(fga: Kind<F, Kind<G, A>>, f: (a: A) => Kind2<H, E, B>) => Kind2<H, E, Kind<F, Kind<G, B>>>;
    // (undocumented)
    <H extends URIS2, E>(H: Applicative2C<H, E>): <A, B>(fga: Kind<F, Kind<G, A>>, f: (a: A) => Kind2<H, E, B>) => Kind2<H, E, Kind<F, Kind<G, B>>>;
    // (undocumented)
    <H extends URIS>(H: Applicative1<H>): <A, B>(fga: Kind<F, Kind<G, A>>, f: (a: A) => Kind<H, B>) => Kind<H, Kind<F, Kind<G, B>>>;
    // (undocumented)
    <H>(H: Applicative<H>): <A, B>(fga: Kind<F, Kind<G, A>>, f: (a: A) => HKT<H, B>) => HKT<H, Kind<F, Kind<G, B>>>;
}

// @public
const traverseReadonlyArrayWithIndex: <A, B>(f: (index: number, a: A) => Option_2<B>) => (as: readonly A[]) => Option_2<readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_10: <A, R, B>(f: (index: number, a: A) => ReaderTask<R, B>) => (as: readonly A[]) => ReaderTask<R, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_11: <A, E, B>(f: (index: number, a: A) => TaskEither<E, B>) => (as: readonly A[]) => TaskEither<E, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_12: <A, R, E, B>(f: (index: number, a: A) => ReaderTaskEither<R, E, B>) => (as: readonly A[]) => ReaderTaskEither<R, E, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_13: <A, S, B>(f: (index: number, a: A) => State<S, B>) => (as: readonly A[]) => State<S, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_14: <A, S, R, E, B>(f: (index: number, a: A) => StateReaderTaskEither<S, R, E, B>) => (as: readonly A[]) => StateReaderTaskEither<S, R, E, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_15: <A, B>(f: (index: number, a: A) => TaskOption<B>) => (as: readonly A[]) => TaskOption<readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_16: <E>(S: Semigroup<E>) => <A, B>(f: (index: number, a: A) => These<E, B>) => (as: readonly A[]) => These<E, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_17: <E>(S: Semigroup<E>) => <A, B>(f: (index: number, a: A) => TaskThese<E, B>) => (as: readonly A[]) => TaskThese<E, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_2: <A, E, B>(f: (index: number, a: A) => Either<E, B>) => (as: readonly A[]) => Either<E, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_3: <A, B>(f: (index: number, a: A) => IO<B>) => (as: readonly A[]) => IO<readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_4: <A, E, B>(f: (index: number, a: A) => IOEither<E, B>) => (as: readonly A[]) => IOEither<E, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_5: <A, B>(f: (index: number, a: A) => IOOption<B>) => (as: readonly A[]) => IOOption<readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_6: <A, R, B>(f: (index: number, a: A) => Reader<R, B>) => (as: readonly A[]) => Reader<R, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_7: <A, R, E, B>(f: (index: number, a: A) => ReaderEither<R, E, B>) => (as: readonly A[]) => ReaderEither<R, E, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_8: <A, R, B>(f: (index: number, a: A) => ReaderIO<R, B>) => (as: readonly A[]) => ReaderIO<R, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndex_9: <A, B>(f: (index: number, a: A) => Task<B>) => (as: readonly A[]) => Task<readonly B[]>;

// @public
const traverseReadonlyArrayWithIndexSeq: <A, E, B>(f: (index: number, a: A) => IOEither<E, B>) => (as: readonly A[]) => IOEither<E, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndexSeq_2: <A, B>(f: (index: number, a: A) => Task<B>) => (as: readonly A[]) => Task<readonly B[]>;

// @public
const traverseReadonlyArrayWithIndexSeq_3: <R, A, B>(f: (index: number, a: A) => ReaderTask<R, B>) => (as: readonly A[]) => ReaderTask<R, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndexSeq_4: <A, E, B>(f: (index: number, a: A) => TaskEither<E, B>) => (as: readonly A[]) => TaskEither<E, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndexSeq_5: <A, R, E, B>(f: (index: number, a: A) => ReaderTaskEither<R, E, B>) => (as: readonly A[]) => ReaderTaskEither<R, E, readonly B[]>;

// @public
const traverseReadonlyArrayWithIndexSeq_6: <A, B>(f: (index: number, a: A) => TaskOption<B>) => (as: readonly A[]) => TaskOption<readonly B[]>;

// @public
const traverseReadonlyArrayWithIndexSeq_7: <E>(S: Semigroup<E>) => <A, B>(f: (index: number, a: A) => TaskThese<E, B>) => (as: readonly A[]) => TaskThese<E, readonly B[]>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex: <A, B>(f: (index: number, a: A) => Option_2<B>) => (as: ReadonlyNonEmptyArray<A>) => Option_2<ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_10: <A, R, B>(f: (index: number, a: A) => ReaderTask<R, B>) => (as: ReadonlyNonEmptyArray<A>) => ReaderTask<R, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_11: <A, E, B>(f: (index: number, a: A) => TaskEither<E, B>) => (as: ReadonlyNonEmptyArray<A>) => TaskEither<E, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_12: <A, R, E, B>(f: (index: number, a: A) => ReaderTaskEither<R, E, B>) => (as: ReadonlyNonEmptyArray<A>) => ReaderTaskEither<R, E, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_13: <A, S, B>(f: (index: number, a: A) => State<S, B>) => (as: ReadonlyNonEmptyArray<A>) => State<S, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_14: <A, S, R, E, B>(f: (index: number, a: A) => StateReaderTaskEither<S, R, E, B>) => (as: ReadonlyNonEmptyArray<A>) => StateReaderTaskEither<S, R, E, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_15: <A, B>(f: (index: number, a: A) => TaskOption<B>) => (as: ReadonlyNonEmptyArray<A>) => TaskOption<ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_16: <E>(S: Semigroup<E>) => <A, B>(f: (index: number, a: A) => These<E, B>) => (as: ReadonlyNonEmptyArray<A>) => These<E, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_17: <E>(S: Semigroup<E>) => <A, B>(f: (index: number, a: A) => TaskThese<E, B>) => (as: ReadonlyNonEmptyArray<A>) => TaskThese<E, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_2: <A, E, B>(f: (index: number, a: A) => Either<E, B>) => (as: ReadonlyNonEmptyArray<A>) => Either<E, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_3: <A, B>(f: (index: number, a: A) => IO<B>) => (as: ReadonlyNonEmptyArray<A>) => IO<ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_4: <A, E, B>(f: (index: number, a: A) => IOEither<E, B>) => (as: ReadonlyNonEmptyArray<A>) => IOEither<E, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_5: <A, B>(f: (index: number, a: A) => IOOption<B>) => (as: ReadonlyNonEmptyArray<A>) => IOOption<ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_6: <A, R, B>(f: (index: number, a: A) => Reader<R, B>) => (as: ReadonlyNonEmptyArray<A>) => Reader<R, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_7: <A, R, E, B>(f: (index: number, a: A) => ReaderEither<R, E, B>) => (as: ReadonlyNonEmptyArray<A>) => ReaderEither<R, E, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_8: <A, R, B>(f: (index: number, a: A) => ReaderIO<R, B>) => (as: ReadonlyNonEmptyArray<A>) => ReaderIO<R, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndex_9: <A, B>(f: (index: number, a: A) => Task<B>) => (as: ReadonlyNonEmptyArray<A>) => Task<ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndexSeq: <A, E, B>(f: (index: number, a: A) => IOEither<E, B>) => (as: ReadonlyNonEmptyArray<A>) => IOEither<E, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndexSeq_2: <A, B>(f: (index: number, a: A) => Task<B>) => (as: ReadonlyNonEmptyArray<A>) => Task<ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndexSeq_3: <R, A, B>(f: (index: number, a: A) => ReaderTask<R, B>) => (as: ReadonlyNonEmptyArray<A>) => ReaderTask<R, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndexSeq_4: <A, E, B>(f: (index: number, a: A) => TaskEither<E, B>) => (as: ReadonlyNonEmptyArray<A>) => TaskEither<E, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndexSeq_5: <A, R, E, B>(f: (index: number, a: A) => ReaderTaskEither<R, E, B>) => (as: ReadonlyNonEmptyArray<A>) => ReaderTaskEither<R, E, ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndexSeq_6: <A, B>(f: (index: number, a: A) => TaskOption<B>) => (as: ReadonlyNonEmptyArray<A>) => TaskOption<ReadonlyNonEmptyArray<B>>;

// @public
const traverseReadonlyNonEmptyArrayWithIndexSeq_7: <E>(S: Semigroup<E>) => <A, B>(f: (index: number, a: A) => TaskThese<E, B>) => (as: ReadonlyNonEmptyArray<A>) => TaskThese<E, ReadonlyNonEmptyArray<B>>;

// @public
const traverseSeqArray: <A, E, B>(f: (a: A) => IOEither<E, B>) => (as: readonly A[]) => IOEither<E, readonly B[]>;

// @public
const traverseSeqArray_2: <A, B>(f: (a: A) => Task<B>) => (as: readonly A[]) => Task<readonly B[]>;

// @public
const traverseSeqArray_3: <R, A, B>(f: (a: A) => ReaderTask<R, B>) => (as: readonly A[]) => ReaderTask<R, readonly B[]>;

// @public
const traverseSeqArray_4: <A, B, E>(f: (a: A) => TaskEither<E, B>) => (as: readonly A[]) => TaskEither<E, readonly B[]>;

// @public
const traverseSeqArray_5: <R, E, A, B>(f: (a: A) => ReaderTaskEither<R, E, B>) => (as: readonly A[]) => ReaderTaskEither<R, E, readonly B[]>;

// @public
const traverseSeqArray_6: <A, B>(f: (a: A) => TaskOption<B>) => (as: ReadonlyArray<A>) => TaskOption<ReadonlyArray<B>>;

// @public
const traverseSeqArrayWithIndex: <A, E, B>(f: (index: number, a: A) => IOEither<E, B>) => (as: ReadonlyArray<A>) => IOEither<E, ReadonlyArray<B>>;

// @public
const traverseSeqArrayWithIndex_2: <A, B>(f: (index: number, a: A) => Task<B>) => (as: ReadonlyArray<A>) => Task<ReadonlyArray<B>>;

// @public
const traverseSeqArrayWithIndex_3: <R, A, B>(f: (index: number, a: A) => ReaderTask<R, B>) => (as: ReadonlyArray<A>) => ReaderTask<R, ReadonlyArray<B>>;

// @public
const traverseSeqArrayWithIndex_4: <A, B, E>(f: (index: number, a: A) => TaskEither<E, B>) => (as: ReadonlyArray<A>) => TaskEither<E, ReadonlyArray<B>>;

// @public
const traverseSeqArrayWithIndex_5: <R, E, A, B>(f: (index: number, a: A) => ReaderTaskEither<R, E, B>) => (as: ReadonlyArray<A>) => ReaderTaskEither<R, E, ReadonlyArray<B>>;

// @public
const traverseSeqArrayWithIndex_6: <A, B>(f: (index: number, a: A) => TaskOption<B>) => (as: ReadonlyArray<A>) => TaskOption<ReadonlyArray<B>>;

// @public (undocumented)
interface TraverseWithIndex<T, I> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, E, B>(ta: HKT<T, A>, f: (i: I, a: A) => Kind3<F, R, E, B>) => Kind3<F, R, E, HKT<T, B>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B>(ta: HKT<T, A>, f: (i: I, a: A) => Kind3<F, R, E, B>) => Kind3<F, R, E, HKT<T, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, E, B>(ta: HKT<T, A>, f: (i: I, a: A) => Kind2<F, E, B>) => Kind2<F, E, HKT<T, B>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B>(ta: HKT<T, A>, f: (i: I, a: A) => Kind2<F, E, B>) => Kind2<F, E, HKT<T, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(ta: HKT<T, A>, f: (i: I, a: A) => Kind<F, B>) => Kind<F, HKT<T, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(ta: HKT<T, A>, f: (i: I, a: A) => HKT<F, B>) => HKT<F, HKT<T, B>>;
}

// @public (undocumented)
const traverseWithIndex: PipeableTraverseWithIndex1<URI_2, number>;

// @public (undocumented)
interface TraverseWithIndex1<T extends URIS, I> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, E, B>(ta: Kind<T, A>, f: (i: I, a: A) => Kind3<F, R, E, B>) => Kind3<F, R, E, Kind<T, B>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B>(ta: Kind<T, A>, f: (i: I, a: A) => Kind3<F, R, E, B>) => Kind3<F, R, E, Kind<T, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, E, B>(ta: Kind<T, A>, f: (i: I, a: A) => Kind2<F, E, B>) => Kind2<F, E, Kind<T, B>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B>(ta: Kind<T, A>, f: (i: I, a: A) => Kind2<F, E, B>) => Kind2<F, E, Kind<T, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(ta: Kind<T, A>, f: (i: I, a: A) => Kind<F, B>) => Kind<F, Kind<T, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(ta: Kind<T, A>, f: (i: I, a: A) => HKT<F, B>) => HKT<F, Kind<T, B>>;
}

// @public (undocumented)
interface TraverseWithIndex2<T extends URIS2, I> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <TE, A, R, FE, B>(ta: Kind2<T, TE, A>, f: (i: I, a: A) => Kind3<F, R, FE, B>) => Kind3<F, R, FE, Kind2<T, TE, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <TE, A, FE, B>(ta: Kind2<T, TE, A>, f: (i: I, a: A) => Kind2<F, FE, B>) => Kind2<F, FE, Kind2<T, TE, B>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <TE, A, B>(ta: Kind2<T, TE, A>, f: (i: I, a: A) => Kind2<F, FE, B>) => Kind2<F, FE, Kind2<T, TE, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <E, A, B>(ta: Kind2<T, E, A>, f: (i: I, a: A) => Kind<F, B>) => Kind<F, Kind2<T, E, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <E, A, B>(ta: Kind2<T, E, A>, f: (i: I, a: A) => HKT<F, B>) => HKT<F, Kind2<T, E, B>>;
}

// @public (undocumented)
interface TraverseWithIndex2C<T extends URIS2, I, E> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, FE, B>(ta: Kind2<T, E, A>, f: (i: I, a: A) => Kind3<F, R, FE, B>) => Kind3<F, R, FE, Kind2<T, E, B>>;
    // (undocumented)
    <F extends URIS3>(F: Applicative3C<F, E>): <A, R, B>(ta: Kind2<T, E, A>, f: (i: I, a: A) => Kind3<F, R, E, B>) => Kind3<F, R, E, Kind2<T, E, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, FE, B>(ta: Kind2<T, E, A>, f: (i: I, a: A) => Kind2<F, FE, B>) => Kind2<F, FE, Kind2<T, E, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2C<F, E>): <A, B>(ta: Kind2<T, E, A>, f: (i: I, a: A) => Kind2<F, E, B>) => Kind2<F, E, Kind2<T, E, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(ta: Kind2<T, E, A>, f: (i: I, a: A) => Kind<F, B>) => Kind<F, Kind2<T, E, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(ta: Kind2<T, E, A>, f: (i: I, a: A) => HKT<F, B>) => HKT<F, Kind2<T, E, B>>;
}

// @public (undocumented)
const traverseWithIndex_2: PipeableTraverseWithIndex1<URI_3, number>;

// @public
const traverseWithIndex_3: PipeableTraverseWithIndex1<URI_4, number>;

// @public (undocumented)
const traverseWithIndex_4: PipeableTraverseWithIndex1<URI_24, number>;

// @public (undocumented)
function traverseWithIndex_5<F extends URIS4>(F: Applicative4<F>): <K extends string, S, R, E, A, B>(f: (k: K, a: A) => Kind4<F, S, R, E, B>) => (ta: ReadonlyRecord<K, A>) => Kind4<F, S, R, E, ReadonlyRecord<K, B>>;

// @public (undocumented)
function traverseWithIndex_5<F extends URIS3>(F: Applicative3<F>): <K extends string, R, E, A, B>(f: (k: K, a: A) => Kind3<F, R, E, B>) => (ta: ReadonlyRecord<K, A>) => Kind3<F, R, E, ReadonlyRecord<K, B>>;

// @public (undocumented)
function traverseWithIndex_5<F extends URIS3, E>(F: Applicative3C<F, E>): <K extends string, R, A, B>(f: (k: K, a: A) => Kind3<F, R, E, B>) => (ta: ReadonlyRecord<K, A>) => Kind3<F, R, E, ReadonlyRecord<K, B>>;

// @public (undocumented)
function traverseWithIndex_5<F extends URIS2>(F: Applicative2<F>): <K extends string, E, A, B>(f: (k: K, a: A) => Kind2<F, E, B>) => (ta: ReadonlyRecord<K, A>) => Kind2<F, E, ReadonlyRecord<K, B>>;

// @public (undocumented)
function traverseWithIndex_5<F extends URIS2, E>(F: Applicative2C<F, E>): <K extends string, A, B>(f: (k: K, a: A) => Kind2<F, E, B>) => (ta: ReadonlyRecord<K, A>) => Kind2<F, E, ReadonlyRecord<K, B>>;

// @public (undocumented)
function traverseWithIndex_5<F extends URIS>(F: Applicative1<F>): <K extends string, A, B>(f: (k: K, a: A) => Kind<F, B>) => (ta: ReadonlyRecord<K, A>) => Kind<F, ReadonlyRecord<K, B>>;

// @public (undocumented)
function traverseWithIndex_5<F>(F: Applicative<F>): <K extends string, A, B>(f: (k: K, a: A) => HKT<F, B>) => (ta: ReadonlyRecord<K, A>) => HKT<F, ReadonlyRecord<K, B>>;

// @public (undocumented)
function traverseWithIndex_6<F extends URIS4>(F: Applicative4<F>): <K extends string, S, R, E, A, B>(f: (k: K, a: A) => Kind4<F, S, R, E, B>) => (ta: Record<K, A>) => Kind4<F, S, R, E, Record<K, B>>;

// @public (undocumented)
function traverseWithIndex_6<F extends URIS3>(F: Applicative3<F>): <K extends string, R, E, A, B>(f: (k: K, a: A) => Kind3<F, R, E, B>) => (ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>;

// @public (undocumented)
function traverseWithIndex_6<F extends URIS3, E>(F: Applicative3C<F, E>): <K extends string, R, A, B>(f: (k: K, a: A) => Kind3<F, R, E, B>) => (ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>;

// @public (undocumented)
function traverseWithIndex_6<F extends URIS2>(F: Applicative2<F>): <K extends string, E, A, B>(f: (k: K, a: A) => Kind2<F, E, B>) => (ta: Record<K, A>) => Kind2<F, E, Record<K, B>>;

// @public (undocumented)
function traverseWithIndex_6<F extends URIS2, E>(F: Applicative2C<F, E>): <K extends string, A, B>(f: (k: K, a: A) => Kind2<F, E, B>) => (ta: Record<K, A>) => Kind2<F, E, Record<K, B>>;

// @public (undocumented)
function traverseWithIndex_6<F extends URIS>(F: Applicative1<F>): <K extends string, A, B>(f: (k: K, a: A) => Kind<F, B>) => (ta: Record<K, A>) => Kind<F, Record<K, B>>;

// @public (undocumented)
function traverseWithIndex_6<F>(F: Applicative<F>): <K extends string, A, B>(f: (k: K, a: A) => HKT<F, B>) => (ta: Record<K, A>) => HKT<F, Record<K, B>>;

// @public (undocumented)
interface Tree<A> {
    // (undocumented)
    readonly forest: Forest<A>;
    // (undocumented)
    readonly value: A;
}

declare namespace tree {
    export {
        make_2 as make,
        getShow_16 as getShow,
        getEq_16 as getEq,
        drawForest,
        drawTree,
        unfoldTree,
        unfoldForest,
        unfoldTreeM,
        unfoldForestM,
        fold_16 as fold,
        elem_12 as elem,
        Forest,
        Tree,
        ap_28 as ap,
        flatMap_21 as flatMap,
        extend_12 as extend,
        duplicate_10 as duplicate,
        flatten_21 as flatten,
        map_42 as map,
        reduce_18 as reduce,
        foldMap_18 as foldMap,
        reduceRight_18 as reduceRight,
        extract_6 as extract,
        traverse_13 as traverse,
        sequence_13 as sequence,
        of_25 as of,
        URI_37 as URI,
        Functor_33 as Functor,
        flap_33 as flap,
        Pointed_24 as Pointed,
        Apply_16 as Apply,
        apFirst_22 as apFirst,
        apSecond_22 as apSecond,
        Applicative_17 as Applicative,
        Chain_22 as Chain,
        Monad_22 as Monad,
        chainFirst_22 as chainFirst,
        Foldable_13 as Foldable,
        Traversable_13 as Traversable,
        Comonad_7 as Comonad,
        Do_19 as Do,
        bindTo_22 as bindTo,
        let__21 as let,
        bind_22 as bind,
        apS_22 as apS,
        exists_6 as exists,
        chain_30 as chain,
        tree_2 as tree
    }
}
export { tree }

// @public @deprecated
const tree_2: Monad1<URI_37> & Foldable1<URI_37> & Traversable1<URI_37> & Comonad1<URI_37>;

// @public (undocumented)
const trim: (s: string) => string;

// @public (undocumented)
const trimLeft: (s: string) => string;

// @public (undocumented)
const trimRight: (s: string) => string;

// @public (undocumented)
const trivial: Ord<unknown>;

// @public
const tryCatch: <A>(f: LazyArg<A>) => Option_2<A>;

// @public
const tryCatch_2: <E, A>(f: LazyArg<A>, onThrow: (e: unknown) => E) => Either<E, A>;

// @public
const tryCatch_3: <E, A>(f: LazyArg<A>, onThrow: (reason: unknown) => E) => IOEither<E, A>;

// @public
const tryCatch_4: <E, A>(f: LazyArg<Promise<A>>, onRejected: (reason: unknown) => E) => TaskEither<E, A>;

// @public
const tryCatch_5: <A>(f: LazyArg<Promise<A>>) => TaskOption<A>;

// @public
const tryCatchK: <A extends readonly unknown[], B>(f: (...a: A) => B) => (...a: A) => Option_2<B>;

// @public
const tryCatchK_2: <A extends readonly unknown[], B, E>(f: (...a: A) => B, onThrow: (error: unknown) => E) => (...a: A) => Either<E, B>;

// @public
const tryCatchK_3: <A extends readonly unknown[], B, E>(f: (...a: A) => B, onThrow: (reason: unknown) => E) => (...a: A) => IOEither<E, B>;

// @public
const tryCatchK_4: <E, A extends readonly unknown[], B>(f: (...a: A) => Promise<B>, onRejected: (reason: unknown) => E) => (...a: A) => TaskEither<E, B>;

// @public
const tryCatchK_5: <A extends readonly unknown[], B>(f: (...a: A) => Promise<B>) => (...a: A) => TaskOption<B>;

declare namespace tuple {
    export {
        getApply_5 as getApply,
        getApplicative_5 as getApplicative,
        getChain_4 as getChain,
        getMonad_4 as getMonad,
        getChainRec_2 as getChainRec,
        fst_2 as fst,
        snd_2 as snd,
        swap_11 as swap,
        bimap_15 as bimap,
        mapFst_2 as mapFst,
        mapSnd_2 as mapSnd,
        compose_5 as compose,
        extend_13 as extend,
        duplicate_11 as duplicate,
        extract_7 as extract,
        foldMap_19 as foldMap,
        reduce_19 as reduce,
        reduceRight_19 as reduceRight,
        traverse_14 as traverse,
        sequence_14 as sequence,
        URI_38 as URI,
        Functor_34 as Functor,
        flap_34 as flap,
        Bifunctor_13 as Bifunctor,
        Semigroupoid_3 as Semigroupoid,
        Comonad_8 as Comonad,
        Foldable_14 as Foldable,
        Traversable_14 as Traversable,
        map_43 as map,
        mapLeft_15 as mapLeft,
        tuple_9 as tuple
    }
}
export { tuple }

// @public
const tuple_2: <A extends readonly unknown[]>(...ords: { [K in keyof A]: Ord<A[K]>; }) => Ord<Readonly<A>>;

// @public
const tuple_3: <A extends readonly unknown[]>(...semigroups: { [K in keyof A]: Semigroup<A[K]>; }) => Semigroup<Readonly<A>>;

// @public
const tuple_4: <A extends readonly unknown[]>(...monoids: { [K in keyof A]: Monoid<A[K]>; }) => Monoid<Readonly<A>>;

// @public
const tuple_5: <A extends readonly unknown[]>(...eqs: { [K in keyof A]: Eq<A[K]>; }) => Eq<Readonly<A>>;

// @public (undocumented)
const tuple_6: <A extends readonly unknown[]>(...shows: { [K in keyof A]: Show<A[K]>; }) => Show<Readonly<A>>;

// @public (undocumented)
function tuple_7<T extends ReadonlyArray<any>>(...t: T): T;

// @public
const tuple_8: <A extends readonly unknown[]>(...rings: { [K in keyof A]: Ring<A[K]>; }) => Ring<Readonly<A>>;

// @public @deprecated
const tuple_9: Semigroupoid2<URI_38> & Bifunctor2<URI_38> & Comonad2<URI_38> & Foldable2<URI_38> & Traversable2<URI_38>;

// @public
function tupled<A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B): (a: A) => B;

// @public
const unappend: <A>(as: ReadonlyNonEmptyArray<A>) => readonly [readonly A[], A];

// @public
const unappend_2: <A>(as: NonEmptyArray<A>) => [A[], A];

// @public @deprecated
const uncons: <A>(as: ReadonlyNonEmptyArray<A>) => readonly [A, ReadonlyArray<A>];

// @public @deprecated
const uncons_2: <A>(as: NonEmptyArray<A>) => [A, Array<A>];

// @public
const unfold: <A, B>(b: B, f: (b: B) => Option_2<readonly [A, B]>) => A[];

// @public (undocumented)
const unfold_2: <A, B>(b: B, f: (b: B) => Option_2<readonly [A, B]>) => readonly A[];

// @public (undocumented)
const Unfoldable: Unfoldable1<URI_4>;

declare namespace unfoldable {
    export {
        Unfoldable_2 as Unfoldable,
        Unfoldable1,
        Unfoldable2,
        Unfoldable2C,
        Unfoldable3,
        Unfoldable3C,
        Unfoldable4
    }
}
export { unfoldable }

// @public (undocumented)
interface Unfoldable1<F extends URIS> {
    // (undocumented)
    readonly unfold: <A, B>(b: B, f: (b: B) => Option_2<[A, B]>) => Kind<F, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Unfoldable2<F extends URIS2> {
    // (undocumented)
    readonly unfold: <E, A, B>(b: B, f: (b: B) => Option_2<[A, B]>) => Kind2<F, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Unfoldable2C<F extends URIS2, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly unfold: <A, B>(b: B, f: (b: B) => Option_2<[A, B]>) => Kind2<F, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Unfoldable3<F extends URIS3> {
    // (undocumented)
    readonly unfold: <R, E, A, B>(b: B, f: (b: B) => Option_2<[A, B]>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Unfoldable3C<F extends URIS3, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly unfold: <R, A, B>(b: B, f: (b: B) => Option_2<[A, B]>) => Kind3<F, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Unfoldable4<F extends URIS4> {
    // (undocumented)
    readonly unfold: <S, R, E, A, B>(b: B, f: (b: B) => Option_2<[A, B]>) => Kind4<F, S, R, E, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
interface Unfoldable_2<F> {
    // (undocumented)
    readonly unfold: <A, B>(b: B, f: (b: B) => Option_2<[A, B]>) => HKT<F, A>;
    // (undocumented)
    readonly URI: F;
}

// @public (undocumented)
const Unfoldable_3: Unfoldable1<URI_24>;

// @public
function unfoldForest<A, B>(bs: Array<B>, f: (b: B) => [A, Array<B>]): Forest<A>;

// @public
function unfoldForestM<M extends URIS4>(M: Monad4<M>): <S, R, E, A, B>(bs: Array<B>, f: (b: B) => Kind4<M, S, R, E, [A, Array<B>]>) => Kind4<M, S, R, E, Forest<A>>;

// @public (undocumented)
function unfoldForestM<M extends URIS3>(M: Monad3<M>): <R, E, A, B>(bs: Array<B>, f: (b: B) => Kind3<M, R, E, [A, Array<B>]>) => Kind3<M, R, E, Forest<A>>;

// @public (undocumented)
function unfoldForestM<M extends URIS3, E>(M: Monad3C<M, E>): <R, A, B>(bs: Array<B>, f: (b: B) => Kind3<M, R, E, [A, Array<B>]>) => Kind3<M, R, E, Forest<A>>;

// @public (undocumented)
function unfoldForestM<M extends URIS2>(M: Monad2<M>): <R, E, B>(bs: Array<B>, f: (b: B) => Kind2<M, R, [E, Array<B>]>) => Kind2<M, R, Forest<E>>;

// @public (undocumented)
function unfoldForestM<M extends URIS2, E>(M: Monad2C<M, E>): <A, B>(bs: Array<B>, f: (b: B) => Kind2<M, E, [A, Array<B>]>) => Kind2<M, E, Forest<A>>;

// @public (undocumented)
function unfoldForestM<M extends URIS>(M: Monad1<M>): <A, B>(bs: Array<B>, f: (b: B) => Kind<M, [A, Array<B>]>) => Kind<M, Forest<A>>;

// @public (undocumented)
function unfoldForestM<M>(M: Monad_6<M>): <A, B>(bs: Array<B>, f: (b: B) => HKT<M, [A, Array<B>]>) => HKT<M, Forest<A>>;

// @public
function unfoldTree<A, B>(b: B, f: (b: B) => [A, Array<B>]): Tree<A>;

// @public
function unfoldTreeM<M extends URIS4>(M: Monad4<M>): <S, R, E, A, B>(b: B, f: (b: B) => Kind4<M, S, R, E, [A, Array<B>]>) => Kind4<M, S, R, E, Tree<A>>;

// @public (undocumented)
function unfoldTreeM<M extends URIS3>(M: Monad3<M>): <R, E, A, B>(b: B, f: (b: B) => Kind3<M, R, E, [A, Array<B>]>) => Kind3<M, R, E, Tree<A>>;

// @public (undocumented)
function unfoldTreeM<M extends URIS3, E>(M: Monad3C<M, E>): <R, A, B>(b: B, f: (b: B) => Kind3<M, R, E, [A, Array<B>]>) => Kind3<M, R, E, Tree<A>>;

// @public (undocumented)
function unfoldTreeM<M extends URIS2>(M: Monad2<M>): <E, A, B>(b: B, f: (b: B) => Kind2<M, E, [A, Array<B>]>) => Kind2<M, E, Tree<A>>;

// @public (undocumented)
function unfoldTreeM<M extends URIS2, E>(M: Monad2C<M, E>): <A, B>(b: B, f: (b: B) => Kind2<M, E, [A, Array<B>]>) => Kind2<M, E, Tree<A>>;

// @public (undocumented)
function unfoldTreeM<M extends URIS>(M: Monad1<M>): <A, B>(b: B, f: (b: B) => Kind<M, [A, Array<B>]>) => Kind<M, Tree<A>>;

// @public (undocumented)
function unfoldTreeM<M>(M: Monad_6<M>): <A, B>(b: B, f: (b: B) => HKT<M, [A, Array<B>]>) => HKT<M, Tree<A>>;

// @public
function union<A>(E: Eq<A>): {
    (xs: Array<A>): (ys: Array<A>) => Array<A>;
    (xs: Array<A>, ys: Array<A>): Array<A>;
};

// @public
function union_10<A>(E: Eq<A>): {
    (that: Set<A>): (me: Set<A>) => Set<A>;
    (me: Set<A>, that: Set<A>): Set<A>;
};

// @public (undocumented)
const union_2: <A>(E: Eq<A>) => (second: NonEmptyArray<A>) => (first: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public (undocumented)
const union_3: <A>(E: Eq<A>) => (second: ReadonlyNonEmptyArray<A>) => (first: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public (undocumented)
const union_4: <K, A>(E: Eq<K>, M: Magma<A>) => (second: Map<K, A>) => (first: Map<K, A>) => Map<K, A>;

// @public
function union_5<A>(E: Eq<A>): {
    (xs: ReadonlyArray<A>): (ys: ReadonlyArray<A>) => ReadonlyArray<A>;
    (xs: ReadonlyArray<A>, ys: ReadonlyArray<A>): ReadonlyArray<A>;
};

// @public (undocumented)
const union_6: <K, A>(E: Eq<K>, M: Magma<A>) => (second: ReadonlyMap<K, A>) => (first: ReadonlyMap<K, A>) => ReadonlyMap<K, A>;

// @public
const union_7: <A>(M: Magma<A>) => (second: Readonly<Record<string, A>>) => (first: Readonly<Record<string, A>>) => Readonly<Record<string, A>>;

// @public
function union_8<A>(E: Eq<A>): {
    (that: ReadonlySet<A>): (me: ReadonlySet<A>) => ReadonlySet<A>;
    (me: ReadonlySet<A>, that: ReadonlySet<A>): ReadonlySet<A>;
};

// @public
const union_9: <A>(M: Magma<A>) => (second: Record<string, A>) => (first: Record<string, A>) => Record<string, A>;

// @public
const uniq: <A>(E: Eq<A>) => (as: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public
const uniq_2: <A>(E: Eq<A>) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public
const uniq_3: <A>(E: Eq<A>) => (as: A[]) => A[];

// @public
const uniq_4: <A>(E: Eq<A>) => (as: readonly A[]) => readonly A[];

// @public
const unprepend: <A>(as: ReadonlyNonEmptyArray<A>) => readonly [A, readonly A[]];

// @public
const unprepend_2: <A>(as: NonEmptyArray<A>) => [A, A[]];

// @public (undocumented)
const unsafeCoerce: <A, B>(a: A) => B;

// @public (undocumented)
const unsafeDeleteAt: <A>(i: number, as: A[]) => A[];

// @public (undocumented)
const unsafeDeleteAt_2: <A>(i: number, as: readonly A[]) => readonly A[];

// @public (undocumented)
const unsafeInsertAt: <A>(i: number, a: A, as: Array<A>) => NonEmptyArray<A>;

// @public (undocumented)
const unsafeInsertAt_2: <A>(i: number, a: A, as: ReadonlyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public (undocumented)
const unsafeUpdateAt: <A>(i: number, a: A, as: A[]) => A[];

// @public (undocumented)
const unsafeUpdateAt_2: <A>(i: number, a: A, as: readonly A[]) => readonly A[];

// @public @deprecated
const unsnoc: <A>(as: ReadonlyNonEmptyArray<A>) => readonly [ReadonlyArray<A>, A];

// @public @deprecated
const unsnoc_2: <A>(as: NonEmptyArray<A>) => [Array<A>, A];

// @public (undocumented)
function untilSome<M extends URIS4>(M: ChainRec4<M>): <S, R, E, A>(ma: Kind4<M, S, R, E, option.Option<A>>) => Kind4<M, S, R, E, A>;

// @public (undocumented)
function untilSome<M extends URIS3>(M: ChainRec3<M>): <R, E, A>(ma: Kind3<M, R, E, option.Option<A>>) => Kind3<M, R, E, A>;

// @public (undocumented)
function untilSome<M extends URIS3, E>(M: ChainRec3C<M, E>): <R, A>(ma: Kind3<M, R, E, option.Option<A>>) => Kind3<M, R, E, A>;

// @public (undocumented)
function untilSome<M extends URIS2>(M: ChainRec2<M>): <E, A>(ma: Kind2<M, E, option.Option<A>>) => Kind2<M, E, A>;

// @public (undocumented)
function untilSome<M extends URIS2, E>(M: ChainRec2C<M, E>): <A>(ma: Kind2<M, E, option.Option<A>>) => Kind2<M, E, A>;

// @public (undocumented)
function untilSome<M extends URIS>(M: ChainRec1<M>): <A>(ma: Kind<M, option.Option<A>>) => Kind<M, A>;

// @public
function untupled<A extends ReadonlyArray<unknown>, B>(f: (a: A) => B): (...a: A) => B;

// @public (undocumented)
const unzip: <A, B>(abs: ReadonlyNonEmptyArray<readonly [A, B]>) => readonly [ReadonlyNonEmptyArray<A>, ReadonlyNonEmptyArray<B>];

// @public (undocumented)
const unzip_2: <A, B>(abs: NonEmptyArray<[A, B]>) => [NonEmptyArray<A>, NonEmptyArray<B>];

// @public
const unzip_3: <A, B>(as: [A, B][]) => [A[], B[]];

// @public
const unzip_4: <A, B>(as: readonly (readonly [A, B])[]) => readonly [readonly A[], readonly B[]];

// @public (undocumented)
const updateAt: <A>(i: number, a: A) => (as: ReadonlyNonEmptyArray<A>) => Option_2<ReadonlyNonEmptyArray<A>>;

// @public (undocumented)
const updateAt_2: <A>(i: number, a: A) => (as: NonEmptyArray<A>) => Option_2<NonEmptyArray<A>>;

// @public
const updateAt_3: <A>(i: number, a: A) => (as: A[]) => Option_2<A[]>;

// @public (undocumented)
const updateAt_4: <K>(E: Eq<K>) => <A>(k: K, a: A) => (m: Map<K, A>) => option.Option<Map<K, A>>;

// @public
const updateAt_5: <A>(i: number, a: A) => (as: readonly A[]) => Option_2<readonly A[]>;

// @public (undocumented)
const updateAt_6: <K>(E: Eq<K>) => <A>(k: K, a: A) => (m: ReadonlyMap<K, A>) => option.Option<ReadonlyMap<K, A>>;

// @public
const updateAt_7: <A>(k: string, a: A) => <K extends string>(r: Readonly<Record<K, A>>) => Option_2<Readonly<Record<K, A>>>;

// @public
const updateAt_8: <A>(k: string, a: A) => <K extends string>(r: Record<K, A>) => Option_2<Record<K, A>>;

// @public
const updateHead: <A>(a: A) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public
const updateHead_2: <A>(a: A) => (as: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public
const updateLast: <A>(a: A) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>;

// @public
const updateLast_2: <A>(a: A) => (as: NonEmptyArray<A>) => NonEmptyArray<A>;

// @public
const upsertAt: <K>(E: Eq<K>) => <A>(k: K, a: A) => (m: Map<K, A>) => Map<K, A>;

// @public
const upsertAt_2: <K>(E: Eq<K>) => <A>(k: K, a: A) => (m: ReadonlyMap<K, A>) => ReadonlyMap<K, A>;

// @public
const upsertAt_3: <A>(k: string, a: A) => (r: Readonly<Record<string, A>>) => Readonly<Record<string, A>>;

// @public
const upsertAt_4: <A>(k: string, a: A) => (r: Record<string, A>) => Record<string, A>;

// @public (undocumented)
const URI = "Ord";

// @public (undocumented)
type URI = typeof URI;

// @public (undocumented)
const URI_10 = "Endomorphism";

// @public (undocumented)
type URI_10 = typeof URI_10;

// @public (undocumented)
const URI_11 = "Identity";

// @public (undocumented)
type URI_11 = typeof URI_11;

// @public (undocumented)
const URI_12 = "IO";

// @public (undocumented)
type URI_12 = typeof URI_12;

// @public (undocumented)
const URI_13 = "IOEither";

// @public (undocumented)
type URI_13 = typeof URI_13;

// @public (undocumented)
const URI_14 = "IOOption";

// @public (undocumented)
type URI_14 = typeof URI_14;

// @public (undocumented)
const URI_15 = "Map";

// @public (undocumented)
type URI_15 = typeof URI_15;

// @public (undocumented)
const URI_16 = "Predicate";

// @public (undocumented)
type URI_16 = typeof URI_16;

// @public (undocumented)
const URI_17 = "Reader";

// @public (undocumented)
type URI_17 = typeof URI_17;

// @public (undocumented)
const URI_18 = "ReaderEither";

// @public (undocumented)
type URI_18 = typeof URI_18;

// @public (undocumented)
const URI_19 = "ReaderIO";

// @public (undocumented)
type URI_19 = typeof URI_19;

// @public (undocumented)
const URI_2 = "ReadonlyNonEmptyArray";

// @public (undocumented)
type URI_2 = typeof URI_2;

// @public (undocumented)
const URI_20 = "ReaderTask";

// @public (undocumented)
type URI_20 = typeof URI_20;

// @public (undocumented)
const URI_21 = "Task";

// @public (undocumented)
type URI_21 = typeof URI_21;

// @public (undocumented)
const URI_22 = "ReaderTaskEither";

// @public (undocumented)
type URI_22 = typeof URI_22;

// @public (undocumented)
const URI_23 = "TaskEither";

// @public (undocumented)
type URI_23 = typeof URI_23;

// @public (undocumented)
const URI_24 = "ReadonlyArray";

// @public (undocumented)
type URI_24 = typeof URI_24;

// @public (undocumented)
const URI_25 = "ReadonlyMap";

// @public (undocumented)
type URI_25 = typeof URI_25;

// @public (undocumented)
const URI_26 = "ReadonlyRecord";

// @public (undocumented)
type URI_26 = typeof URI_26;

// @public (undocumented)
const URI_27 = "ReadonlySet";

// @public (undocumented)
type URI_27 = typeof URI_27;

// @public (undocumented)
const URI_28 = "ReadonlyTuple";

// @public (undocumented)
type URI_28 = typeof URI_28;

// @public (undocumented)
const URI_29 = "Record";

// @public (undocumented)
type URI_29 = typeof URI_29;

// @public (undocumented)
const URI_3 = "NonEmptyArray";

// @public (undocumented)
type URI_3 = typeof URI_3;

// @public (undocumented)
const URI_30 = "State";

// @public (undocumented)
type URI_30 = typeof URI_30;

// @public (undocumented)
const URI_31 = "StateReaderTaskEither";

// @public (undocumented)
type URI_31 = typeof URI_31;

// @public (undocumented)
const URI_32 = "Store";

// @public (undocumented)
type URI_32 = typeof URI_32;

// @public (undocumented)
const URI_33 = "TaskOption";

// @public (undocumented)
type URI_33 = typeof URI_33;

// @public (undocumented)
const URI_34 = "TaskThese";

// @public (undocumented)
type URI_34 = typeof URI_34;

// @public (undocumented)
const URI_35 = "These";

// @public (undocumented)
type URI_35 = typeof URI_35;

// @public (undocumented)
const URI_36 = "Traced";

// @public (undocumented)
type URI_36 = typeof URI_36;

// @public (undocumented)
const URI_37 = "Tree";

// @public (undocumented)
type URI_37 = typeof URI_37;

// @public (undocumented)
const URI_38 = "Tuple";

// @public (undocumented)
type URI_38 = typeof URI_38;

// @public (undocumented)
const URI_39 = "Writer";

// @public (undocumented)
type URI_39 = typeof URI_39;

// @public (undocumented)
const URI_4 = "Array";

// @public (undocumented)
type URI_4 = typeof URI_4;

// @public (undocumented)
const URI_5 = "Separated";

// @public (undocumented)
type URI_5 = typeof URI_5;

// @public (undocumented)
const URI_6 = "Either";

// @public (undocumented)
type URI_6 = typeof URI_6;

// @public (undocumented)
const URI_7 = "Option";

// @public (undocumented)
type URI_7 = typeof URI_7;

// @public (undocumented)
const URI_8 = "Eq";

// @public (undocumented)
type URI_8 = typeof URI_8;

// @public (undocumented)
const URI_9 = "Const";

// @public (undocumented)
type URI_9 = typeof URI_9;

// @public
type URIS = keyof URItoKind<any>;

// @public
type URIS2 = keyof URItoKind2<any, any>;

// @public
type URIS3 = keyof URItoKind3<any, any, any>;

// @public
type URIS4 = keyof URItoKind4<any, any, any, any>;

// @public
interface URItoKind<A> {
}

// @public
interface URItoKind2<E, A> {
}

// @public
interface URItoKind3<R, E, A> {
}

// @public
interface URItoKind4<S, R, E, A> {
}

// @public @deprecated (undocumented)
interface ValidationM<M, E> extends ApplicativeCompositionHKT2C<M, either.URI, E> {
    // (undocumented)
    readonly alt: <A>(fa: ValidationT<M, E, A>, that: LazyArg<ValidationT<M, E, A>>) => ValidationT<M, E, A>;
    // (undocumented)
    readonly chain: <A, B>(ma: ValidationT<M, E, A>, f: (a: A) => ValidationT<M, E, B>) => ValidationT<M, E, B>;
}

// @public @deprecated (undocumented)
interface ValidationM1<M extends URIS, E> extends ApplicativeComposition12C<M, either.URI, E> {
    // (undocumented)
    readonly alt: <A>(fa: ValidationT1<M, E, A>, that: LazyArg<ValidationT1<M, E, A>>) => ValidationT1<M, E, A>;
    // (undocumented)
    readonly chain: <A, B>(ma: ValidationT1<M, E, A>, f: (a: A) => ValidationT1<M, E, B>) => ValidationT1<M, E, B>;
}

// @public @deprecated (undocumented)
interface ValidationM2<M extends URIS2, E> extends ApplicativeComposition22C<M, either.URI, E> {
    // (undocumented)
    readonly alt: <R, A>(fa: ValidationT2<M, R, E, A>, that: LazyArg<ValidationT2<M, R, E, A>>) => ValidationT2<M, R, E, A>;
    // (undocumented)
    readonly chain: <R, A, B>(ma: ValidationT2<M, R, E, A>, f: (a: A) => ValidationT2<M, R, E, B>) => ValidationT2<M, R, E, B>;
}

// @public @deprecated (undocumented)
interface ValidationT<M, E, A> extends HKT<M, Either<E, A>> {
}

declare namespace validationT {
    export {
        getValidationM,
        ValidationT,
        ValidationM,
        ValidationT1,
        ValidationM1,
        ValidationT2,
        ValidationM2
    }
}
export { validationT }

// @public @deprecated (undocumented)
type ValidationT1<M extends URIS, E, A> = Kind<M, Either<E, A>>;

// @public @deprecated (undocumented)
type ValidationT2<M extends URIS2, R, E, A> = Kind2<M, R, Either<E, A>>;

// @public
const values: <A>(O: Ord<A>) => <K>(m: Map<K, A>) => A[];

// @public
const values_2: <A>(O: Ord<A>) => <K>(m: ReadonlyMap<K, A>) => readonly A[];

declare namespace void {
    export {
        Semigroup_4 as Semigroup,
        Monoid_4 as Monoid
    }
}
export { void }

// @public (undocumented)
const warn: <A>(a: A) => IO<void>;

// @public (undocumented)
function whileSome<M extends URIS4, A>(M: ChainRec4<M>, Mn: monoid.Monoid<A>): <S, R, E>(ma: Kind4<M, S, R, E, option.Option<A>>) => Kind4<M, S, R, E, A>;

// @public (undocumented)
function whileSome<M extends URIS3, A>(M: ChainRec3<M>, Mn: monoid.Monoid<A>): <R, E>(ma: Kind3<M, R, E, option.Option<A>>) => Kind3<M, R, E, A>;

// @public (undocumented)
function whileSome<M extends URIS3, E, A>(M: ChainRec3C<M, E>, Mn: monoid.Monoid<A>): <R>(ma: Kind3<M, R, E, option.Option<A>>) => Kind3<M, R, E, A>;

// @public (undocumented)
function whileSome<M extends URIS2, A>(M: ChainRec2<M>, Mn: monoid.Monoid<A>): <E>(ma: Kind2<M, E, option.Option<A>>) => Kind2<M, E, A>;

// @public (undocumented)
function whileSome<M extends URIS2, E, A>(M: ChainRec2C<M, E>, Mn: monoid.Monoid<A>): (ma: Kind2<M, E, option.Option<A>>) => Kind2<M, E, A>;

// @public (undocumented)
function whileSome<M extends URIS, A>(M: ChainRec1<M>, Mn: monoid.Monoid<A>): (ma: Kind<M, option.Option<A>>) => Kind<M, A>;

// @public (undocumented)
interface Wilt<W> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, E, B, C>(wa: HKT<W, A>, f: (a: A) => Kind3<F, R, E, Either<B, C>>) => Kind3<F, R, E, Separated<HKT<W, B>, HKT<W, C>>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B, C>(wa: HKT<W, A>, f: (a: A) => Kind3<F, R, E, Either<B, C>>) => Kind3<F, R, E, Separated<HKT<W, B>, HKT<W, C>>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, E, B, C>(wa: HKT<W, A>, f: (a: A) => Kind2<F, E, Either<B, C>>) => Kind2<F, E, Separated<HKT<W, B>, HKT<W, C>>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B, C>(wa: HKT<W, A>, f: (a: A) => Kind2<F, E, Either<B, C>>) => Kind2<F, E, Separated<HKT<W, B>, HKT<W, C>>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B, C>(wa: HKT<W, A>, f: (a: A) => Kind<F, Either<B, C>>) => Kind<F, Separated<HKT<W, B>, HKT<W, C>>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B, C>(wa: HKT<W, A>, f: (a: A) => HKT<F, Either<B, C>>) => HKT<F, Separated<HKT<W, B>, HKT<W, C>>>;
}

// @public (undocumented)
const wilt: PipeableWilt1<URI_4>;

// @public (undocumented)
interface Wilt1<W extends URIS> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, E, B, C>(wa: Kind<W, A>, f: (a: A) => Kind3<F, R, E, Either<B, C>>) => Kind3<F, R, E, Separated<Kind<W, B>, Kind<W, C>>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B, C>(wa: Kind<W, A>, f: (a: A) => Kind3<F, R, E, Either<B, C>>) => Kind3<F, R, E, Separated<Kind<W, B>, Kind<W, C>>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, E, B, C>(wa: Kind<W, A>, f: (a: A) => Kind2<F, E, Either<B, C>>) => Kind2<F, E, Separated<Kind<W, B>, Kind<W, C>>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B, C>(wa: Kind<W, A>, f: (a: A) => Kind2<F, E, Either<B, C>>) => Kind2<F, E, Separated<Kind<W, B>, Kind<W, C>>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B, C>(wa: Kind<W, A>, f: (a: A) => Kind<F, Either<B, C>>) => Kind<F, Separated<Kind<W, B>, Kind<W, C>>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B, C>(wa: Kind<W, A>, f: (a: A) => HKT<F, Either<B, C>>) => HKT<F, Separated<Kind<W, B>, Kind<W, C>>>;
}

// @public (undocumented)
interface Wilt2<W extends URIS2> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <WE, A, R, FE, B, C>(wa: Kind2<W, WE, A>, f: (a: A) => Kind3<F, R, FE, Either<B, C>>) => Kind3<F, R, FE, Separated<Kind2<W, WE, B>, Kind2<W, WE, C>>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <WE, A, FE, B, C>(wa: Kind2<W, WE, A>, f: (a: A) => Kind2<F, FE, Either<B, C>>) => Kind2<F, FE, Separated<Kind2<W, WE, B>, Kind2<W, WE, C>>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <WE, A, B, C>(wa: Kind2<W, WE, A>, f: (a: A) => Kind2<F, FE, Either<B, C>>) => Kind2<F, FE, Separated<Kind2<W, WE, B>, Kind2<W, WE, C>>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <E, A, B, C>(wa: Kind2<W, E, A>, f: (a: A) => Kind<F, Either<B, C>>) => Kind<F, Separated<Kind2<W, E, B>, Kind2<W, E, C>>>;
    // (undocumented)
    <F>(F: Applicative<F>): <E, A, B, C>(wa: Kind2<W, E, A>, f: (a: A) => HKT<F, Either<B, C>>) => HKT<F, Separated<Kind2<W, E, B>, Kind2<W, E, C>>>;
}

// @public (undocumented)
interface Wilt2C<W extends URIS2, E> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, FE, B, C>(wa: Kind2<W, E, A>, f: (a: A) => Kind3<F, R, FE, Either<B, C>>) => Kind3<F, R, FE, Separated<Kind2<W, E, B>, Kind2<W, E, C>>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, FE, B, C>(wa: Kind2<W, E, A>, f: (a: A) => Kind2<F, FE, Either<B, C>>) => Kind2<F, FE, Separated<Kind2<W, E, B>, Kind2<W, E, C>>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <A, B, C>(wa: Kind2<W, E, A>, f: (a: A) => Kind2<F, FE, Either<B, C>>) => Kind2<F, FE, Separated<Kind2<W, E, B>, Kind2<W, E, C>>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B, C>(wa: Kind2<W, E, A>, f: (a: A) => Kind<F, Either<B, C>>) => Kind<F, Separated<Kind2<W, E, B>, Kind2<W, E, C>>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B, C>(wa: Kind2<W, E, A>, f: (a: A) => HKT<F, Either<B, C>>) => HKT<F, Separated<Kind2<W, E, B>, Kind2<W, E, C>>>;
}

// @public (undocumented)
interface Wilt3<W extends URIS3> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <WR, WE, A, FR, FE, B, C>(wa: Kind3<W, WR, WE, A>, f: (a: A) => Kind3<F, FR, FE, Either<B, C>>) => Kind3<F, FR, FE, Separated<Kind3<W, WR, WE, B>, Kind3<W, WR, WE, C>>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <R, WE, A, FE, B, C>(wa: Kind3<W, R, WE, A>, f: (a: A) => Kind2<F, FE, Either<B, C>>) => Kind2<F, FE, Separated<Kind3<W, R, WE, B>, Kind3<W, R, WE, C>>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <R, WE, A, B, C>(wa: Kind3<W, R, WE, A>, f: (a: A) => Kind2<F, FE, Either<B, C>>) => Kind2<F, FE, Separated<Kind3<W, R, WE, B>, Kind3<W, R, WE, C>>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <R, E, A, B, C>(wa: Kind3<W, R, E, A>, f: (a: A) => Kind<F, Either<B, C>>) => Kind<F, Separated<Kind3<W, R, E, B>, Kind3<W, R, E, C>>>;
    // (undocumented)
    <F>(F: Applicative<F>): <R, E, A, B, C>(wa: Kind3<W, R, E, A>, f: (a: A) => HKT<F, Either<B, C>>) => HKT<F, Separated<Kind3<W, R, E, B>, Kind3<W, R, E, C>>>;
}

// @public (undocumented)
const wilt_2: PipeableWilt1<URI_7>;

// @public (undocumented)
const wilt_3: PipeableWilt1<URI_24>;

// @public (undocumented)
const wilt_4: PipeableWilt1<URI_26>;

// @public (undocumented)
const wilt_5: PipeableWilt1<URI_29>;

// @public
function wiltDefault<W extends URIS2, E>(T: Traversable2C<W, E>, C: Compactable2<W>): Witherable2C<W, E>['wilt'];

// @public (undocumented)
function wiltDefault<W extends URIS2, E>(T: Traversable2<W>, C: Compactable2C<W, E>): Witherable2C<W, E>['wilt'];

// @public (undocumented)
function wiltDefault<W extends URIS>(T: Traversable1<W>, C: Compactable1<W>): Witherable1<W>['wilt'];

// @public (undocumented)
function wiltDefault<W>(T: Traversable_12<W>, C: Compactable_3<W>): Witherable_6<W>['wilt'];

// @public (undocumented)
interface Wither<W> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, E, B>(ta: HKT<W, A>, f: (a: A) => Kind3<F, R, E, Option_2<B>>) => Kind3<F, R, E, HKT<W, B>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B>(ta: HKT<W, A>, f: (a: A) => Kind3<F, R, E, Option_2<B>>) => Kind3<F, R, E, HKT<W, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, E, B>(ta: HKT<W, A>, f: (a: A) => Kind2<F, E, Option_2<B>>) => Kind2<F, E, HKT<W, B>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B>(ta: HKT<W, A>, f: (a: A) => Kind2<F, E, Option_2<B>>) => Kind2<F, E, HKT<W, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(ta: HKT<W, A>, f: (a: A) => Kind<F, Option_2<B>>) => Kind<F, HKT<W, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(ta: HKT<W, A>, f: (a: A) => HKT<F, Option_2<B>>) => HKT<F, HKT<W, B>>;
}

// @public (undocumented)
const wither: PipeableWither1<URI_4>;

// @public (undocumented)
interface Wither1<W extends URIS> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, E, B>(ta: Kind<W, A>, f: (a: A) => Kind3<F, R, E, Option_2<B>>) => Kind3<F, R, E, Kind<W, B>>;
    // (undocumented)
    <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B>(ta: Kind<W, A>, f: (a: A) => Kind3<F, R, E, Option_2<B>>) => Kind3<F, R, E, Kind<W, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, E, B>(ta: Kind<W, A>, f: (a: A) => Kind2<F, E, Option_2<B>>) => Kind2<F, E, Kind<W, B>>;
    // (undocumented)
    <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B>(ta: Kind<W, A>, f: (a: A) => Kind2<F, E, Option_2<B>>) => Kind2<F, E, Kind<W, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(ta: Kind<W, A>, f: (a: A) => Kind<F, Option_2<B>>) => Kind<F, Kind<W, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(ta: Kind<W, A>, f: (a: A) => HKT<F, Option_2<B>>) => HKT<F, Kind<W, B>>;
}

// @public (undocumented)
interface Wither2<W extends URIS2> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <WE, A, R, FE, B>(ta: Kind2<W, WE, A>, f: (a: A) => Kind3<F, R, FE, Option_2<B>>) => Kind3<F, R, FE, Kind2<W, WE, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <WE, A, FE, B>(ta: Kind2<W, WE, A>, f: (a: A) => Kind2<F, FE, Option_2<B>>) => Kind2<F, FE, Kind2<W, WE, B>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <WE, A, B>(ta: Kind2<W, WE, A>, f: (a: A) => Kind2<F, FE, Option_2<B>>) => Kind2<F, FE, Kind2<W, WE, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <E, A, B>(ta: Kind2<W, E, A>, f: (a: A) => Kind<F, Option_2<B>>) => Kind<F, Kind2<W, E, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <E, A, B>(ta: Kind2<W, E, A>, f: (a: A) => HKT<F, Option_2<B>>) => HKT<F, Kind2<W, E, B>>;
}

// @public (undocumented)
interface Wither2C<W extends URIS2, E> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <A, R, FE, B>(ta: Kind2<W, E, A>, f: (a: A) => Kind3<F, R, FE, Option_2<B>>) => Kind3<F, R, FE, Kind2<W, E, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <A, FE, B>(ta: Kind2<W, E, A>, f: (a: A) => Kind2<F, FE, Option_2<B>>) => Kind2<F, FE, Kind2<W, E, B>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <A, B>(ta: Kind2<W, E, A>, f: (a: A) => Kind2<F, FE, Option_2<B>>) => Kind2<F, FE, Kind2<W, E, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <A, B>(ta: Kind2<W, E, A>, f: (a: A) => Kind<F, Option_2<B>>) => Kind<F, Kind2<W, E, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <A, B>(ta: Kind2<W, E, A>, f: (a: A) => HKT<F, Option_2<B>>) => HKT<F, Kind2<W, E, B>>;
}

// @public (undocumented)
interface Wither3<W extends URIS3> {
    // (undocumented)
    <F extends URIS3>(F: Applicative3<F>): <WR, WE, A, FR, FE, B>(ta: Kind3<W, WR, WE, A>, f: (a: A) => Kind3<F, FR, FE, Option_2<B>>) => Kind3<F, FR, FE, Kind3<W, WR, WE, B>>;
    // (undocumented)
    <F extends URIS2>(F: Applicative2<F>): <WR, WE, A, FE, B>(ta: Kind3<W, WR, WE, A>, f: (a: A) => Kind2<F, FE, Option_2<B>>) => Kind2<F, FE, Kind3<W, WR, WE, B>>;
    // (undocumented)
    <F extends URIS2, FE>(F: Applicative2C<F, FE>): <R, WE, A, B>(ta: Kind3<W, R, WE, A>, f: (a: A) => Kind2<F, FE, Option_2<B>>) => Kind2<F, FE, Kind3<W, R, WE, B>>;
    // (undocumented)
    <F extends URIS>(F: Applicative1<F>): <R, E, A, B>(ta: Kind3<W, R, E, A>, f: (a: A) => Kind<F, Option_2<B>>) => Kind<F, Kind3<W, R, E, B>>;
    // (undocumented)
    <F>(F: Applicative<F>): <R, E, A, B>(ta: Kind3<W, R, E, A>, f: (a: A) => HKT<F, Option_2<B>>) => HKT<F, Kind3<W, R, E, B>>;
}

// @public (undocumented)
const wither_2: PipeableWither1<URI_7>;

// @public (undocumented)
const wither_3: PipeableWither1<URI_24>;

// @public (undocumented)
const wither_4: PipeableWither1<URI_26>;

// @public (undocumented)
const wither_5: PipeableWither1<URI_29>;

// @public (undocumented)
const Witherable: Witherable1<URI_4>;

declare namespace witherable {
    export {
        wiltDefault,
        witherDefault,
        filterE_3 as filterE,
        Witherable_6 as Witherable,
        Witherable1,
        Witherable2,
        Witherable2C,
        Witherable3,
        Wither,
        Wither1,
        Wither2,
        Wither2C,
        Wither3,
        Wilt,
        Wilt1,
        Wilt2,
        Wilt2C,
        Wilt3,
        PipeableWither,
        PipeableWither1,
        PipeableWither2,
        PipeableWither2C,
        PipeableWither3,
        PipeableWilt,
        PipeableWilt1,
        PipeableWilt2,
        PipeableWilt2C,
        PipeableWilt3,
        FilterE1
    }
}
export { witherable }

// @public (undocumented)
interface Witherable1<T extends URIS> extends Traversable1<T>, Filterable1<T> {
    // (undocumented)
    readonly wilt: Wilt1<T>;
    // (undocumented)
    readonly wither: Wither1<T>;
}

// @public (undocumented)
interface Witherable2<T extends URIS2> extends Traversable2<T>, Filterable2<T> {
    // (undocumented)
    readonly wilt: Wilt2<T>;
    // (undocumented)
    readonly wither: Wither2<T>;
}

// @public (undocumented)
interface Witherable2C<T extends URIS2, TL> extends Traversable2C<T, TL>, Filterable2C<T, TL> {
    // (undocumented)
    readonly wilt: Wilt2C<T, TL>;
    // (undocumented)
    readonly wither: Wither2C<T, TL>;
}

// @public (undocumented)
interface Witherable3<T extends URIS3> extends Traversable3<T>, Filterable3<T> {
    // (undocumented)
    readonly wilt: Wilt3<T>;
    // (undocumented)
    readonly wither: Wither3<T>;
}

// @public (undocumented)
const Witherable_2: Witherable1<URI_7>;

// @public (undocumented)
const Witherable_3: Witherable1<URI_24>;

// @public @deprecated
const Witherable_4: Witherable1<URI_26>;

// @public @deprecated
const Witherable_5: Witherable1<URI_29>;

// @public (undocumented)
interface Witherable_6<T> extends Traversable_12<T>, Filterable_3<T> {
    readonly wilt: Wilt<T>;
    readonly wither: Wither<T>;
}

// @public
function witherDefault<W extends URIS2, E>(T: Traversable2C<W, E>, C: Compactable2<W>): Witherable2C<W, E>['wither'];

// @public (undocumented)
function witherDefault<W extends URIS2, E>(T: Traversable2<W>, C: Compactable2C<W, E>): Witherable2C<W, E>['wither'];

// @public (undocumented)
function witherDefault<W extends URIS>(T: Traversable1<W>, C: Compactable1<W>): Witherable1<W>['wither'];

// @public (undocumented)
function witherDefault<W>(T: Traversable_12<W>, C: Compactable_3<W>): Witherable_6<W>['wither'];

// @public (undocumented)
interface Writer<W, A> {
    // (undocumented)
    (): [A, W];
}

declare namespace writer {
    export {
        getChain_5 as getChain,
        getMonad_5 as getMonad,
        Writer,
        tell,
        listen_2 as listen,
        pass,
        listens_2 as listens,
        censor_2 as censor,
        map_44 as map,
        URI_39 as URI,
        getPointed,
        getApply_6 as getApply,
        getApplicative_6 as getApplicative,
        Functor_35 as Functor,
        flap_35 as flap,
        evaluate_4 as evaluate,
        execute_4 as execute,
        evalWriter,
        execWriter,
        writer_2 as writer
    }
}
export { writer }

// @public @deprecated
const writer_2: Functor2<URI_39>;

// @public (undocumented)
interface WriterM<M> {
    // (undocumented)
    readonly censor: <W, A>(fa: WriterT<M, W, A>, f: (w: W) => W) => WriterT<M, W, A>;
    // (undocumented)
    readonly evalWriter: <W, A>(fa: WriterT<M, W, A>) => HKT<M, A>;
    // (undocumented)
    readonly execWriter: <W, A>(fa: WriterT<M, W, A>) => HKT<M, W>;
    // (undocumented)
    readonly getMonad: <W>(M: Monoid<W>) => {
        readonly _E: W;
        readonly map: <A, B>(ma: WriterT<M, W, A>, f: (a: A) => B) => WriterT<M, W, B>;
        readonly of: <A>(a: A) => WriterT<M, W, A>;
        readonly ap: <A, B>(mab: WriterT<M, W, (a: A) => B>, ma: WriterT<M, W, A>) => WriterT<M, W, B>;
        readonly chain: <A, B>(ma: WriterT<M, W, A>, f: (a: A) => WriterT<M, W, B>) => WriterT<M, W, B>;
    };
    // (undocumented)
    readonly listen: <W, A>(fa: WriterT<M, W, A>) => WriterT<M, W, [A, W]>;
    // (undocumented)
    readonly listens: <W, A, B>(fa: WriterT<M, W, A>, f: (w: W) => B) => WriterT<M, W, [A, B]>;
    // (undocumented)
    readonly map: <W, A, B>(fa: WriterT<M, W, A>, f: (a: A) => B) => WriterT<M, W, B>;
    // (undocumented)
    readonly pass: <W, A>(fa: WriterT<M, W, [A, (w: W) => W]>) => WriterT<M, W, A>;
    // (undocumented)
    readonly tell: <W>(w: W) => WriterT<M, W, void>;
}

// @public (undocumented)
interface WriterM1<M extends URIS> {
    // (undocumented)
    readonly censor: <W, A>(fa: WriterT1<M, W, A>, f: (w: W) => W) => WriterT1<M, W, A>;
    // (undocumented)
    readonly evalWriter: <W, A>(fa: WriterT1<M, W, A>) => Kind<M, A>;
    // (undocumented)
    readonly execWriter: <W, A>(fa: WriterT1<M, W, A>) => Kind<M, W>;
    // (undocumented)
    readonly getMonad: <W>(M: Monoid<W>) => {
        readonly _E: W;
        readonly map: <A, B>(ma: WriterT1<M, W, A>, f: (a: A) => B) => WriterT1<M, W, B>;
        readonly of: <A>(a: A) => WriterT1<M, W, A>;
        readonly ap: <A, B>(mab: WriterT1<M, W, (a: A) => B>, ma: WriterT1<M, W, A>) => WriterT1<M, W, B>;
        readonly chain: <A, B>(ma: WriterT1<M, W, A>, f: (a: A) => WriterT1<M, W, B>) => WriterT1<M, W, B>;
    };
    // (undocumented)
    readonly listen: <W, A>(fa: WriterT1<M, W, A>) => WriterT1<M, W, [A, W]>;
    // (undocumented)
    readonly listens: <W, A, B>(fa: WriterT1<M, W, A>, f: (w: W) => B) => WriterT1<M, W, [A, B]>;
    // (undocumented)
    readonly map: <W, A, B>(fa: WriterT1<M, W, A>, f: (a: A) => B) => WriterT1<M, W, B>;
    // (undocumented)
    readonly pass: <W, A>(fa: WriterT1<M, W, [A, (w: W) => W]>) => WriterT1<M, W, A>;
    // (undocumented)
    readonly tell: <W>(w: W) => WriterT1<M, W, void>;
}

// @public (undocumented)
interface WriterM2<M extends URIS2> {
    // (undocumented)
    readonly censor: <E, W, A>(fa: WriterT2<M, E, W, A>, f: (w: W) => W) => WriterT2<M, E, W, A>;
    // (undocumented)
    readonly evalWriter: <E, W, A>(fa: WriterT2<M, E, W, A>) => Kind2<M, E, A>;
    // (undocumented)
    readonly execWriter: <E, W, A>(fa: WriterT2<M, E, W, A>) => Kind2<M, E, W>;
    // (undocumented)
    readonly getMonad: <W>(M: Monoid<W>) => {
        readonly _E: W;
        readonly map: <E, A, B>(ma: WriterT2<M, E, W, A>, f: (a: A) => B) => WriterT2<M, E, W, B>;
        readonly of: <E, A>(a: A) => WriterT2<M, E, W, A>;
        readonly ap: <E, A, B>(mab: WriterT2<M, E, W, (a: A) => B>, ma: WriterT2<M, E, W, A>) => WriterT2<M, E, W, B>;
        readonly chain: <E, A, B>(ma: WriterT2<M, E, W, A>, f: (a: A) => WriterT2<M, E, W, B>) => WriterT2<M, E, W, B>;
    };
    // (undocumented)
    readonly listen: <E, W, A>(fa: WriterT2<M, E, W, A>) => WriterT2<M, E, W, [A, W]>;
    // (undocumented)
    readonly listens: <E, W, A, B>(fa: WriterT2<M, E, W, A>, f: (w: W) => B) => WriterT2<M, E, W, [A, B]>;
    // (undocumented)
    readonly map: <E, W, A, B>(fa: WriterT2<M, E, W, A>, f: (a: A) => B) => WriterT2<M, E, W, B>;
    // (undocumented)
    readonly pass: <E, W, A>(fa: WriterT2<M, E, W, [A, (w: W) => W]>) => WriterT2<M, E, W, A>;
    // (undocumented)
    readonly tell: <E, W>(w: W) => WriterT2<M, E, W, void>;
}

// @public (undocumented)
interface WriterM2C<M extends URIS2, E> {
    // (undocumented)
    readonly censor: <W, A>(fa: WriterT2<M, E, W, A>, f: (w: W) => W) => WriterT2<M, E, W, A>;
    // (undocumented)
    readonly evalWriter: <W, A>(fa: WriterT2<M, E, W, A>) => Kind2<M, E, A>;
    // (undocumented)
    readonly execWriter: <W, A>(fa: WriterT2<M, E, W, A>) => Kind2<M, E, W>;
    // (undocumented)
    readonly getMonad: <W>(M: Monoid<W>) => {
        readonly _E: W;
        readonly map: <A, B>(ma: WriterT2<M, E, W, A>, f: (a: A) => B) => WriterT2<M, E, W, B>;
        readonly of: <A>(a: A) => WriterT2<M, E, W, A>;
        readonly ap: <A, B>(mab: WriterT2<M, E, W, (a: A) => B>, ma: WriterT2<M, E, W, A>) => WriterT2<M, E, W, B>;
        readonly chain: <A, B>(ma: WriterT2<M, E, W, A>, f: (a: A) => WriterT2<M, E, W, B>) => WriterT2<M, E, W, B>;
    };
    // (undocumented)
    readonly listen: <W, A>(fa: WriterT2<M, E, W, A>) => WriterT2<M, E, W, [A, W]>;
    // (undocumented)
    readonly listens: <W, A, B>(fa: WriterT2<M, E, W, A>, f: (w: W) => B) => WriterT2<M, E, W, [A, B]>;
    // (undocumented)
    readonly map: <W, A, B>(fa: WriterT2<M, E, W, A>, f: (a: A) => B) => WriterT2<M, E, W, B>;
    // (undocumented)
    readonly pass: <W, A>(fa: WriterT2<M, E, W, [A, (w: W) => W]>) => WriterT2<M, E, W, A>;
    // (undocumented)
    readonly tell: <W>(w: W) => WriterT2<M, E, W, void>;
}

// @public (undocumented)
interface WriterM3<M extends URIS3> {
    // (undocumented)
    readonly censor: <R, E, W, A>(fa: WriterT3<M, R, E, W, A>, f: (w: W) => W) => WriterT3<M, R, E, W, A>;
    // (undocumented)
    readonly evalWriter: <R, E, W, A>(fa: WriterT3<M, R, E, W, A>) => Kind3<M, R, E, A>;
    // (undocumented)
    readonly execWriter: <R, E, W, A>(fa: WriterT3<M, R, E, W, A>) => Kind3<M, R, E, W>;
    // (undocumented)
    readonly getMonad: <W>(M: Monoid<W>) => {
        readonly _E: W;
        readonly map: <R, E, A, B>(ma: WriterT3<M, R, E, W, A>, f: (a: A) => B) => WriterT3<M, R, E, W, B>;
        readonly of: <R, E, A>(a: A) => WriterT3<M, R, E, W, A>;
        readonly ap: <R, E, A, B>(mab: WriterT3<M, R, E, W, (a: A) => B>, ma: WriterT3<M, R, E, W, A>) => WriterT3<M, R, E, W, B>;
        readonly chain: <R, E, A, B>(ma: WriterT3<M, R, E, W, A>, f: (a: A) => WriterT3<M, R, E, W, B>) => WriterT3<M, R, E, W, B>;
    };
    // (undocumented)
    readonly listen: <R, E, W, A>(fa: WriterT3<M, R, E, W, A>) => WriterT3<M, R, E, W, [A, W]>;
    // (undocumented)
    readonly listens: <R, E, W, A, B>(fa: WriterT3<M, R, E, W, A>, f: (w: W) => B) => WriterT3<M, R, E, W, [A, B]>;
    // (undocumented)
    readonly map: <R, E, W, A, B>(fa: WriterT3<M, R, E, W, A>, f: (a: A) => B) => WriterT3<M, R, E, W, B>;
    // (undocumented)
    readonly pass: <R, E, W, A>(fa: WriterT3<M, R, E, W, [A, (w: W) => W]>) => WriterT3<M, R, E, W, A>;
    // (undocumented)
    readonly tell: <R, E, W>(w: W) => WriterT3<M, R, E, W, void>;
}

// @public (undocumented)
interface WriterT<M, W, A> {
    // (undocumented)
    (): HKT<M, [A, W]>;
}

declare namespace writerT {
    export {
        getWriterM,
        WriterT,
        WriterM,
        WriterT1,
        WriterM1,
        WriterT2,
        WriterM2,
        WriterM2C,
        WriterT3,
        WriterM3
    }
}
export { writerT }

// @public (undocumented)
interface WriterT1<M extends URIS, W, A> {
    // (undocumented)
    (): Kind<M, [A, W]>;
}

// @public (undocumented)
interface WriterT2<M extends URIS2, E, W, A> {
    // (undocumented)
    (): Kind2<M, E, [A, W]>;
}

// @public (undocumented)
interface WriterT3<M extends URIS3, R, E, W, A> {
    // (undocumented)
    (): Kind3<M, R, E, [A, W]>;
}

// @public (undocumented)
interface Zero<F> {
    // (undocumented)
    readonly URI: F;
    // (undocumented)
    readonly zero: <A>() => HKT<F, A>;
}

declare namespace zero {
    export {
        guard_6 as guard,
        Zero,
        Zero1,
        Zero2,
        Zero2C,
        Zero3,
        Zero3C,
        Zero4
    }
}
export { zero }

// @public (undocumented)
interface Zero1<F extends URIS> {
    // (undocumented)
    readonly URI: F;
    // (undocumented)
    readonly zero: <A>() => Kind<F, A>;
}

// @public (undocumented)
interface Zero2<F extends URIS2> {
    // (undocumented)
    readonly URI: F;
    // (undocumented)
    readonly zero: <E, A>() => Kind2<F, E, A>;
}

// @public (undocumented)
interface Zero2C<F extends URIS2, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly URI: F;
    // (undocumented)
    readonly zero: <A>() => Kind2<F, E, A>;
}

// @public (undocumented)
interface Zero3<F extends URIS3> {
    // (undocumented)
    readonly URI: F;
    // (undocumented)
    readonly zero: <R, E, A>() => Kind3<F, R, E, A>;
}

// @public (undocumented)
interface Zero3C<F extends URIS3, E> {
    // (undocumented)
    readonly _E: E;
    // (undocumented)
    readonly URI: F;
    // (undocumented)
    readonly zero: <R, A>() => Kind3<F, R, E, A>;
}

// @public (undocumented)
interface Zero4<F extends URIS4> {
    // (undocumented)
    readonly URI: F;
    // (undocumented)
    readonly zero: <S, R, E, A>() => Kind4<F, S, R, E, A>;
}

// @public (undocumented)
const Zero_2: Zero1<URI_4>;

// @public
const zero_2: <A>() => Array<A>;

// @public (undocumented)
const Zero_3: Zero1<URI_7>;

// @public (undocumented)
const zero_3: <A>() => Option_2<A>;

// @public (undocumented)
const Zero_4: Zero1<URI_14>;

// @public (undocumented)
const zero_4: <A>() => IOOption<A>;

// @public (undocumented)
const Zero_5: Zero1<URI_24>;

// @public (undocumented)
function zero_5<F extends URIS4>(F: Pointed4<F>): <S, R, E, A>() => Kind4<F, S, R, E, Option_2<A>>;

// @public (undocumented)
function zero_5<F extends URIS3>(F: Pointed3<F>): <R, E, A>() => Kind3<F, R, E, Option_2<A>>;

// @public (undocumented)
function zero_5<F extends URIS3, E>(F: Pointed3C<F, E>): <R, A>() => Kind3<F, R, E, Option_2<A>>;

// @public (undocumented)
function zero_5<F extends URIS2>(F: Pointed2<F>): <E, A>() => Kind2<F, E, Option_2<A>>;

// @public (undocumented)
function zero_5<F extends URIS2, E>(F: Pointed2C<F, E>): <A>() => Kind2<F, E, Option_2<A>>;

// @public (undocumented)
function zero_5<F extends URIS>(F: Pointed1<F>): <A>() => Kind<F, Option_2<A>>;

// @public (undocumented)
function zero_5<F>(F: Pointed<F>): <A>() => HKT<F, Option_2<A>>;

// @public (undocumented)
const Zero_6: Zero1<URI_33>;

// @public (undocumented)
const zero_6: <A>() => ReadonlyArray<A>;

// @public (undocumented)
const zero_7: <A, B extends A>() => Refinement<A, B>;

// @public (undocumented)
const zero_8: <A>() => TaskOption<A>;

// @public
function zip<B>(bs: Array<B>): <A>(as: Array<A>) => Array<[A, B]>;

// @public (undocumented)
function zip<A, B>(as: Array<A>, bs: Array<B>): Array<[A, B]>;

// @public (undocumented)
function zip_2<B>(bs: NonEmptyArray<B>): <A>(as: NonEmptyArray<A>) => NonEmptyArray<[A, B]>;

// @public (undocumented)
function zip_2<A, B>(as: NonEmptyArray<A>, bs: NonEmptyArray<B>): NonEmptyArray<[A, B]>;

// @public (undocumented)
function zip_3<B>(bs: ReadonlyNonEmptyArray<B>): <A>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<readonly [A, B]>;

// @public (undocumented)
function zip_3<A, B>(as: ReadonlyNonEmptyArray<A>, bs: ReadonlyNonEmptyArray<B>): ReadonlyNonEmptyArray<readonly [A, B]>;

// @public
function zip_4<B>(bs: ReadonlyArray<B>): <A>(as: ReadonlyArray<A>) => ReadonlyArray<readonly [A, B]>;

// @public (undocumented)
function zip_4<A, B>(as: ReadonlyArray<A>, bs: ReadonlyArray<B>): ReadonlyArray<readonly [A, B]>;

// @public (undocumented)
const zipWith: <A, B, C>(as: ReadonlyNonEmptyArray<A>, bs: ReadonlyNonEmptyArray<B>, f: (a: A, b: B) => C) => ReadonlyNonEmptyArray<C>;

// @public (undocumented)
const zipWith_2: <A, B, C>(as: NonEmptyArray<A>, bs: NonEmptyArray<B>, f: (a: A, b: B) => C) => NonEmptyArray<C>;

// @public
const zipWith_3: <A, B, C>(fa: A[], fb: B[], f: (a: A, b: B) => C) => C[];

// @public
const zipWith_4: <A, B, C>(fa: readonly A[], fb: readonly B[], f: (a: A, b: B) => C) => readonly C[];

// (No @packageDocumentation comment for this package)

```
